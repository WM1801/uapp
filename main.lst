CCS PCD C Compiler, Version 5.051, 43599               18-апр-16 11:01

               Filename:   F:\work\UAPP\main.lst

               ROM used:   7182 bytes (16%)
                           Largest free fragment is 36850
               RAM used:   459 (6%) at main() level
                           541 (7%) worst case
               Stack used: 94 locations (40 in main + 54 for interrupts)
               Stack size: 128

*
0000:  GOTO    1AFA
*
000E:  DATA    3A,03,00
*
001C:  DATA    14,03,00
*
002A:  DATA    AC,02,00
*
0044:  DATA    66,02,00
*
004A:  DATA    EC,02,00
004C:  DATA    00,02,00
*
0074:  DATA    7E,06,00
.................... #include "main.h" 
.................... #include "24HJ64GP206.h" 
.................... //////////// Standard Header file for the PIC24HJ64GP206 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24HJ64GP206 
*
07CC:  MOV     W1,32
07CE:  CP0     W3
07D0:  BRA     Z,7F8
07D2:  BTSC.B  0.0
07D4:  BRA     7E2
07D6:  TBLRDL.B[W0++],[W2++]
07D8:  DEC     W3,W3
07DA:  BRA     Z,7F8
07DC:  TBLRDL.B[W0],[W2++]
07DE:  DEC     W3,W3
07E0:  BRA     Z,7F8
07E2:  DEC     W0,W0
07E4:  TBLRDH.B[W0++],[W2++]
07E6:  DEC     W3,W3
07E8:  BRA     Z,7F8
07EA:  CLR.B   [W2++]
07EC:  DEC     W3,W3
07EE:  INC     W0,W0
07F0:  CP0     W0
07F2:  BTSC.B  42.1
07F4:  INC     0032
07F6:  BRA     7CE
07F8:  RETURN  
*
0B08:  MOV     W5,[W15++]
0B0A:  MOV     W6,[W15++]
0B0C:  MOV     W7,[W15++]
0B0E:  XOR     W1,W3,W4
0B10:  BTSS    W4.F
0B12:  BRA     B20
0B14:  BCLR.B  42.0
0B16:  BCLR.B  42.1
0B18:  BTSS    W1.F
0B1A:  BRA     B68
0B1C:  BSET.B  42.0
0B1E:  BRA     B68
0B20:  MOV     W1,W4
0B22:  MOV     W0,W5
0B24:  MOV     W3,W6
0B26:  MOV     W2,W7
0B28:  RLC     W1,W1
0B2A:  SWAP    W1
0B2C:  RLC     W3,W3
0B2E:  SWAP    W3
0B30:  SUB.B   W3L,W1L,W1L
0B32:  BRA     Z,B3E
0B34:  BTSS    W4.F
0B36:  BRA     B68
0B38:  MOV     #1,W0
0B3A:  XOR.B   42
0B3C:  BRA     B68
0B3E:  MOV.B   W4L,W1L
0B40:  MOV.B   W6L,W3L
0B42:  BCLR    W1.7
0B44:  BCLR    W3.7
0B46:  SUB.B   W3L,W1L,W1L
0B48:  BRA     Z,B54
0B4A:  BTSS    W4.F
0B4C:  BRA     B68
0B4E:  MOV     #1,W0
0B50:  XOR.B   42
0B52:  BRA     B68
0B54:  SUB     W7,W5,W1
0B56:  BRA     Z,B62
0B58:  BTSS    W4.F
0B5A:  BRA     B68
0B5C:  MOV     #1,W0
0B5E:  XOR.B   42
0B60:  BRA     B68
0B62:  BCLR.B  42.0
0B64:  BRA     B68
0B66:  BRA     B68
0B68:  MOV     [--W15],W7
0B6A:  MOV     [--W15],W6
0B6C:  MOV     [--W15],W5
0B6E:  RETURN  
0B70:  MOV     W5,[W15++]
0B72:  MOV     W6,[W15++]
0B74:  MOV     #8E,W1
0B76:  BCLR    W6.0
0B78:  BTSS    W0.F
0B7A:  BRA     B82
0B7C:  BSET    W6.0
0B7E:  NEG     W0,W0
0B80:  BRA     B82
0B82:  CP0     W0
0B84:  BRA     Z,BAE
0B86:  BTSC    W0.F
0B88:  BRA     B92
0B8A:  BCLR.B  42.0
0B8C:  RLC     W0,W0
0B8E:  DEC     W1,W1
0B90:  BRA     B86
0B92:  SWAP    W1
0B94:  BCLR.B  42.0
0B96:  RRC     W1,W1
0B98:  BCLR    W0.F
0B9A:  SWAP    W0
0B9C:  XOR.B   W0L,W1L,W1L
0B9E:  AND.B   #0,W0L
0BA0:  BTSC    W6.0
0BA2:  BSET    W1.F
0BA4:  BRA     BB4
0BA6:  MOV.B   W1L,W0L
0BA8:  BSET    W1.7
0BAA:  AND.B   #0,W1L
0BAC:  BRA     BB4
0BAE:  CLR     W0
0BB0:  CLR     W1
0BB2:  BRA     BB4
0BB4:  MOV     [--W15],W6
0BB6:  MOV     [--W15],W5
0BB8:  RETURN  
0BBA:  MOV     W5,[W15++]
0BBC:  MOV     #C,W5
0BBE:  REPEAT  #4
0BC0:  MOV     [W5++],[W15++]
0BC2:  CLR     W9
0BC4:  XOR     W1,W3,W9
0BC6:  MOV     W1,W6
0BC8:  MOV     W0,W5
0BCA:  MOV     W3,W8
0BCC:  MOV     W2,W7
0BCE:  RLC     W1,W1
0BD0:  SWAP    W1
0BD2:  ZE      W1,W1
0BD4:  CP0     W1
0BD6:  BRA     Z,C74
0BD8:  RLC     W3,W3
0BDA:  SWAP    W3
0BDC:  ZE      W3,W3
0BDE:  CP0     W3
0BE0:  BRA     Z,C74
0BE2:  CLR     W0
0BE4:  SUB.B   W1L,W3L,W0L
0BE6:  BRA     NC,BEE
0BE8:  ADD.B   #7F,W0L
0BEA:  BRA     C,C74
0BEC:  BRA     BF4
0BEE:  SUB.B   #81,W0L
0BF0:  BRA     NC,C74
0BF2:  BRA     Z,C74
0BF4:  MOV     W5,W1
0BF6:  MOV     W6,W2
0BF8:  BSET    W2.7
0BFA:  AND     #FF,W2
0BFC:  AND     #FF,W8
0BFE:  BSET    W8.7
0C00:  MOV     #19,W10
0C02:  CLR     W3
0C04:  CLR     W4
0C06:  SUB     W1,W7,W1
0C08:  SUBB    W2,W8,W2
0C0A:  BRA     N,C10
0C0C:  BRA     C,C16
0C0E:  BRA     NZ,C18
0C10:  ADD     W1,W7,W1
0C12:  ADDC    W2,W8,W2
0C14:  BRA     C18
0C16:  BSET    W4.0
0C18:  DEC     W10,W10
0C1A:  BRA     Z,C2A
0C1C:  BCLR.B  42.0
0C1E:  RLC     W1,W1
0C20:  RLC     W2,W2
0C22:  BCLR.B  42.0
0C24:  RLC     W4,W4
0C26:  RLC     W3,W3
0C28:  BRA     C06
0C2A:  CLR     W10
0C2C:  BTSC    W3.8
0C2E:  BRA     C32
0C30:  BRA     C3E
0C32:  BCLR.B  42.0
0C34:  RRC     W3,W3
0C36:  BCLR    W3.7
0C38:  RRC     W4,W4
0C3A:  RLC     W10,W10
0C3C:  BRA     C42
0C3E:  DEC     W0,W0
0C40:  BRA     Z,C74
0C42:  BTSC    W10.F
0C44:  BRA     NC,C50
0C46:  RLC     W1,W1
0C48:  RLC     W2,W2
0C4A:  SUB     W1,W7,W1
0C4C:  SUBB    W2,W8,W2
0C4E:  BRA     NC,C62
0C50:  INC     W4,W4
0C52:  BRA     NZ,C62
0C54:  INC     W3,W3
0C56:  BRA     NZ,C62
0C58:  INC     W0,W0
0C5A:  BRA     Z,C74
0C5C:  BRA     C62
0C5E:  DEC     W0,W0
0C60:  BRA     Z,C74
0C62:  SWAP    W0
0C64:  RRC     W0,W1
0C66:  BSET    W1.F
0C68:  BTSS    W9.F
0C6A:  BCLR    W1.F
0C6C:  BCLR    W3.7
0C6E:  XOR.B   W3L,W1L,W1L
0C70:  MOV     W4,W0
0C72:  BRA     C7A
0C74:  MOV     #0,W0
0C76:  MOV     #0,W1
0C78:  BRA     C7A
0C7A:  MOV     #14,W5
0C7C:  REPEAT  #4
0C7E:  MOV     [--W15],[W5--]
0C80:  MOV     [--W15],W5
0C82:  RETURN  
*
151C:  MOV     W5,[W15++]
151E:  MOV     #C,W5
1520:  REPEAT  #4
1522:  MOV     [W5++],[W15++]
1524:  MOV     W0,W4
1526:  MOV     W1,W5
1528:  MOV     W3,W7
152A:  MOV     W2,W6
152C:  BCLR.B  42.0
152E:  BCLR.B  42.1
1530:  RLC     W1,W1
1532:  SWAP    W1
1534:  AND     #FF,W1
1536:  CP0     W1
1538:  BRA     Z,15D0
153A:  BCLR.B  42.0
153C:  BCLR.B  42.1
153E:  RLC     W3,W3
1540:  SWAP    W3
1542:  AND     #FF,W3
1544:  CP0     W3
1546:  BRA     Z,15D0
1548:  ZE      W0,W0
154A:  ADD.B   W3L,W1L,W0L
154C:  BRA     C,1556
154E:  SUB     #7F,W0
1550:  BRA     Z,15D0
1552:  BRA     NC,15D0
1554:  BRA     155A
1556:  ADD.B   #81,W0L
1558:  BRA     C,15D0
155A:  XOR     W5,W7,W10
155C:  BCLR.B  42.0
155E:  BCLR.B  42.1
1560:  AND     #FF,W5
1562:  BSET    W5.7
1564:  BCLR.B  42.0
1566:  AND     #FF,W7
1568:  BSET    W7.7
156A:  MUL.UU  W4,W6,W2
156C:  MUL.UU  W5,W6,W8
156E:  ADDC    W8,W3,W3
1570:  MOV     W9,W1
1572:  BTSC.B  42.0
1574:  INC     W1,W1
1576:  BCLR.B  42.0
1578:  MUL.UU  W7,W4,W8
157A:  ADDC    W8,W3,W3
157C:  ADDC    W9,W1,W1
157E:  MUL.UU  W5,W7,W8
1580:  ADDC    W8,W1,W1
1582:  INC     W0,W0
1584:  CP0     W1
1586:  BTSC.B  42.1
1588:  BRA     158C
158A:  BRA     1592
158C:  CP0     W3
158E:  BTSC.B  42.1
1590:  BRA     159C
1592:  BTSC    W1.F
1594:  BRA     159C
1596:  RLC     W3,W3
1598:  RLC     W1,W1
159A:  DEC     W0,W0
159C:  MOV     W1,W2
159E:  BCLR.B  42.0
15A0:  BTSS    W3.7
15A2:  BRA     15B6
15A4:  MOV     #FF00,W7
15A6:  AND     W3,W7,W3
15A8:  ADD     #100,W3
15AA:  ADDC    W2,#0,W2
15AC:  CP0     W2
15AE:  BRA     NZ,15B6
15B0:  CP0     W3
15B2:  BRA     NZ,15B6
15B4:  INC     W0,W0
15B6:  SWAP    W0
15B8:  BCLR.B  42.0
15BA:  BCLR.B  42.1
15BC:  RRC     W0,W1
15BE:  BTSC    W10.F
15C0:  BSET    W1.F
15C2:  BCLR    W2.F
15C4:  SWAP    W2
15C6:  XOR.B   W2L,W1L,W1L
15C8:  SWAP    W3
15CA:  MOV.B   W3L,W2L
15CC:  MOV     W2,W0
15CE:  BRA     15D6
15D0:  MOV     #0,W0
15D2:  MOV     #0,W1
15D4:  BRA     15D6
15D6:  MOV     #14,W5
15D8:  REPEAT  #4
15DA:  MOV     [--W15],[W5--]
15DC:  MOV     [--W15],W5
15DE:  RETURN  
15E0:  MOV     W0,W2
15E2:  MOV     W1,W3
15E4:  MOV.B   W1L,W0L
15E6:  SWAP    W0
15E8:  BSET    W0.F
15EA:  RLC     W1,W1
15EC:  SWAP    W1
15EE:  ZE      W1,W1
15F0:  MOV     #8E,W4
15F2:  SUB.B   W4L,W1L,W1L
15F4:  BRA     Z,1602
15F6:  CP0     W0
15F8:  BRA     Z,1602
15FA:  BCLR.B  42.0
15FC:  RRC     W0,W0
15FE:  DEC     W1,W1
1600:  BRA     NZ,15F6
1602:  BTSS    W3.F
1604:  BRA     160A
1606:  NEG     W0,W0
1608:  BRA     160A
160A:  RETURN  
....................  
.................... #list 
....................  
.................... #include "uart.h" 
....................  
....................  
.................... #word MCU_U1MODE = 0x220 
.................... #bit    MCU_STSEL = MCU_U1MODE.0 
.................... #bit    MCU_PDSEL0 = MCU_U1MODE.1 
.................... #bit    MCU_PDSEL1 = MCU_U1MODE.2 
.................... #bit    MCU_BRGH = MCU_U1MODE.3 
.................... #bit    MCU_URXINV = MCU_U1MODE.4 
.................... #bit    MCU_ABAUD = MCU_U1MODE.5 
.................... #bit    MCU_LPBACK = MCU_U1MODE.6 
.................... #bit    MCU_WAKE = MCU_U1MODE.7 
.................... #bit    MCU_UEN0 = MCU_U1MODE.8 
.................... #bit    MCU_UEN1 = MCU_U1MODE.9 
.................... #bit    MCU_RTSMD = MCU_U1MODE.11 
.................... #bit    MCU_IREN = MCU_U1MODE.12 
.................... #bit    MCU_USIDL = MCU_U1MODE.13 
.................... #bit    MCU_UARTEN = MCU_U1MODE.15 
.................... #word MCU_U1STA = 0x222 
.................... #bit    MCU_URXDA = MCU_U1STA.0 
.................... #bit    MCU_OERR = MCU_U1STA.1 
.................... #bit    MCU_FERR = MCU_U1STA.2 
.................... #bit    MCU_PERR = MCU_U1STA.3 
.................... #bit    MCU_RIDLE = MCU_U1STA.4 
.................... #bit    MCU_ADDEN = MCU_U1STA.5 
.................... #bit    MCU_URXISEL0 = MCU_U1STA.6 
.................... #bit    MCU_URXISEL1 = MCU_U1STA.7 
.................... #bit    MCU_TRMT = MCU_U1STA.8 
.................... #bit    MCU_UTXBF = MCU_U1STA.9 
.................... #bit    MCU_UTXEN = MCU_U1STA.10 
.................... #bit    MCU_UTXBRK = MCU_U1STA.11 
.................... #bit    MCU_UTXISEL0 = MCU_U1STA.13 
.................... #bit    MCU_UTXINV = MCU_U1STA.14 
.................... #bit    MCU_UTXISEL1 = MCU_U1STA.15 
.................... #word MCU_U1TXREG = 0x224 
.................... //#word MCU_U1TXREG = 0x224 
.................... #bit    MCU_UTXREG0 = MCU_U1TXREG.0 
.................... #bit    MCU_UTXREG1 = MCU_U1TXREG.1 
.................... #bit    MCU_UTXREG2 = MCU_U1TXREG.2 
.................... #bit    MCU_UTXREG3 = MCU_U1TXREG.3 
.................... #bit    MCU_UTXREG4 = MCU_U1TXREG.4 
.................... #bit    MCU_UTXREG5 = MCU_U1TXREG.5 
.................... #bit    MCU_UTXREG6 = MCU_U1TXREG.6 
.................... #bit    MCU_UTXREG7 = MCU_U1TXREG.7 
.................... #bit    MCU_UTXREG8 = MCU_U1TXREG.8 
.................... #word MCU_U1RXREG = 0x226 
.................... //#word MCU_U1RXREG = 0x226 
.................... #bit    MCU_URXREG0 = MCU_U1RXREG.0 
.................... #bit    MCU_URXREG1 = MCU_U1RXREG.1 
.................... #bit    MCU_URXREG2 = MCU_U1RXREG.2 
.................... #bit    MCU_URXREG3 = MCU_U1RXREG.3 
.................... #bit    MCU_URXREG4 = MCU_U1RXREG.4 
.................... #bit    MCU_URXREG5 = MCU_U1RXREG.5 
.................... #bit    MCU_URXREG6 = MCU_U1RXREG.6 
.................... #bit    MCU_URXREG7 = MCU_U1RXREG.7 
.................... #bit    MCU_URXREG8 = MCU_U1RXREG.8 
.................... #word MCU_U1BRG = 0x228 
....................  
....................  
....................  
.................... #ZERO_RAM 
.................... #DEVICE ADC=12 
....................  
.................... #FUSES NOWDT     	  	   		 //No Watch Dog Timer  
.................... #FUSES HS 
.................... #FUSES PR_PLL                 //High speed Osc (> 4mhz)  
.................... #FUSES PUT64                     //Power Up Timer  
.................... #FUSES NOPROTECT                 //Code not protected from reads  
.................... #FUSES NODEBUG                   //No Debug mode for ICD  
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... //*- CRC -*// 
.................... #rom getenv("PROGRAM_MEMORY")-2 = CHECKSUM 
....................  
.................... #define FREQUENCY 80000000  //!!!!PR_PLL 
.................... #use delay(clock=FREQUENCY, oscilator=FREQUENCY) 
....................  
.................... #use rs232(UART1, baud=115200, BITS =8,PARITY=N, STOP=1, ENABLE=PIN_F6, ERRORS, STREAM = RS1) 
*
028A:  BTSS.B  222.0
028C:  BRA     28A
028E:  PUSH    222
0290:  POP     800
0292:  MOV     226,W0
0294:  BCLR.B  222.1
0296:  RETURN  
....................  
.................... #use standard_io(All) 
....................  
....................  
.................... int8 adress = 0;  
....................  
....................  
.................... //ID 
.................... #define ID1 0x17 
.................... #define ID2 0x03 
.................... #define ID3 0x20 
.................... #define ID4 0x16 
....................  
.................... //adress 
.................... #define ADRES1    0x85 
.................... #define ADRES2    0x85 
....................  
.................... //commands  
.................... #define COM_SET_ALL_UI       0x40 //устанавливает значения всех стрелок, бленкеров, индексов 
.................... #define COM_SET_UGOL_STR	 0x31 //только стрелка угла атаки 	 
.................... #define COM_SET_UGOL_IND     0x3A //индекс угла атаки 		 
.................... #define COM_SET_PRG_STR      0x32 //стрелка перегрузки   
.................... #define COM_SET_PRG_IND      0x41 //индекс перегрузки  
.................... #define COM_SET_UP_BLN       0x42 //бленкер угла атаки & блекнкер перегрузки 
....................  
.................... #define COM_READ_CRC	     0x47 //чтение контрольной суммы 
.................... #define COM_INFO			 0x48 //поддерживаемы команды  
.................... #define COM_READ_ID		     0x46 //идентивикатор 
.................... #define COM_RESET_MK		 0x55 //программный перезапуск МК	 
.................... #define RESET_MK_WORD_2      0xAA //2 е -слово используемое в команде перезапуска МК 
....................  
....................  
.................... //add modul  
....................  
.................... #include "Led.c"      // timer5 
.................... // used timer5  
....................  
.................... #define LED_GREEN_ON {output_high(PIN_G7);}// output_low(PIN_G0);} 
.................... #define LED_GREEN_OFF {output_low(PIN_G7);}// output_high(PIN_G0);} 
.................... #define LED_RED_ON {output_high(PIN_G8);} //output_low(PIN_G1);} 
.................... #define LED_RED_OFF {output_low(PIN_G8);}// output_high(PIN_G1);} 
....................  
.................... // color vd 
.................... #define LED_RED   0x5555 
.................... #define LED_GREEN 0xAAAA 
....................  
.................... int1 runRedVd = 0;  
.................... int1 runGreenVd = 0;  
.................... int1 periodRed = 0; 
.................... int1 periodGreen = 0; 
....................  
.................... void runVD(int color);  
.................... void initLed();  
....................  
.................... static const int16 time = 15625; //10Hz//23528; // Fcy = Fosc/2; t=Fcy*256 (t.k. (TMR_INTERNAL|TMR_DIV_BY_256) 
.................... //************************************************************ 
.................... //* 
.................... //************************************************************ 
.................... void initLed() 
.................... { 
.................... 	setup_timer5(TMR_INTERNAL|TMR_DIV_BY_256, time ); 
*
0844:  CLR     120
0846:  MOV     #3D09,W4
0848:  MOV     W4,11C
084A:  MOV     #8030,W4
084C:  MOV     W4,120
.................... 	set_timer5(0); 
084E:  CLR     118
.................... 	enable_interrupts(INT_TIMER5); 
0850:  BSET.B  97.4
.................... 	runVD(LED_GREEN);  
0852:  MOV     #AAAA,W4
0854:  MOV     W4,93E
0856:  CALL    822
.................... 	runVD(LED_RED);  
085A:  MOV     #5555,W4
085C:  MOV     W4,93E
085E:  CALL    822
0862:  RETURN  
.................... } 
.................... //************************************************************ 
.................... // управление светодиодом 
.................... //************************************************************ 
.................... void runVD(int color) 
.................... { 
....................  
.................... 	switch(color) 
*
0822:  MOV     93E,W0
0824:  MOV     #5555,W4
0826:  CP      W0,W4
0828:  BRA     Z,832
082A:  MOV     #AAAA,W4
082C:  CP      W0,W4
082E:  BRA     Z,83A
0830:  BRA     842
.................... 	{ 
.................... 		case LED_RED:  
.................... 		{ 
.................... 			if(!periodRed)  
0832:  BTSC.B  803.2
0834:  BRA     838
.................... 			{ 
.................... 				runRedVd = 1; 				 
0836:  BSET.B  803.0
.................... 			} 		 
.................... 			break;  
0838:  BRA     842
.................... 		} 
.................... 		case LED_GREEN:  
.................... 		{ 
.................... 			if(!periodGreen) 
083A:  BTSC.B  803.3
083C:  BRA     840
.................... 			{ 
.................... 				runGreenVd = 1;  
083E:  BSET.B  803.1
.................... 			}  
.................... 			break;  
0840:  BRA     842
.................... 		} 
.................... 		default: 
.................... 		{ 
....................  
.................... 		} 
.................... 	} 
0842:  RETURN  
.................... } 
....................  
....................  
....................  
.................... //*************************************************************** 
.................... //* 
.................... //*************************************************************** 
.................... #int_timer5 
.................... void timer5_isr(void) 
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
.................... 	if(runRedVd) 
020E:  BTSS.B  803.0
0210:  BRA     21C
.................... 	{ 
.................... 		LED_RED_ON; 
0212:  BCLR.B  2E5.0
0214:  BSET.B  2E9.0
.................... 		runRedVd = 0; 
0216:  BCLR.B  803.0
.................... 		periodRed = 1;  
0218:  BSET.B  803.2
.................... 	} 
021A:  BRA     222
.................... 	else  
.................... 	{	 
.................... 	 	LED_RED_OFF; 
021C:  BCLR.B  2E5.0
021E:  BCLR.B  2E9.0
.................... 		periodRed = 0;  
0220:  BCLR.B  803.2
.................... 	 
.................... 	} 
.................... 	 
.................... 	if(runGreenVd) 
0222:  BTSS.B  803.1
0224:  BRA     230
.................... 	{ 
.................... 			LED_GREEN_OFF; 
0226:  BCLR.B  2E4.7
0228:  BCLR.B  2E8.7
.................... 			runGreenVd = 0;  
022A:  BCLR.B  803.1
.................... 			periodGreen = 1;   
022C:  BSET.B  803.3
.................... 	} 
022E:  BRA     236
.................... 	else 
.................... 	{ 
.................... 		LED_GREEN_ON;  
0230:  BCLR.B  2E4.7
0232:  BSET.B  2E8.7
.................... 		periodGreen = 0;  
0234:  BCLR.B  803.3
....................  
.................... 	} 
.................... 	clear_interrupt(INT_TIMER5); 
0236:  BCLR.B  87.4
.................... //	disable_interrupts(INT_TIMER5); 
.................... 	set_timer5(0); 
0238:  CLR     118
....................   
.................... } 
....................  
....................  
.................... #include "PLL.c" 
.................... #include "PLL.h" 
.................... #ifndef PLL_H 
.................... #define PLL_H 
....................  
....................  
....................  
.................... // OSCILLATOR CONFIGURATION  
023A:  BCLR.B  87.4
023C:  MOV     #1A,W0
023E:  REPEAT  #C
0240:  MOV     [--W15],[W0--]
0242:  MOV     [--W15],W0
0244:  POP     32
0246:  POP     36
0248:  POP     42
024A:  RETFIE  
.................... #WORD CLKDIV = 0x0744         //PLLPOST(6,7) - PLLPRE(0,1,2,3,4)  
....................  
.................... #BIT PLLPOST_0 = CLKDIV.6  
.................... #BIT PLLPOST_1 = CLKDIV.7  
....................  
.................... #BIT PLLPRE_0 = CLKDIV.0  
.................... #BIT PLLPRE_1 = CLKDIV.1  
.................... #BIT PLLPRE_2 = CLKDIV.2  
.................... #BIT PLLPRE_3 = CLKDIV.3  
.................... #BIT PLLPRE_4 = CLKDIV.4  
....................  
.................... #WORD PLLFBD = 0x0746         //PLLDIV(0,1,2,3,4,5,6,7,8)  
....................  
.................... #BIT PLLDIV_0 = PLLFBD.0  
.................... #BIT PLLDIV_1 = PLLFBD.1  
.................... #BIT PLLDIV_2 = PLLFBD.2  
.................... #BIT PLLDIV_3 = PLLFBD.3  
.................... #BIT PLLDIV_4 = PLLFBD.4  
.................... #BIT PLLDIV_5 = PLLFBD.5  
.................... #BIT PLLDIV_6 = PLLFBD.6  
.................... #BIT PLLDIV_7 = PLLFBD.7  
.................... #BIT PLLDIV_8 = PLLFBD.8 
....................  
....................  
.................... void init_PLL();  
....................  
.................... #endif 
....................  
.................... void init_PLL() 
.................... { 
.................... 	//********* ”становка рабочей частоты 80 ћvц при кварце 16 ћvц ********* 
.................... // OSCILLATOR CONFIGURATION 
.................... // PLLPRE=4  Luego N1=2  
....................    PLLPRE_0 = 0;  
*
077A:  BCLR.B  744.0
....................    PLLPRE_1 = 1;  
077C:  BSET.B  744.1
....................    PLLPRE_2 = 0;  
077E:  BCLR.B  744.2
....................    PLLPRE_3 = 0;  
0780:  BCLR.B  744.3
....................    PLLPRE_4 = 0;  
0782:  BCLR.B  744.4
....................  
....................    // PLLPOST=0  Luego N2=0 
....................    PLLPOST_0 = 0;  
0784:  BCLR.B  744.6
....................    PLLPOST_1 = 0;  
0786:  BCLR.B  744.7
....................  
....................    // PLLDIV=30  Luego M=26  
....................    PLLDIV_0 = 0;  
0788:  BCLR.B  746.0
....................    PLLDIV_1 = 1;  
078A:  BSET.B  746.1
....................    PLLDIV_2 = 1;  
078C:  BSET.B  746.2
....................    PLLDIV_3 = 0;  
078E:  BCLR.B  746.3
....................    PLLDIV_4 = 0;  
0790:  BCLR.B  746.4
....................    PLLDIV_5 = 1;  
0792:  BSET.B  746.5
....................    PLLDIV_6 = 0;  
0794:  BCLR.B  746.6
....................    PLLDIV_7 = 0;  
0796:  BCLR.B  746.7
....................    PLLDIV_8 = 0;  
0798:  BCLR.B  747.0
079A:  RETURN  
.................... //********************************************************************** 
.................... } 
....................  
.................... #include "AZP.c"      // dma1, adc 
.................... #include "AZP.h" 
.................... #ifndef AZP_H 
.................... #define AZP_H 
....................  
.................... #include "ADC.h" 
.................... #ifndef ADC_H 
.................... #define ADC_H 
....................  
.................... #word MCU_ADC1BUF0 = 0x300 
.................... #word MCU_AD1CON1 = 0x320 
.................... #bit    MCU_DONE = MCU_AD1CON1.0 
.................... #bit    MCU_SAMP = MCU_AD1CON1.1 
.................... #bit    MCU_ASAM = MCU_AD1CON1.2 
.................... #bit    MCU_SIMSAM = MCU_AD1CON1.3 
.................... #bit    MCU_SSRC0 = MCU_AD1CON1.5 
.................... #bit    MCU_SSRC1 = MCU_AD1CON1.6 
.................... #bit    MCU_SSRC2 = MCU_AD1CON1.7 
.................... #bit    MCU_FORM0 = MCU_AD1CON1.8 
.................... #bit    MCU_FORM1 = MCU_AD1CON1.9 
.................... #bit    MCU_AD12B = MCU_AD1CON1.10 
.................... #bit    MCU_ADDMABM = MCU_AD1CON1.12 
.................... #bit    MCU_ADSIDL = MCU_AD1CON1.13 
.................... #bit    MCU_ADON = MCU_AD1CON1.15 
.................... #word MCU_AD1CON2 = 0x322 
.................... #bit    MCU_ALTS = MCU_AD1CON2.0 
.................... #bit    MCU_BUFM = MCU_AD1CON2.1 
.................... #bit    MCU_SMPI0 = MCU_AD1CON2.2 
.................... #bit    MCU_SMPI1 = MCU_AD1CON2.3 
.................... #bit    MCU_SMPI2 = MCU_AD1CON2.4 
.................... #bit    MCU_SMPI3 = MCU_AD1CON2.5 
.................... #bit    MCU_BUFS = MCU_AD1CON2.7 
.................... #bit    MCU_CHPS0 = MCU_AD1CON2.8 
.................... #bit    MCU_CHPS1 = MCU_AD1CON2.9 
.................... #bit    MCU_CSCNA = MCU_AD1CON2.10 
.................... #bit    MCU_VCFG0 = MCU_AD1CON2.13 
.................... #bit    MCU_VCFG1 = MCU_AD1CON2.14 
.................... #bit    MCU_VCFG2 = MCU_AD1CON2.15 
.................... #word MCU_AD1CON3 = 0x324 
.................... #bit    MCU_ADCS0 = MCU_AD1CON3.0 
.................... #bit    MCU_ADCS1 = MCU_AD1CON3.1 
.................... #bit    MCU_ADCS2 = MCU_AD1CON3.2 
.................... #bit    MCU_ADCS3 = MCU_AD1CON3.3 
.................... #bit    MCU_ADCS4 = MCU_AD1CON3.4 
.................... #bit    MCU_ADCS5 = MCU_AD1CON3.5 
.................... #bit    MCU_ADCS6 = MCU_AD1CON3.6 
.................... #bit    MCU_ADCS7 = MCU_AD1CON3.7 
.................... #bit    MCU_SAMC0 = MCU_AD1CON3.8 
.................... #bit    MCU_SAMC1 = MCU_AD1CON3.9 
.................... #bit    MCU_SAMC2 = MCU_AD1CON3.10 
.................... #bit    MCU_SAMC3 = MCU_AD1CON3.11 
.................... #bit    MCU_SAMC4 = MCU_AD1CON3.12 
.................... #bit    MCU_ADRC = MCU_AD1CON3.15 
.................... #word MCU_AD1CHS123 = 0x326 
.................... #bit    MCU_CH123SA = MCU_AD1CHS123.0 
.................... #bit    MCU_CH123NA0 = MCU_AD1CHS123.1 
.................... #bit    MCU_CH123NA1 = MCU_AD1CHS123.2 
.................... #bit    MCU_CH123SB = MCU_AD1CHS123.8 
.................... #bit    MCU_CH123NB0 = MCU_AD1CHS123.9 
.................... #bit    MCU_CH123NB1 = MCU_AD1CHS123.10 
.................... #word MCU_AD1CHS0 = 0x328 
.................... #bit    MCU_CH0SA0 = MCU_AD1CHS0.0 
.................... #bit    MCU_CH0SA1 = MCU_AD1CHS0.1 
.................... #bit    MCU_CH0SA2 = MCU_AD1CHS0.2 
.................... #bit    MCU_CH0SA3 = MCU_AD1CHS0.3 
.................... #bit    MCU_CH0SA4 = MCU_AD1CHS0.4 
.................... #bit    MCU_CH0NA = MCU_AD1CHS0.7 
.................... #bit    MCU_CH0SB0 = MCU_AD1CHS0.8 
.................... #bit    MCU_CH0SB1 = MCU_AD1CHS0.9 
.................... #bit    MCU_CH0SB2 = MCU_AD1CHS0.10 
.................... #bit    MCU_CH0SB3 = MCU_AD1CHS0.11 
.................... #bit    MCU_CH0SB4 = MCU_AD1CHS0.12 
.................... #bit    MCU_CH0NB = MCU_AD1CHS0.15 
.................... //#word MCU_AD1PCFGH = 0x32A 
.................... #word MCU_AD1PCFGH = 0x32A 
.................... #bit    MCU_PCFG16 = MCU_AD1PCFGH.0 
.................... #bit    MCU_PCFG17 = MCU_AD1PCFGH.1 
.................... #word MCU_AD1PCFGL = 0x32C 
.................... #bit    MCU_PCFG0 = MCU_AD1PCFGL.0 
.................... #bit    MCU_PCFG1 = MCU_AD1PCFGL.1 
.................... #bit    MCU_PCFG2 = MCU_AD1PCFGL.2 
.................... #bit    MCU_PCFG3 = MCU_AD1PCFGL.3 
.................... #bit    MCU_PCFG4 = MCU_AD1PCFGL.4 
.................... #bit    MCU_PCFG5 = MCU_AD1PCFGL.5 
.................... #bit    MCU_PCFG6 = MCU_AD1PCFGL.6 
.................... #bit    MCU_PCFG7 = MCU_AD1PCFGL.7 
.................... #bit    MCU_PCFG8 = MCU_AD1PCFGL.8 
.................... #bit    MCU_PCFG9 = MCU_AD1PCFGL.9 
.................... #bit    MCU_PCFG10 = MCU_AD1PCFGL.10 
.................... #bit    MCU_PCFG11 = MCU_AD1PCFGL.11 
.................... #bit    MCU_PCFG12 = MCU_AD1PCFGL.12 
.................... #bit    MCU_PCFG13 = MCU_AD1PCFGL.13 
.................... #bit    MCU_PCFG14 = MCU_AD1PCFGL.14 
.................... #bit    MCU_PCFG15 = MCU_AD1PCFGL.15 
.................... //#word MCU_AD1CSSH = 0x32E 
.................... #word MCU_AD1CSSH = 0x32E 
.................... #bit    MCU_CSS16 = MCU_AD1CSSH.0 
.................... #bit    MCU_CSS17 = MCU_AD1CSSH.1 
.................... #word MCU_AD1CSSL = 0x330 
.................... #bit    MCU_CSS0 = MCU_AD1CSSL.0 
.................... #bit    MCU_CSS1 = MCU_AD1CSSL.1 
.................... #bit    MCU_CSS2 = MCU_AD1CSSL.2 
.................... #bit    MCU_CSS3 = MCU_AD1CSSL.3 
.................... #bit    MCU_CSS4 = MCU_AD1CSSL.4 
.................... #bit    MCU_CSS5 = MCU_AD1CSSL.5 
.................... #bit    MCU_CSS6 = MCU_AD1CSSL.6 
.................... #bit    MCU_CSS7 = MCU_AD1CSSL.7 
.................... #bit    MCU_CSS8 = MCU_AD1CSSL.8 
.................... #bit    MCU_CSS9 = MCU_AD1CSSL.9 
.................... #bit    MCU_CSS10 = MCU_AD1CSSL.10 
.................... #bit    MCU_CSS11 = MCU_AD1CSSL.11 
.................... #bit    MCU_CSS12 = MCU_AD1CSSL.12 
.................... #bit    MCU_CSS13 = MCU_AD1CSSL.13 
.................... #bit    MCU_CSS14 = MCU_AD1CSSL.14 
.................... #bit    MCU_CSS15 = MCU_AD1CSSL.15 
.................... #word MCU_AD1CON4 = 0x332 
.................... #word MCU_DMA0STB = 0x386 
.................... #word MCU_DMACS0 = 0x3E0 
.................... #bit    MCU_XWCOL0 = MCU_DMACS0.0 
.................... #bit    MCU_XWCOL1 = MCU_DMACS0.1 
.................... #bit    MCU_XWCOL2 = MCU_DMACS0.2 
.................... #bit    MCU_XWCOL3 = MCU_DMACS0.3 
.................... #bit    MCU_XWCOL4 = MCU_DMACS0.4 
.................... #bit    MCU_XWCOL5 = MCU_DMACS0.5 
.................... #bit    MCU_XWCOL6 = MCU_DMACS0.6 
.................... #bit    MCU_XWCOL7 = MCU_DMACS0.7 
.................... #bit    MCU_PWCOL0 = MCU_DMACS0.8 
.................... #bit    MCU_PWCOL1 = MCU_DMACS0.9 
.................... #bit    MCU_PWCOL2 = MCU_DMACS0.10 
.................... #bit    MCU_PWCOL3 = MCU_DMACS0.11 
.................... #bit    MCU_PWCOL4 = MCU_DMACS0.12 
.................... #bit    MCU_PWCOL5 = MCU_DMACS0.13 
.................... #bit    MCU_PWCOL6 = MCU_DMACS0.14 
.................... #bit    MCU_PWCOL7 = MCU_DMACS0.15 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //ADC INPUT 
.................... #define AV1 PIN_B2  //AN2 
.................... #define AV2 PIN_B3  //AN3 
.................... #define AV3 PIN_B13 //AN13 
.................... #define AV4 PIN_B14 //AN14 
....................  
.................... #define SIZE_DMA_ADC_BUF 4 
.................... #BANK_DMA  
.................... static volatile int16 dmaAdcBuf[SIZE_DMA_ADC_BUF]; 
....................  
.................... int1 dmaAdcFlag = 0;   
....................  
.................... int16 valAdc1 = 0;  
.................... int16 valAdc2 = 0;  
.................... int16 valAdc3 = 0;  
.................... int16 valAdc4 = 0;  
....................  
....................  
.................... void clearAdcDmaBuf(); 
.................... void initAdcDma();   
.................... void initADC();  
.................... void readDmaAdc(); 
....................  
.................... //int1 tempDma = 0;  
....................  
....................  
....................  
....................   
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... void clearAdcDmaBuf()  
.................... { 
.................... 	memset(dmaAdcBuf, 0x00, sizeof(dmaAdcBuf));   
*
0864:  MOV     #2000,W1
0866:  MOV     #0,W2
0868:  REPEAT  #7
086A:  CLR.B   [W1++]
086C:  RETURN  
.................... } 
....................  
.................... void initAdcDma() 
.................... { 
....................  
.................... 	clearAdcDmaBuf();  
086E:  CALL    864
.................... 	setup_dma(2, DMA_IN_ADC1, DMA_WORD); 
0872:  CLR.B   399
0874:  MOV.B   #D,W0L
0876:  MOV.B   W0L,39A
0878:  MOV     #300,W4
087A:  MOV     W4,3A0
.................... 	dma_start(2,DMA_CONTINOUS, &dmaAdcBuf[0]);  
087C:  BCLR.B  399.7
087E:  CLR.B   398
0880:  MOV     #2000,W4
0882:  MOV     W4,39C
0884:  BTSS.B  399.6
0886:  BRA     88E
0888:  MOV     #7,W4
088A:  MOV     W4,3A2
088C:  BRA     892
088E:  MOV     #3,W4
0890:  MOV     W4,3A2
0892:  BSET.B  399.7
.................... 	enable_interrupts(INT_DMA2);	 
0894:  BSET.B  97.0
0896:  RETURN  
.................... } 
....................  
.................... #INT_DMA2 
.................... void DMA2Interrupts() 
*
0266:  PUSH    42
0268:  PUSH    36
026A:  PUSH    32
026C:  MOV     W0,[W15++]
026E:  MOV     #2,W0
0270:  REPEAT  #C
0272:  MOV     [W0++],[W15++]
.................... { 
.................... 	//dmaAdcFlag = 1;  
.................... 	readDmaAdc(); 
0274:  CALL    24C
.................... 	//runVD(LED_RED);	 
0278:  BCLR.B  87.0
027A:  MOV     #1A,W0
027C:  REPEAT  #C
027E:  MOV     [--W15],[W0--]
0280:  MOV     [--W15],W0
0282:  POP     32
0284:  POP     36
0286:  POP     42
0288:  RETFIE  
.................... } 
....................  
.................... void readDmaAdc() 
.................... { 
.................... 	//if(dmaAdcFlag) 
.................... 	//{ 
.................... 		valAdc1 = (dmaAdcBuf[0]&0xFFFF); 
*
024C:  MOV     2000,W0
024E:  MOV     W0,W4
0250:  MOV     W4,804
.................... 		valAdc2 = (dmaAdcBuf[1]&0xFFFF); 
0252:  MOV     2002,W0
0254:  MOV     W0,W4
0256:  MOV     W4,806
.................... 		valAdc3 = (dmaAdcBuf[2]&0xFFFF); 
0258:  MOV     2004,W0
025A:  MOV     W0,W4
025C:  MOV     W4,808
.................... 		valAdc4 = (dmaAdcBuf[3]&0xFFFF);  
025E:  MOV     2006,W0
0260:  MOV     W0,W4
0262:  MOV     W4,80A
0264:  RETURN  
.................... 	//	dmaAdcFlag = 1; 
.................... 	/*	tempDma = !tempDma;  
.................... 		if(tempDma) 
.................... 		{	output_high(PIN_G1); } 
.................... 		else {output_low(PIN_G1); }*/ 
.................... 			  
.................... 	  
.................... 	//} 
.................... } 
....................  
.................... void initADC() 
.................... { 
.................... 	//1)set mode 12 bit 
.................... 	MCU_ADON = 0; 
*
0898:  BCLR.B  321.7
.................... 	MCU_AD12B = 1;  
089A:  BSET.B  321.2
.................... 	//2)SET VOLTAGE REFERENSE 	  
.................... 	MCU_VCFG0 = 0;  
089C:  BCLR.B  323.5
.................... 	MCU_VCFG1 = 0;  
089E:  BCLR.B  323.6
.................... 	MCU_VCFG2 = 0;  
08A0:  BCLR.B  323.7
.................... 	//3)SELECT ANALOG CONVERSION CLOCK 
.................... 	MCU_AD1CON3 = 0x0606; //0000_0100_0000_0100 
08A2:  MOV     #606,W4
08A4:  MOV     W4,324
.................... 	 					  // AutoSample 4TAD 
.................... 						  // TAD = 5*Tcy	 
.................... 						  // Tcy = 1/Fcy  
.................... 						  // Fcy = Fosc/2 
.................... 	//4)select port pins 
.................... 	MCU_PCFG16 = 0x01; 
08A6:  BSET.B  32A.0
.................... 	MCU_PCFG17 = 0x01;  
08A8:  BSET.B  32A.1
.................... 	MCU_AD1PCFGL = 0x9FF3; 
08AA:  MOV     #9FF3,W4
08AC:  MOV     W4,32C
.................... 	//5)determine inputs to channels 
.................... 	MCU_AD1CHS0 = 0x0006;  
08AE:  MOV     #6,W4
08B0:  MOV     W4,328
.................... 	//6)DETERMINE how many Sample/Hold channels 
.................... 	MCU_CHPS0 = 0;  
08B2:  BCLR.B  323.0
.................... 	MCU_CHPS1 = 0;  
08B4:  BCLR.B  323.1
.................... 	//7)Determine how sampling will occur 
.................... 	 
.................... 	MCU_SIMSAM = 0; 
08B6:  BCLR.B  320.3
.................... 	MCU_CSS16 = 0;  
08B8:  BCLR.B  32E.0
.................... 	MCU_CSS17 = 0;  
08BA:  BCLR.B  32E.1
.................... 	MCU_AD1CSSL = 0x600C;  
08BC:  MOV     #600C,W4
08BE:  MOV     W4,330
.................... 	//8)Auto sampling  
.................... 	MCU_ASAM = 1; 
08C0:  BSET.B  320.2
.................... 	//Select conversion trigger and sampling time 
.................... 	MCU_SSRC0 = 1; // internal counter ends sampling and start conversion (auto-convert) 
08C2:  BSET.B  320.5
.................... 	MCU_SSRC1 = 1; 
08C4:  BSET.B  320.6
.................... 	MCU_SSRC2 = 1;  
08C6:  BSET.B  320.7
.................... 	//Select how conversion results 
.................... 	MCU_FORM0 = 0; 
08C8:  BCLR.B  321.0
.................... 	MCU_FORM1 = 0; 
08CA:  BCLR.B  321.1
.................... 	//Select interrupt rate or DMA buffer pointer increment rate 
.................... 	MCU_SMPI0 = 1;  
08CC:  BSET.B  322.2
.................... 	MCU_SMPI1 = 1; 
08CE:  BSET.B  322.3
.................... 	MCU_SMPI2 = 0; 
08D0:  BCLR.B  322.4
.................... 	MCU_SMPI3 = 0; 
08D2:  BCLR.B  322.5
.................... 	//Select the number of samples  
.................... 	//in DMA buffer for each ADC module input 
.................... 	MCU_AD1CON4 = 0; // 1 WORD   
08D4:  CLR     332
.................... 	// Select the data format 
....................  
.................... 	//Configure DMA channel (if needed) 
.................... 	initAdcDma();	 
08D6:  CALL    86E
....................  
.................... 	//Configure ADC interrupt (if required) 
.................... 	 
.................... 	MCU_ADDMABM = 0;  
08DA:  BCLR.B  321.4
.................... 	MCU_CSCNA = 1; 
08DC:  BSET.B  323.2
.................... 	MCU_BUFM = 0; 
08DE:  BCLR.B  322.1
.................... 	//Turn on ADC module  
.................... 	 MCU_ADON = 1;  
08E0:  BSET.B  321.7
08E2:  RETURN  
.................... 	 	 
.................... } 
....................  
....................  
....................  
.................... #include "pwmUap.c"   //pwm, timer3 // 
.................... #include "pwmUap.h" 
.................... #ifndef PWMUAP_H 
.................... #define PWMUAP_H 
....................  
.................... #include "CalibrAdcPwm.h" 
.................... #ifndef CALIBRADCPWM_H 
.................... #define CALIBRADCPWM_H 
....................  
.................... #include "pwmUap.h" 
.................... #ifndef PWMUAP_H 
.................... #define PWMUAP_H 
....................  
.................... #include "CalibrAdcPwm.h" 
.................... #include "motor.h" 
....................  
.................... //PWM OUTPUT 
.................... #define CANAL1_PWM PIN_D0 
.................... #define CANAL2_PWM PIN_D1 
.................... #define CANAL3_PWM PIN_D2 
.................... #define CANAL4_PWM PIN_D3 
.................... #define CANAL5_PWM PIN_D4 
.................... #define CANAL6_PWM PIN_D5 
....................  
....................  
.................... #define PIN_BLENK1 PIN_F0 
.................... #define PIN_BLENK2 PIN_F1  
.................... #define BLENK1_ON  output_low(PIN_BLENK1);  
.................... #define BLENK1_OFF output_high(PIN_BLENK1);  
.................... #define BLENK2_ON  output_low(PIN_BLENK2);  
.................... #define BLENK2_OFF output_high(PIN_BLENK2); 
....................  
....................  
....................  
.................... Motor m3;  
.................... Motor m4;  
.................... Motor m5;  
.................... Motor m6;  
....................  
.................... int16 newValueM3 = 0;  
.................... int16 newValueM4 = 0;  
.................... int16 newValueM5 = 0;  
.................... int16 newValueM6 = 0;  
.................... int8  newValueRk = 0;  
.................... //ENAB POWER PWM 
.................... #define SD_PIN PIN_G15 // shutdown IR2014S 
.................... #define ON_PWR_PWM output_high(SD_PIN) 
.................... #define OFF_PWR_PWM output_low(SD_PIN) 
.................... //Time Pwm  
.................... #define TIME_PWM 12500 
....................  
.................... #define POL_PERIOD (TIME_PWM>>1) 
.................... #define POL_POL_PERIOD (POL_PERIOD>>1) 
....................  
....................  
.................... // начальная настройка  
.................... void initPWM(); 
.................... //поворот  
.................... void rotate();  
.................... // включение, отключение силовой части   
.................... void onOffPWMCanal(int1 b);  
.................... // вкл 
.................... void setEnableSD(); 
.................... void setDisableSD(); 
.................... // установка нового значения с АЦП до которого будет осуществлен поворот   
.................... void setPwm3456(int16 pwm3, int16 pwm4, int16 pwm5, int16 pwm6, int8 blenk); 
.................... void setPwm3(int16 data);  
.................... void setPwm4(int16 data);  
.................... void setPwm5(int16 data);  
.................... void setPwm6(int16 data);  
.................... // управление бленкерами  
.................... void setRk(int8 data); 
....................  
.................... // вулючение и отключение силов 
....................  
.................... /*void updatePwm3();  
.................... void updatePwm4();  
.................... void updatePwm5(); 
.................... void updatePwm6(); */ 
.................... void updateRk();  
....................  
.................... int8 canalPwm = 0;  
.................... int16 dataCanal3 = 0;  
.................... int1 enabRegul = 0;  
....................  
....................  
....................  
....................  
....................   
....................  
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "AZP.h" 
.................... #ifndef AZP_H 
.................... #define AZP_H 
....................  
.................... #include "ADC.h" 
....................  
.................... //ADC INPUT 
.................... #define AV1 PIN_B2  //AN2 
.................... #define AV2 PIN_B3  //AN3 
.................... #define AV3 PIN_B13 //AN13 
.................... #define AV4 PIN_B14 //AN14 
....................  
.................... #define SIZE_DMA_ADC_BUF 4 
.................... #BANK_DMA  
.................... static volatile int16 dmaAdcBuf[SIZE_DMA_ADC_BUF]; 
....................  
.................... int1 dmaAdcFlag = 0;   
....................  
.................... int16 valAdc1 = 0;  
.................... int16 valAdc2 = 0;  
.................... int16 valAdc3 = 0;  
.................... int16 valAdc4 = 0;  
....................  
....................  
.................... void clearAdcDmaBuf(); 
.................... void initAdcDma();   
.................... void initADC();  
.................... void readDmaAdc(); 
....................  
.................... //int1 tempDma = 0;  
....................  
....................  
....................  
....................   
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define TIME_TEST_ADC_PWM 31250  //200ms 
.................... #define MAX_COUNT_ZIKL_WAIT 800 
....................  
.................... #define ERROR_WAIT (1<<4) 
.................... #define ACCURACY_ADC 0xFFF0 
....................  
.................... #define SK_VAL1_UP 250 
.................... #define SK_VAL2_UP (POL_PERIOD + SK_VAL1_UP) 
.................... #define SK_VAL1_DW (TIME_PWM-SK_VAL1_UP) 
.................... #define SK_VAL2_DW (POL_PERIOD-(TIME_PWM-SK_VAL1_DW)) 
.................... //states  
.................... #define S0  0x0000 
.................... #define S1  0x0001 
.................... #define S2  0x0002 
.................... #define S3  0x0004 
.................... #define S4  0x0008 
.................... #define S5  0x0010 
.................... #define S6  0x0020 
.................... #define S7  0x0040 
.................... #define S8  0x0080 
.................... #define S9  0x0100 
.................... #define S10 0x0200 
....................  
.................... // граничные значения с АЦП при нахождении указателей 
.................... // в максимальном и минимальном положени по шкале 
.................... //min  
.................... int16 minAdc1 = 0;  
.................... int16 minAdc2 = 0;  
.................... int16 minAdc3 = 0;  
.................... int16 minAdc4 = 0;  
.................... //max 
.................... int16 maxAdc1 = 0;  
.................... int16 maxAdc2 = 0;  
.................... int16 maxAdc3 = 0;  
.................... int16 maxAdc4 = 0;  
....................  
.................... #define SIZE_TEMP_ADC 4 
.................... int16 tempValADC11[SIZE_TEMP_ADC] = {0,0,0,0};  
.................... int16 tempValADC12[SIZE_TEMP_ADC] = {0,0,0,0}; 
.................... int16 tempValADC13[SIZE_TEMP_ADC] = {0,0,0,0}; 
.................... int16 tempValADC14[SIZE_TEMP_ADC] = {0,0,0,0}; 
....................  
.................... int16 readValADC11 = 0;  
.................... int16 readValADC12 = 0; 
.................... int16 readValADC21 = 0; 
.................... int16 readValADC22 = 0; 
.................... int16 readValADC31 = 0; 
.................... int16 readValADC32 = 0; 
.................... int16 readValADC41 = 0; 
.................... int16 readValADC42 = 0; 
....................  
.................... int8 errorRotate = 0; 
....................  
.................... int16 currentStateAvt = 0;  
.................... int16 oldStateAvt = 0;  
.................... int16 newStateAvt = 0;  
.................... int1 enabSendCalibrData = 0;   
.................... int1 endCalibrMotor = 0;  
....................  
.................... void setPositionEndCalibr(); 
....................  
.................... void initAvtomat();  
.................... void startAvtomatCalibr();  
.................... void startTimer7();  
.................... void resetCountZikl();  
.................... void resetAvtomat();  
.................... void updateState();  
.................... void readData1Adc();  
.................... void readData2Adc();  
.................... void sravnData(); 
.................... void setEnableSendData();   
.................... void sendDataCalibr();  
.................... void stopTimer7(); 
.................... void setRotatePwm(int1 b);  
.................... int1 waitStop();  
.................... void sendState( );  
....................  
.................... int16 ziklReadCalibr = 0; 
.................... int16 indexDataRead = 0;     
....................  
....................  
.................... int1 getFullMasCalibr(int16 a, int16 b, int16 c, int16 d);  
....................  
....................  
.................... int1 debugRS = 0;  
.................... void setDebugRS(); 
....................  
.................... #endif 
....................  
.................... #include "motor.h" 
.................... #ifndef MOTOR_H 
.................... #define MOTOR_H 
....................  
.................... #define MIN_ERROR  2.0f // минимальная ошибка для доворота  
....................  
.................... #define MIN_DADC 0x0008  
....................  
.................... // Error 
.................... // bits 
.................... #define ERR_DADC 0x08 //(dADC<MIN_ADC) 
.................... #define ERR_VADC2_B   0x04 //vAdc1<vAdc2 
.................... #define ERR_VADC1_B   0x02 //vAdc1>vAdc2 
.................... #define ERR_VADC_RAVN 0x01 //vAdc1=vAdc2 
.................... #define MAX_INT_ERROR 50     
.................... #define MIN_INT_ERROR (-50)  
....................  
....................  
.................... typedef struct MotorAs 
.................... { 
.................... 	int canalPwm;  // пин ШИМ 
.................... 	int1 upValue; //флаг направления движения, вводит относительный верх и  низ у нескольких моторов 
.................... 	int16 minValAdc; //минимальное значение ацп на одном краю шкалы 
.................... 	int16 maxValAdc; //максимальное значение ацп на другом краю шкалы 
.................... 	int16 oldValAdc; // прошлое значение используемое для установки  
.................... 	int16 newValue; // новое значение в которое необходимо перейти стрелке 
.................... 	float dAdc; 	// разность макс и мин значения АЦП 
.................... 	float kP;  // 	(POL_POL_PERIOD/m->dAdc) где (POL_POL_PERIOD) знач ШИМ для макс  
.................... 				//скорости(1/4Шим(90градусов сдвиг между каналами ШИМ))))  
.................... 				// и m->dAdc диапазон шкалы в значениях АЦП 
.................... 	float kD;  
.................... 	float kI;  
.................... 	int8 Error;    // хранит ошибки и текущее состояние  
.................... 	int16 minSpeed; // минимальное значение ШИМ при котором стрелка двигается 
.................... 	int16 maxSpeed; // максимальное значение ШИМ при котором стрелка двигается (1/4 значения счетчика ШИМ) 
.................... 	int16 maxAccel; // максимальное ускорение 
.................... 	int16 minAccel; // минимальное ускорение  
.................... 	int16 oldSpeed; // значение скорости в прошлый перерасчет положения 
.................... 	int1 enabRotate; // разрешение вращения  
.................... 	signed int maxIEr; // максимальная ошибка интегр. сост  
.................... 	signed int minIEr; // минимальная ошибка интегр. сост 
.................... 	signed int integrError; 
.................... } Motor;  
....................  
....................   
....................   
.................... void initMotor(Motor * m, int cPwm, int16 tPwm, int16 vAdc1, int16 vAdc2);  
.................... void setLimitAdcMotor(Motor *m, int16 vAdc1, int16 vAdc2); 
.................... void setMinSpeed(Motor *m,int16 data);  
.................... void setMaxSpeed(Motor *m,int16 data);     
.................... void setRotate(Motor *m, int16 currentData, int16 newData);  
.................... int16 difSost(Motor *m, float data);  
.................... int16 intSost(Motor *m, int1 dir, float data);  
.................... int16 proSost(Motor *m, int16 data, float eData);  
.................... void setNewValueMotor (Motor *m, int16 data);  
.................... void setK(Motor *m); 
.................... void setMaxAccel(Motor *m, int16 data);   
....................  
....................  
.................... #endif 
....................  
....................  
.................... //PWM OUTPUT 
.................... #define CANAL1_PWM PIN_D0 
.................... #define CANAL2_PWM PIN_D1 
.................... #define CANAL3_PWM PIN_D2 
.................... #define CANAL4_PWM PIN_D3 
.................... #define CANAL5_PWM PIN_D4 
.................... #define CANAL6_PWM PIN_D5 
....................  
....................  
.................... #define PIN_BLENK1 PIN_F0 
.................... #define PIN_BLENK2 PIN_F1  
.................... #define BLENK1_ON  output_low(PIN_BLENK1);  
.................... #define BLENK1_OFF output_high(PIN_BLENK1);  
.................... #define BLENK2_ON  output_low(PIN_BLENK2);  
.................... #define BLENK2_OFF output_high(PIN_BLENK2); 
....................  
....................  
....................  
.................... Motor m3;  
.................... Motor m4;  
.................... Motor m5;  
.................... Motor m6;  
....................  
.................... int16 newValueM3 = 0;  
.................... int16 newValueM4 = 0;  
.................... int16 newValueM5 = 0;  
.................... int16 newValueM6 = 0;  
.................... int8  newValueRk = 0;  
.................... //ENAB POWER PWM 
.................... #define SD_PIN PIN_G15 // shutdown IR2014S 
.................... #define ON_PWR_PWM output_high(SD_PIN) 
.................... #define OFF_PWR_PWM output_low(SD_PIN) 
.................... //Time Pwm  
.................... #define TIME_PWM 12500 
....................  
.................... #define POL_PERIOD (TIME_PWM>>1) 
.................... #define POL_POL_PERIOD (POL_PERIOD>>1) 
....................  
....................  
.................... // начальная настройка  
.................... void initPWM(); 
.................... //поворот  
.................... void rotate();  
.................... // включение, отключение силовой части   
.................... void onOffPWMCanal(int1 b);  
.................... // вкл 
.................... void setEnableSD(); 
.................... void setDisableSD(); 
.................... // установка нового значения с АЦП до которого будет осуществлен поворот   
.................... void setPwm3456(int16 pwm3, int16 pwm4, int16 pwm5, int16 pwm6, int8 blenk); 
.................... void setPwm3(int16 data);  
.................... void setPwm4(int16 data);  
.................... void setPwm5(int16 data);  
.................... void setPwm6(int16 data);  
.................... // управление бленкерами  
.................... void setRk(int8 data); 
....................  
.................... // вулючение и отключение силов 
....................  
.................... /*void updatePwm3();  
.................... void updatePwm4();  
.................... void updatePwm5(); 
.................... void updatePwm6(); */ 
.................... void updateRk();  
....................  
.................... int8 canalPwm = 0;  
.................... int16 dataCanal3 = 0;  
.................... int1 enabRegul = 0;  
....................  
....................  
....................  
....................  
....................   
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... void initPWM() 
.................... { 
.................... 	onOffPWMCanal(0);  
*
09D2:  CLR.B   942
09D4:  CALL    8E4
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_8, TIME_PWM); 
09D8:  CLR     112
09DA:  MOV     #30D4,W4
09DC:  MOV     W4,10E
09DE:  MOV     #8010,W4
09E0:  MOV     W4,112
.................... 	setup_compare( 1,COMPARE_CONT_PULSE | COMPARE_TIMER3); 
09E2:  MOV     #D,W4
09E4:  MOV     W4,184
.................... 	setup_compare( 2,COMPARE_CONT_PULSE | COMPARE_TIMER3); 
09E6:  MOV     #D,W4
09E8:  MOV     W4,18A
.................... 	setup_compare( 3,COMPARE_CONT_PULSE | COMPARE_TIMER3 ); 
09EA:  MOV     #D,W4
09EC:  MOV     W4,190
.................... 	setup_compare( 4,COMPARE_CONT_PULSE | COMPARE_TIMER3 ); 
09EE:  MOV     #D,W4
09F0:  MOV     W4,196
.................... 	setup_compare( 5,COMPARE_CONT_PULSE | COMPARE_TIMER3 ); 
09F2:  MOV     #D,W4
09F4:  MOV     W4,19C
.................... 	setup_compare( 6,COMPARE_CONT_PULSE | COMPARE_TIMER3 ); 
09F6:  MOV     #D,W4
09F8:  MOV     W4,1A2
.................... 	set_compare_time(1, 0, POL_PERIOD); 
09FA:  CLR     182
09FC:  MOV     #186A,W4
09FE:  MOV     W4,180
.................... 	set_compare_time(2, POL_PERIOD, 0); 
0A00:  MOV     #186A,W4
0A02:  MOV     W4,188
0A04:  CLR     186
.................... 	set_compare_time(3, 0,POL_PERIOD); //3125, 9375); 
0A06:  CLR     18E
0A08:  MOV     #186A,W4
0A0A:  MOV     W4,18C
.................... 	set_compare_time(4, 0,POL_PERIOD);//3125, 9375); 
0A0C:  CLR     194
0A0E:  MOV     #186A,W4
0A10:  MOV     W4,192
.................... 	set_compare_time(5, 0,POL_PERIOD); //9375, 3125); 
0A12:  CLR     19A
0A14:  MOV     #186A,W4
0A16:  MOV     W4,198
.................... 	set_compare_time(6, 0,POL_PERIOD);//3125, 9375); 
0A18:  CLR     1A0
0A1A:  MOV     #186A,W4
0A1C:  MOV     W4,19E
.................... 	enabRegul = 0;  
0A1E:  BCLR.B  921.0
....................  
.................... 	initMotor(&m3, 3, TIME_PWM, 0, 0);  
0A20:  MOV     #858,W4
0A22:  MOV     W4,934
0A24:  MOV     #3,W4
0A26:  MOV     W4,936
0A28:  MOV     #30D4,W4
0A2A:  MOV     W4,938
0A2C:  CLR     93A
0A2E:  CLR     93C
0A30:  CALL    8F4
.................... 	initMotor(&m4, 4, TIME_PWM, 0, 0);  
0A34:  MOV     #888,W4
0A36:  MOV     W4,934
0A38:  MOV     #4,W4
0A3A:  MOV     W4,936
0A3C:  MOV     #30D4,W4
0A3E:  MOV     W4,938
0A40:  CLR     93A
0A42:  CLR     93C
0A44:  CALL    8F4
.................... 	initMotor(&m5, 5, TIME_PWM, 0, 0);  
0A48:  MOV     #8B8,W4
0A4A:  MOV     W4,934
0A4C:  MOV     #5,W4
0A4E:  MOV     W4,936
0A50:  MOV     #30D4,W4
0A52:  MOV     W4,938
0A54:  CLR     93A
0A56:  CLR     93C
0A58:  CALL    8F4
.................... 	initMotor(&m6, 6, TIME_PWM, 0, 0); 	 
0A5C:  MOV     #8E8,W4
0A5E:  MOV     W4,934
0A60:  MOV     #6,W4
0A62:  MOV     W4,936
0A64:  MOV     #30D4,W4
0A66:  MOV     W4,938
0A68:  CLR     93A
0A6A:  CLR     93C
0A6C:  CALL    8F4
0A70:  RETURN  
.................... } 
....................  
....................  
....................  
.................... void rotate() 
.................... { 
.................... 	if(endCalibrMotor) 
*
1A8A:  BTSS.B  803.6
1A8C:  BRA     1AF8
.................... 	{ 
.................... 		//output_low(PIN_G0); 
.................... 		for(int i = 3; i<7; i++) 
1A8E:  MOV     #3,W4
1A90:  MOV     W4,934
1A92:  MOV     934,W4
1A94:  CP      W4,#7
1A96:  BRA     GE,1AF8
.................... 		{ 
.................... 			switch(i) 
1A98:  MOV     934,W0
1A9A:  XOR     #3,W0
1A9C:  BRA     Z,1AAC
1A9E:  XOR     #7,W0
1AA0:  BRA     Z,1ABE
1AA2:  XOR     #1,W0
1AA4:  BRA     Z,1AD0
1AA6:  XOR     #3,W0
1AA8:  BRA     Z,1AE2
1AAA:  BRA     1AF4
.................... 			{ 
.................... 				case 3: {setRotate(&m3, valAdc1, newValueM3); break;} 
1AAC:  MOV     #858,W4
1AAE:  MOV     W4,936
1AB0:  PUSH    804
1AB2:  POP     938
1AB4:  PUSH    918
1AB6:  POP     93A
1AB8:  CALL    173A
1ABC:  BRA     1AF4
.................... 				case 4: {setRotate(&m4, valAdc2, newValueM4); break;} 
1ABE:  MOV     #888,W4
1AC0:  MOV     W4,936
1AC2:  PUSH    806
1AC4:  POP     938
1AC6:  PUSH    91A
1AC8:  POP     93A
1ACA:  CALL    173A
1ACE:  BRA     1AF4
.................... 				case 5: {setRotate(&m5, valAdc3, newValueM5); break;} 
1AD0:  MOV     #8B8,W4
1AD2:  MOV     W4,936
1AD4:  PUSH    808
1AD6:  POP     938
1AD8:  PUSH    91C
1ADA:  POP     93A
1ADC:  CALL    173A
1AE0:  BRA     1AF4
.................... 				case 6: {setRotate(&m6, valAdc4, newValueM6); break;} 
1AE2:  MOV     #8E8,W4
1AE4:  MOV     W4,936
1AE6:  PUSH    80A
1AE8:  POP     938
1AEA:  PUSH    91E
1AEC:  POP     93A
1AEE:  CALL    173A
1AF2:  BRA     1AF4
.................... 				default: {} 
.................... 			} 
1AF4:  INC     0934
1AF6:  BRA     1A92
.................... 		} 
.................... 		//output_high(PIN_G0);	 
.................... 	} 
1AF8:  RETURN  
.................... } 
....................  
....................  
.................... void onOffPWMCanal(int1 b) 
.................... { 
.................... 	if(b==0) 
*
08E4:  CP0.B   942
08E6:  BRA     NZ,8EE
.................... 	{ 
.................... 		OFF_PWR_PWM; 
08E8:  BCLR.B  2E5.7
08EA:  BCLR.B  2E9.7
.................... 	} 
08EC:  BRA     8F2
.................... 	else 
.................... 	{ 
.................... 		ON_PWR_PWM; 
08EE:  BCLR.B  2E5.7
08F0:  BSET.B  2E9.7
.................... 	}  
08F2:  RETURN  
.................... 	 
.................... } 
....................  
.................... /*void setEnableSD() 
.................... { 
.................... 	output_high(SD_PIN);  
.................... } 
....................  
.................... void setDisableSD() 
.................... { 
.................... 	output_low(SD_PIN); 
.................... }*/ 
....................  
....................   
.................... void setPwm3456(int16 pwm3, int16 pwm4, int16 pwm5, int16 pwm6, int8 rk) 
.................... { 
.................... 	 setPwm3(pwm3);   
.................... 	 setPwm4(pwm4);  
....................      setPwm5(pwm5);  
....................      setPwm6(pwm6);  
....................      setRk(rk);  
.................... } 
....................  
.................... void setPwm3(int16 data) 
.................... { 
.................... 	newValueM3 = data;  
.................... }  
.................... void setPwm4(int16 data)  
.................... { 
.................... 	newValueM4 = data;  
.................... }  
.................... void setPwm5(int16 data) 
.................... { 
.................... 	newValueM5 = data;  
.................... }  
.................... void setPwm6(int16 data) 
.................... { 
.................... 	newValueM6 = data;   
.................... }  
.................... void setRk(int8 data) 
.................... { 
.................... 	newValueRk = data;  
.................... } 
....................  
....................  
.................... void updateRk() 
.................... { 
.................... 	if((newValueRk&0x01)) 
.................... 	{ 
.................... 		BLENK2_ON;  
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		BLENK2_OFF;  
.................... 	} 
.................... 	 
.................... 	if((newValueRk&0x10)) 
.................... 	{ 
.................... 		BLENK1_ON;  
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		BLENK1_OFF;  
.................... 	} 
.................... 	 
.................... } 
....................  
....................  
.................... #include "RS485.c"    //timer4, uart1 
.................... #include "RS485.h"  
.................... #ifndef RS485_H 
.................... #define RS485_H 
....................  
....................  
....................  
.................... #define ENABLE PIN_F6 
....................  
.................... int indW = 0;  
....................  
.................... #define SIZE_RS_BUFFER 10 
.................... #define RELOAD_INDW  9// SIZE_RS_BUFFER - 2   
....................  
.................... int8  buffer[SIZE_RS_BUFFER] = {0,0,0,0,0,0,0,0,0,0.}; 
....................  
.................... int1 FLAG = 0;  
.................... int16 pause = 47;/*115200/80MHZ*/ //35;/*115200/60MHz*/  
....................  
....................  
.................... void pause3_5RS();  
.................... void sendRS( int8 msg);  
.................... void sendRS16( int8 msg); 
.................... void initRS();  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... //***************************************************************** 
.................... //* инициализация  
.................... //***************************************************************** 
.................... void initRS() 
.................... { 
.................... 	enable_interrupts(INT_RDA); 
*
079C:  BSET.B  95.3
079E:  RETURN  
.................... } 
....................  
.................... #INT_RDA 
.................... void interruptRS() 
*
02AC:  PUSH    42
02AE:  PUSH    36
02B0:  PUSH    32
02B2:  MOV     W0,[W15++]
02B4:  MOV     #2,W0
02B6:  REPEAT  #C
02B8:  MOV     [W0++],[W15++]
.................... { 
.................... 	buffer[indW] = getc(); 
02BA:  MOV     #926,W4
02BC:  MOV     924,W3
02BE:  ADD     W3,W4,W5
02C0:  CALL    28A
02C4:  MOV.B   W0L,[W5]
.................... 	 
.................... 	indW++; 
02C6:  INC     0924
.................... 	 
.................... 	if(indW>RELOAD_INDW) 
02C8:  MOV     924,W4
02CA:  CP      W4,#9
02CC:  BRA     LE,2D0
.................... 	{ 
.................... 		indW = 0;  
02CE:  CLR     924
.................... 	} 
.................... 	clear_interrupt(INT_RDA); 
02D0:  REPEAT  #3
02D2:  MOV     226,W0
02D4:  BCLR.B  85.3
.................... 	 
.................... 	pause3_5RS(); 
02D6:  CALL    298
.................... 	 
.................... 	 
02DA:  BCLR.B  85.3
02DC:  MOV     #1A,W0
02DE:  REPEAT  #C
02E0:  MOV     [--W15],[W0--]
02E2:  MOV     [--W15],W0
02E4:  POP     32
02E6:  POP     36
02E8:  POP     42
02EA:  RETFIE  
.................... } 
....................  
.................... //***************************************************************** 
.................... //* пауза в 3,5 символа  
.................... //***************************************************************** 
....................  
.................... void pause3_5RS() 
.................... { 
.................... 	setup_timer4(TMR_DISABLED); 
*
0298:  CLR     11E
....................     clear_interrupt(INT_TIMER4); 
029A:  BCLR.B  87.3
.................... 	set_timer4(0); 	  
029C:  CLR     114
.................... 	setup_timer4(TMR_INTERNAL|TMR_DIV_BY_256, pause );/// 
029E:  CLR     11E
02A0:  PUSH    930
02A2:  POP     11A
02A4:  MOV     #8030,W4
02A6:  MOV     W4,11E
.................... 	enable_interrupts(int_timer4); 
02A8:  BSET.B  97.3
02AA:  RETURN  
.................... //	output_high(PIN_G13); 
.................... 	//3.8mS 
....................  
.................... } 
.................... //**************************************************************** 
.................... // таймер расчета паузы в 3.5 символа  
.................... //**************************************************************** 
....................  
.................... #int_timer4 //  
.................... void __timer4_isr__(void) 
*
02EC:  PUSH    42
02EE:  PUSH    36
02F0:  PUSH    32
02F2:  MOV     W0,[W15++]
02F4:  MOV     #2,W0
02F6:  REPEAT  #C
02F8:  MOV     [W0++],[W15++]
.................... { 
.................... 	 //1.6ms 
.................... //	output_low(PIN_G13); 
.................... 	setup_timer4(TMR_DISABLED); 
02FA:  CLR     11E
.................... 	clear_interrupt(INT_TIMER4); 
02FC:  BCLR.B  87.3
.................... 	FLAG = TRUE;  
02FE:  BSET.B  921.1
....................     set_timer4(0);  
0300:  CLR     114
.................... 	//1.6ms 
.................... 	 
0302:  BCLR.B  87.3
0304:  MOV     #1A,W0
0306:  REPEAT  #C
0308:  MOV     [--W15],[W0--]
030A:  MOV     [--W15],W0
030C:  POP     32
030E:  POP     36
0310:  POP     42
0312:  RETFIE  
.................... } 
....................  
.................... //**************************************************************** 
.................... // вывод  RS 
.................... //*************************************************************** 
....................  
.................... void sendRS( int8 msg) 
.................... { 
....................  
.................... 	output_high(ENABLE); 
*
0AA6:  BCLR.B  2DE.6
0AA8:  BSET.B  2E2.6
.................... 	while(MCU_UTXBF);  
0AAA:  BTSC.B  223.1
0AAC:  BRA     AAA
.................... 	MCU_U1TXREG = msg;   
0AAE:  MOV.B   93E,W0L
0AB0:  SE      W0,W0
0AB2:  MOV     W0,224
.................... 	#asm nop #endasm 
0AB4:  NOP     
.................... 	while(!MCU_TRMT);  
0AB6:  BTSS.B  223.0
0AB8:  BRA     AB6
.................... 	output_low(ENABLE);  
0ABA:  BCLR.B  2DE.6
0ABC:  BCLR.B  2E2.6
0ABE:  RETURN  
.................... } 
....................  
....................  
.................... void sendRS16( int16 msg) 
*
0D3E:  MOV     W5,[W15++]
.................... { 
....................  
.................... 	output_high(ENABLE); 
0D40:  BCLR.B  2DE.6
0D42:  BSET.B  2E2.6
.................... 	while(MCU_UTXBF);  
0D44:  BTSC.B  223.1
0D46:  BRA     D44
.................... 	MCU_U1TXREG = ((msg>>8)&0xFF);   
0D48:  MOV.B   93F,W0L
0D4A:  MOV.B   W0L,W5L
0D4C:  CLR.B   B
0D4E:  MOV     W5,W4
0D50:  AND     #FF,W4
0D52:  MOV     W4,224
.................... 	#asm nop #endasm 
0D54:  NOP     
.................... 	while(!MCU_TRMT);  
0D56:  BTSS.B  223.0
0D58:  BRA     D56
....................  
.................... 	while(MCU_UTXBF);  
0D5A:  BTSC.B  223.1
0D5C:  BRA     D5A
.................... 	MCU_U1TXREG = (msg&0xFF);   
0D5E:  MOV     93E,W0
0D60:  AND     #FF,W0
0D62:  MOV     W0,224
.................... 	#asm nop #endasm 
0D64:  NOP     
.................... 	while(!MCU_TRMT);  
0D66:  BTSS.B  223.0
0D68:  BRA     D66
.................... 	output_low(ENABLE);  
0D6A:  BCLR.B  2DE.6
0D6C:  BCLR.B  2E2.6
0D6E:  MOV     [--W15],W5
0D70:  RETURN  
.................... } 
....................  
....................  
.................... #include "DMA_RS.c"   // DMA0 
.................... #define SIZE_DMA_BUF 15 
.................... #define PIN_RS_SEND PIN_F6 
.................... int1 dmaBusy = 0;  
.................... // ответы по RS 
.................... void ansComSetAllUi(int8 Ustr, int8 Uind, int8 Pstr, int8 Pind, int8 UPbln);  
.................... void ansComSetUgolStr(int8 Ustr);   
.................... void ansComSetUgolInd(int8 Uind);   
.................... void ansComSetPrgStr(int8 Pstr);   
.................... void ansComSetPrgInd(int8 Pind);   
.................... void ansComSetUPBln(int8 Pbln);  
....................  
.................... void ansReadCrc(int16 crc);  
.................... void ansComInfo();  
.................... void ansComId();  
.................... void ansComRst(int8 com, int8 data);  
.................... void ansErrorCom(int8 com);  
....................  
.................... #BANK_DMA 
.................... static volatile byte dmaBuffer[SIZE_DMA_BUF];  
....................  
.................... void clearDmaBuf()  
.................... { 
.................... 	memset(dmaBuffer, 0x00, sizeof(dmaBuffer));  
*
07A0:  MOV     #2008,W1
07A2:  MOV     #0,W2
07A4:  REPEAT  #E
07A6:  CLR.B   [W1++]
.................... 	dmaBusy = 0;  
07A8:  BCLR.B  921.2
.................... 	dmaBuffer[0] = adress; 
07AA:  MOV.B   802,W0L
07AC:  PUSH    2008
07AE:  MOV.B   W0L,[W15-#2]
07B0:  POP     2008
07B2:  RETURN  
.................... } 
....................  
.................... void initDma() 
.................... { 
.................... 	clearDmaBuf();  
07B4:  CALL    7A0
.................... 	enable_interrupts(INT_DMA0); 
07B8:  BSET.B  94.4
.................... 	setup_dma(0, DMA_OUT_UART1, DMA_BYTE); 
07BA:  MOV.B   #60,W0L
07BC:  MOV.B   W0L,381
07BE:  MOV.B   #C,W0L
07C0:  MOV.B   W0L,382
07C2:  MOV     #224,W4
07C4:  MOV     W4,388
.................... 	output_low(PIN_RS_SEND); 
07C6:  BCLR.B  2DE.6
07C8:  BCLR.B  2E2.6
07CA:  RETURN  
.................... } 
....................  
.................... void sendInRsDma(int len) 
.................... { 
.................... 	dmaBusy = 1;  
*
0D72:  BSET.B  921.2
.................... 	output_high(PIN_RS_SEND); 
0D74:  BCLR.B  2DE.6
0D76:  BSET.B  2E2.6
.................... 	dma_start(0, DMA_ONE_SHOT|DMA_FORCE_NOW, dmaBuffer, len );  
0D78:  BCLR.B  381.7
0D7A:  MOV.B   #1,W0L
0D7C:  MOV.B   W0L,380
0D7E:  MOV     #2008,W4
0D80:  MOV     W4,384
0D82:  PUSH    954
0D84:  POP     38A
0D86:  BSET.B  381.7
0D88:  BSET.B  383.7
0D8A:  RETURN  
.................... } 
....................  
.................... #INT_DMA0 
.................... void DMAInterrupts() 
*
0314:  PUSH    42
0316:  PUSH    36
0318:  PUSH    32
031A:  MOV     W0,[W15++]
031C:  MOV     #2,W0
031E:  REPEAT  #C
0320:  MOV     [W0++],[W15++]
.................... { 
.................... 	dmaBusy = 0;  
0322:  BCLR.B  921.2
.................... 	output_low(PIN_RS_SEND); 
0324:  BCLR.B  2DE.6
0326:  BCLR.B  2E2.6
.................... } 
....................  
....................  
0328:  BCLR.B  84.4
032A:  MOV     #1A,W0
032C:  REPEAT  #C
032E:  MOV     [--W15],[W0--]
0330:  MOV     [--W15],W0
0332:  POP     32
0334:  POP     36
0336:  POP     42
0338:  RETFIE  
.................... #INT_DMAERR 
.................... void DmaErrorInterrupt() 
033A:  PUSH    42
033C:  PUSH    36
033E:  PUSH    32
0340:  MOV     W0,[W15++]
0342:  MOV     #2,W0
0344:  REPEAT  #C
0346:  MOV     [W0++],[W15++]
.................... { 
....................     
0348:  BCLR.B  80.5
034A:  MOV     #1A,W0
034C:  REPEAT  #C
034E:  MOV     [--W15],[W0--]
0350:  MOV     [--W15],W0
0352:  POP     32
0354:  POP     36
0356:  POP     42
0358:  RETFIE  
.................... } 
....................  
....................  
.................... void ansComSetAllUi(int8 Ustr, int8 Uind, int8 Pstr, int8 Pind, int8 UPbln) 
.................... { 
.................... 	clearDmaBuf();  
*
0D8C:  CALL    7A0
.................... 	dmaBuffer[1]=COM_SET_ALL_UI;  
0D90:  MOV     2008,W0
0D92:  SWAP    W0
0D94:  MOV.B   #40,W0L
0D96:  SWAP    W0
0D98:  MOV     W0,2008
.................... 	dmaBuffer[2]=Ustr;  
0D9A:  MOV.B   94A,W0L
0D9C:  PUSH    200A
0D9E:  MOV.B   W0L,[W15-#2]
0DA0:  POP     200A
.................... 	dmaBuffer[3]=Uind; 
0DA2:  MOV.B   94B,W0L
0DA4:  PUSH    200A
0DA6:  MOV.B   W0L,[W15-#1]
0DA8:  POP     200A
.................... 	dmaBuffer[4]=Pstr; 
0DAA:  MOV.B   94C,W0L
0DAC:  PUSH    200C
0DAE:  MOV.B   W0L,[W15-#2]
0DB0:  POP     200C
.................... 	dmaBuffer[5]=Pind; 
0DB2:  MOV.B   94D,W0L
0DB4:  PUSH    200C
0DB6:  MOV.B   W0L,[W15-#1]
0DB8:  POP     200C
.................... 	dmaBuffer[6]=UPbln; 
0DBA:  MOV.B   94E,W0L
0DBC:  PUSH    200E
0DBE:  MOV.B   W0L,[W15-#2]
0DC0:  POP     200E
.................... 	sendInRsDma(8); 
0DC2:  MOV     #8,W4
0DC4:  MOV     W4,954
0DC6:  CALL    D72
0DCA:  RETURN  
.................... }  
.................... void ansComSetUgolStr(int8 Ustr) 
.................... { 
.................... 	clearDmaBuf();  
0DCC:  CALL    7A0
.................... 	dmaBuffer[1]=COM_SET_UGOL_STR;  
0DD0:  MOV     2008,W0
0DD2:  SWAP    W0
0DD4:  MOV.B   #31,W0L
0DD6:  SWAP    W0
0DD8:  MOV     W0,2008
.................... 	dmaBuffer[2]=Ustr;  
0DDA:  MOV.B   942,W0L
0DDC:  PUSH    200A
0DDE:  MOV.B   W0L,[W15-#2]
0DE0:  POP     200A
.................... 	sendInRsDma(4); 
0DE2:  MOV     #4,W4
0DE4:  MOV     W4,954
0DE6:  CALL    D72
0DEA:  RETURN  
.................... }   
.................... void ansComSetUgolInd(int8 Uind) 
.................... { 
.................... 	clearDmaBuf();  
0DEC:  CALL    7A0
.................... 	dmaBuffer[1]=COM_SET_UGOL_IND;  
0DF0:  MOV     2008,W0
0DF2:  SWAP    W0
0DF4:  MOV.B   #3A,W0L
0DF6:  SWAP    W0
0DF8:  MOV     W0,2008
.................... 	dmaBuffer[2]=Uind;  
0DFA:  MOV.B   942,W0L
0DFC:  PUSH    200A
0DFE:  MOV.B   W0L,[W15-#2]
0E00:  POP     200A
.................... 	sendInRsDma(4); 
0E02:  MOV     #4,W4
0E04:  MOV     W4,954
0E06:  CALL    D72
0E0A:  RETURN  
.................... }   
.................... void ansComSetPrgStr(int8 Pstr) 
.................... { 
.................... 	clearDmaBuf();  
0E0C:  CALL    7A0
.................... 	dmaBuffer[1]=COM_SET_PRG_STR;  
0E10:  MOV     2008,W0
0E12:  SWAP    W0
0E14:  MOV.B   #32,W0L
0E16:  SWAP    W0
0E18:  MOV     W0,2008
.................... 	dmaBuffer[2]=Pstr;  
0E1A:  MOV.B   942,W0L
0E1C:  PUSH    200A
0E1E:  MOV.B   W0L,[W15-#2]
0E20:  POP     200A
.................... 	sendInRsDma(4); 
0E22:  MOV     #4,W4
0E24:  MOV     W4,954
0E26:  CALL    D72
0E2A:  RETURN  
.................... }   
.................... void ansComSetPrgInd(int8 Pind) 
.................... { 
.................... 	clearDmaBuf();  
0E2C:  CALL    7A0
.................... 	dmaBuffer[1]=COM_SET_PRG_IND;  
0E30:  MOV     2008,W0
0E32:  SWAP    W0
0E34:  MOV.B   #41,W0L
0E36:  SWAP    W0
0E38:  MOV     W0,2008
.................... 	dmaBuffer[2]=Pind;  
0E3A:  MOV.B   942,W0L
0E3C:  PUSH    200A
0E3E:  MOV.B   W0L,[W15-#2]
0E40:  POP     200A
.................... 	sendInRsDma(4); 
0E42:  MOV     #4,W4
0E44:  MOV     W4,954
0E46:  CALL    D72
0E4A:  RETURN  
.................... }   
.................... void ansComSetUPBln(int8 Pbln) 
.................... { 
.................... 	clearDmaBuf();  
0E4C:  CALL    7A0
.................... 	dmaBuffer[1]=COM_SET_UP_BLN;  
0E50:  MOV     2008,W0
0E52:  SWAP    W0
0E54:  MOV.B   #42,W0L
0E56:  SWAP    W0
0E58:  MOV     W0,2008
.................... 	dmaBuffer[2]=Pbln;  
0E5A:  MOV.B   942,W0L
0E5C:  PUSH    200A
0E5E:  MOV.B   W0L,[W15-#2]
0E60:  POP     200A
.................... 	sendInRsDma(4); 
0E62:  MOV     #4,W4
0E64:  MOV     W4,954
0E66:  CALL    D72
0E6A:  RETURN  
.................... }  
....................  
....................  
.................... void ansReadCrc(int16 crc) 
0E6C:  MOV     W5,[W15++]
.................... { 
.................... 	clearDmaBuf();  
0E6E:  CALL    7A0
.................... 	dmaBuffer[1]=COM_READ_CRC;  
0E72:  MOV     2008,W0
0E74:  SWAP    W0
0E76:  MOV.B   #47,W0L
0E78:  SWAP    W0
0E7A:  MOV     W0,2008
.................... 	dmaBuffer[2]=((crc>>8)&0xFF);  
0E7C:  MOV.B   93F,W0L
0E7E:  MOV.B   W0L,W5L
0E80:  CLR.B   B
0E82:  MOV     W5,W0
0E84:  PUSH    200A
0E86:  MOV.B   W0L,[W15-#2]
0E88:  POP     200A
.................... 	dmaBuffer[3]= (crc&0xFF);  
0E8A:  MOV     93E,W0
0E8C:  AND     #FF,W0
0E8E:  PUSH    200A
0E90:  MOV.B   W0L,[W15-#1]
0E92:  POP     200A
.................... 	sendInRsDma(5); 
0E94:  MOV     #5,W4
0E96:  MOV     W4,954
0E98:  CALL    D72
0E9C:  MOV     [--W15],W5
0E9E:  RETURN  
.................... }  
.................... void ansComInfo() 
.................... { 
.................... 	clearDmaBuf();  
0EA0:  CALL    7A0
.................... 	dmaBuffer[1]= COM_INFO; 
0EA4:  MOV     2008,W0
0EA6:  SWAP    W0
0EA8:  MOV.B   #48,W0L
0EAA:  SWAP    W0
0EAC:  MOV     W0,2008
.................... 	dmaBuffer[2]= COM_SET_ALL_UI; 
0EAE:  MOV     200A,W0
0EB0:  MOV.B   #40,W0L
0EB2:  MOV     W0,200A
.................... 	dmaBuffer[3]= COM_SET_UGOL_STR; 
0EB4:  MOV     200A,W0
0EB6:  SWAP    W0
0EB8:  MOV.B   #31,W0L
0EBA:  SWAP    W0
0EBC:  MOV     W0,200A
.................... 	dmaBuffer[4]= COM_SET_UGOL_IND; 
0EBE:  MOV     200C,W0
0EC0:  MOV.B   #3A,W0L
0EC2:  MOV     W0,200C
.................... 	dmaBuffer[5]= COM_SET_PRG_STR; 
0EC4:  MOV     200C,W0
0EC6:  SWAP    W0
0EC8:  MOV.B   #32,W0L
0ECA:  SWAP    W0
0ECC:  MOV     W0,200C
.................... 	dmaBuffer[6]= COM_SET_PRG_IND; 
0ECE:  MOV     200E,W0
0ED0:  MOV.B   #41,W0L
0ED2:  MOV     W0,200E
.................... 	dmaBuffer[7]= COM_SET_UP_BLN; 
0ED4:  MOV     200E,W0
0ED6:  SWAP    W0
0ED8:  MOV.B   #42,W0L
0EDA:  SWAP    W0
0EDC:  MOV     W0,200E
....................  
.................... 	dmaBuffer[8]= COM_READ_CRC; 
0EDE:  MOV     2010,W0
0EE0:  MOV.B   #47,W0L
0EE2:  MOV     W0,2010
.................... 	dmaBuffer[9]= COM_READ_ID; 
0EE4:  MOV     2010,W0
0EE6:  SWAP    W0
0EE8:  MOV.B   #46,W0L
0EEA:  SWAP    W0
0EEC:  MOV     W0,2010
.................... 	dmaBuffer[10]= COM_RESET_MK; 
0EEE:  MOV     2012,W0
0EF0:  MOV.B   #55,W0L
0EF2:  MOV     W0,2012
.................... 	sendInRsDma(12); 
0EF4:  MOV     #C,W4
0EF6:  MOV     W4,954
0EF8:  CALL    D72
0EFC:  RETURN  
....................  
.................... } 
.................... void ansComId() 
.................... { 
.................... 	clearDmaBuf();  
0EFE:  CALL    7A0
.................... 	dmaBuffer[1]= COM_READ_ID; 
0F02:  MOV     2008,W0
0F04:  SWAP    W0
0F06:  MOV.B   #46,W0L
0F08:  SWAP    W0
0F0A:  MOV     W0,2008
.................... 	dmaBuffer[2]= ID1; 
0F0C:  MOV     200A,W0
0F0E:  MOV.B   #17,W0L
0F10:  MOV     W0,200A
.................... 	dmaBuffer[3]= ID2; 
0F12:  MOV     200A,W0
0F14:  SWAP    W0
0F16:  MOV.B   #3,W0L
0F18:  SWAP    W0
0F1A:  MOV     W0,200A
.................... 	dmaBuffer[4]= ID3; 
0F1C:  MOV     200C,W0
0F1E:  MOV.B   #20,W0L
0F20:  MOV     W0,200C
.................... 	dmaBuffer[5]= ID4;  
0F22:  MOV     200C,W0
0F24:  SWAP    W0
0F26:  MOV.B   #16,W0L
0F28:  SWAP    W0
0F2A:  MOV     W0,200C
.................... 	sendInRsDma(7); 
0F2C:  MOV     #7,W4
0F2E:  MOV     W4,954
0F30:  CALL    D72
0F34:  RETURN  
.................... }  
.................... void ansComRst(int8 com, int8 data) 
.................... { 
.................... 	clearDmaBuf();  
0F36:  CALL    7A0
.................... 	dmaBuffer[1]= com; 
0F3A:  MOV.B   942,W0L
0F3C:  PUSH    2008
0F3E:  MOV.B   W0L,[W15-#1]
0F40:  POP     2008
.................... 	dmaBuffer[2]= data;  
0F42:  MOV.B   943,W0L
0F44:  PUSH    200A
0F46:  MOV.B   W0L,[W15-#2]
0F48:  POP     200A
.................... 	sendInRsDma(4);	 
0F4A:  MOV     #4,W4
0F4C:  MOV     W4,954
0F4E:  CALL    D72
0F52:  RETURN  
.................... } 
.................... void ansErrorCom(int8 com) 
.................... { 
.................... 	clearDmaBuf();   
0F54:  CALL    7A0
.................... 	dmaBuffer[1]= (~com);  
0F58:  COM.B   0942,W0L
0F5A:  PUSH    2008
0F5C:  MOV.B   W0L,[W15-#1]
0F5E:  POP     2008
.................... 	sendInRsDma(3);	 
0F60:  MOV     #3,W4
0F62:  MOV     W4,954
0F64:  CALL    D72
0F68:  RETURN  
.................... } 
....................  
.................... #include "CRC.c" 
.................... //*********************************************************** 
.................... //контрольная сумма  
.................... //*********************************************************** 
.................... int16 crc = 0;  
.................... int16 getChecksum() 
*
07FA:  MOV     W5,[W15++]
07FC:  CLR     934
*
0800:  MOV     #ABFE,W4
0802:  MOV     W4,938
0804:  CLR     93A
.................... 	{ 
.................... 		int16 chSum = 0;  
.................... 		int8 temp[2] = {0, 0};  
*
07FE:  CLR     936
.................... 		int32 adr = (getenv("Program_memory")-2 );  
.................... 		//sendRS(0x33); 
.................... 		read_program_memory(adr, temp, 2); 
*
0806:  MOV     938,W0
0808:  MOV     93A,W1
080A:  MOV     #936,W2
080C:  MOV     #2,W3
080E:  CALL    7CC
.................... 		//sendRS(temp[1]); 
.................... 		//sendRS(temp[0]);  
.................... 		chSum = make16(temp[1], temp[0]); 
0812:  MOV.B   936,W0L
0814:  MOV.B   W0L,934
0816:  MOV.B   937,W0L
0818:  MOV.B   W0L,935
.................... 		return chSum;  
081A:  PUSH    934
081C:  POP     0
081E:  MOV     [--W15],W5
0820:  RETURN  
.................... 	} 
.................... //*********************************************************** 
....................  
.................... #include "calibrAdcPwm.c" // timer7 
.................... #include "calibrAdcPwm.h" 
.................... #ifndef CALIBRADCPWM_H 
.................... #define CALIBRADCPWM_H 
....................  
.................... #include "pwmUap.h" 
.................... #include "AZP.h" 
....................  
.................... #define TIME_TEST_ADC_PWM 31250  //200ms 
.................... #define MAX_COUNT_ZIKL_WAIT 800 
....................  
.................... #define ERROR_WAIT (1<<4) 
.................... #define ACCURACY_ADC 0xFFF0 
....................  
.................... #define SK_VAL1_UP 250 
.................... #define SK_VAL2_UP (POL_PERIOD + SK_VAL1_UP) 
.................... #define SK_VAL1_DW (TIME_PWM-SK_VAL1_UP) 
.................... #define SK_VAL2_DW (POL_PERIOD-(TIME_PWM-SK_VAL1_DW)) 
.................... //states  
.................... #define S0  0x0000 
.................... #define S1  0x0001 
.................... #define S2  0x0002 
.................... #define S3  0x0004 
.................... #define S4  0x0008 
.................... #define S5  0x0010 
.................... #define S6  0x0020 
.................... #define S7  0x0040 
.................... #define S8  0x0080 
.................... #define S9  0x0100 
.................... #define S10 0x0200 
....................  
.................... // граничные значения с АЦП при нахождении указателей 
.................... // в максимальном и минимальном положени по шкале 
.................... //min  
.................... int16 minAdc1 = 0;  
.................... int16 minAdc2 = 0;  
.................... int16 minAdc3 = 0;  
.................... int16 minAdc4 = 0;  
.................... //max 
.................... int16 maxAdc1 = 0;  
.................... int16 maxAdc2 = 0;  
.................... int16 maxAdc3 = 0;  
.................... int16 maxAdc4 = 0;  
....................  
.................... #define SIZE_TEMP_ADC 4 
.................... int16 tempValADC11[SIZE_TEMP_ADC] = {0,0,0,0};  
.................... int16 tempValADC12[SIZE_TEMP_ADC] = {0,0,0,0}; 
.................... int16 tempValADC13[SIZE_TEMP_ADC] = {0,0,0,0}; 
.................... int16 tempValADC14[SIZE_TEMP_ADC] = {0,0,0,0}; 
....................  
.................... int16 readValADC11 = 0;  
.................... int16 readValADC12 = 0; 
.................... int16 readValADC21 = 0; 
.................... int16 readValADC22 = 0; 
.................... int16 readValADC31 = 0; 
.................... int16 readValADC32 = 0; 
.................... int16 readValADC41 = 0; 
.................... int16 readValADC42 = 0; 
....................  
.................... int8 errorRotate = 0; 
....................  
.................... int16 currentStateAvt = 0;  
.................... int16 oldStateAvt = 0;  
.................... int16 newStateAvt = 0;  
.................... int1 enabSendCalibrData = 0;   
.................... int1 endCalibrMotor = 0;  
....................  
.................... void setPositionEndCalibr(); 
....................  
.................... void initAvtomat();  
.................... void startAvtomatCalibr();  
.................... void startTimer7();  
.................... void resetCountZikl();  
.................... void resetAvtomat();  
.................... void updateState();  
.................... void readData1Adc();  
.................... void readData2Adc();  
.................... void sravnData(); 
.................... void setEnableSendData();   
.................... void sendDataCalibr();  
.................... void stopTimer7(); 
.................... void setRotatePwm(int1 b);  
.................... int1 waitStop();  
.................... void sendState( );  
....................  
.................... int16 ziklReadCalibr = 0; 
.................... int16 indexDataRead = 0;     
....................  
....................  
.................... int1 getFullMasCalibr(int16 a, int16 b, int16 c, int16 d);  
....................  
....................  
.................... int1 debugRS = 0;  
.................... void setDebugRS(); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... void initAvtomat() 
.................... { 
.................... 	minAdc1 = 0x0000; 
*
035A:  CLR     80C
.................... 	minAdc2 = 0x0000; 
035C:  CLR     80E
.................... 	minAdc3 = 0x0000; 
035E:  CLR     810
.................... 	minAdc4 = 0x0000; 
0360:  CLR     812
.................... 	maxAdc1 = 0x0000; 
0362:  CLR     814
.................... 	maxAdc2 = 0x0000; 
0364:  CLR     816
.................... 	maxAdc3 = 0x0000; 
0366:  CLR     818
.................... 	maxAdc4 = 0x0000; 
0368:  CLR     81A
.................... 	 
.................... 	memset(tempValADC11, 0, (SIZE_TEMP_ADC<<1));  
036A:  MOV     #81C,W1
036C:  MOV     #0,W2
036E:  REPEAT  #7
0370:  CLR.B   [W1++]
.................... 	memset(tempValADC12, 0, (SIZE_TEMP_ADC<<1));  
0372:  MOV     #824,W1
0374:  MOV     #0,W2
0376:  REPEAT  #7
0378:  CLR.B   [W1++]
.................... 	memset(tempValADC13, 0, (SIZE_TEMP_ADC<<1));  
037A:  MOV     #82C,W1
037C:  MOV     #0,W2
037E:  REPEAT  #7
0380:  CLR.B   [W1++]
.................... 	memset(tempValADC14, 0, (SIZE_TEMP_ADC<<1));  
0382:  MOV     #834,W1
0384:  MOV     #0,W2
0386:  REPEAT  #7
0388:  CLR.B   [W1++]
.................... /*	for(int i= 0; i<SIZE_TEMP_ADC; i++) 
.................... 	{ 
.................... 		tempValADC11[i] = 0; 	 
.................... 		tempValADC12[i] = 0; 
.................... 		tempValADC13[i] = 0; 
.................... 		tempValADC14[i] = 0; 
.................... 	}*/ 
.................... 	 
.................... 	currentStateAvt = 0;  
038A:  CLR     84E
.................... 	oldStateAvt = 0;  
038C:  CLR     850
.................... 	newStateAvt = 0;  
038E:  CLR     852
.................... 	enabSendCalibrData = 0;  
0390:  BCLR.B  803.5
.................... 	endCalibrMotor = 0;  
0392:  BCLR.B  803.6
0394:  RETURN  
.................... //	resetCountZikl();  
.................... } 
....................  
....................  
.................... void setPositionEndCalibr() // smotri stopTimer7(), primenenie dannoi f() vyzyvaet  
.................... {				//Interrupts disabled during call to prevent re-entrancy:  (stopTimer7) 
.................... 	newValueM3  = (maxAdc1&0xFFC0); 
.................... 	newValueM4  = (maxAdc2&0xFFC0); 
.................... 	newValueM5  = (maxAdc3&0xFFC0); 
.................... 	newValueM6  = (maxAdc4&0xFFC0); 
....................  
.................... } 
....................  
.................... void resetCountZikl() 
.................... { 
.................... 	ziklReadCalibr = 0;  
0396:  CLR     854
.................... 	indexDataRead = 0; 
0398:  CLR     856
.................... 	enabSendCalibrData = 0;   
039A:  BCLR.B  803.5
039C:  RETURN  
.................... 	 
.................... } 
....................  
.................... void stopTimer7() 
.................... { 
.................... 	disable_interrupts(int_TIMER7);  
*
0644:  BCLR.B  9A.0
.................... 	set_timer7(0); 
0646:  CLR     126
.................... 	endCalibrMotor = 1;  
0648:  BSET.B  803.6
.................... 	//setPositionEndCalibr(); -  Interrupts disabled during call to prevent re-entrancy:  (stopTimer7) 
.................... 	newValueM3  = (maxAdc1&0xFFC0); 
064A:  PUSH    814
064C:  POP     918
064E:  MOV     #FFC0,W0
0650:  AND     918
.................... 	newValueM4  = (maxAdc2&0xFFC0); 
0652:  PUSH    816
0654:  POP     91A
0656:  MOV     #FFC0,W0
0658:  AND     91A
.................... 	newValueM5  = (maxAdc3&0xFFC0); 
065A:  PUSH    818
065C:  POP     91C
065E:  MOV     #FFC0,W0
0660:  AND     91C
.................... 	newValueM6  = (maxAdc4&0xFFC0); 
0662:  PUSH    81A
0664:  POP     91E
0666:  MOV     #FFC0,W0
0668:  AND     91E
066A:  RETURN  
.................... } 
....................  
.................... void startTimer7() 
.................... { 
.................... 	 
.................... 	disable_interrupts(int_TIMER7);  
*
0A72:  BCLR.B  9A.0
.................... 	setup_timer7(TMR_INTERNAL|TMR_DIV_BY_256, TIME_TEST_ADC_PWM);  
0A74:  CLR     12E
0A76:  MOV     #7A12,W4
0A78:  MOV     W4,12A
0A7A:  MOV     #8030,W4
0A7C:  MOV     W4,12E
.................... 	set_timer7(0);  
0A7E:  CLR     126
.................... 	enable_interrupts(int_TIMER7); 	 
0A80:  BSET.B  9A.0
0A82:  RETURN  
.................... } 
....................  
.................... void startAvtomatCalibr() 
.................... { 
.................... 	stopTimer7();  
0A84:  CALL    644
.................... 	initAvtomat(); 
0A88:  CALL    35A
.................... 	startTimer7();  
0A8C:  CALL    A72
.................... 	endCalibrMotor = 0;  
0A90:  BCLR.B  803.6
0A92:  RETURN  
.................... 		 
.................... } 
....................  
.................... void updateState() 
.................... { 
.................... 	oldStateAvt = currentStateAvt;  
*
0674:  PUSH    84E
0676:  POP     850
.................... 	currentStateAvt = newStateAvt; 	 
0678:  PUSH    852
067A:  POP     84E
067C:  RETURN  
.................... } 
.................... 	 
....................  
....................  
.................... void testPWM(int8 n, int1 b) 
.................... { 
.................... 		switch(n) 
*
039E:  MOV.B   97E,W0L
03A0:  SE      W0,W0
03A2:  XOR     #3,W0
03A4:  BRA     Z,3B4
03A6:  XOR     #7,W0
03A8:  BRA     Z,3CC
03AA:  XOR     #1,W0
03AC:  BRA     Z,3E4
03AE:  XOR     #3,W0
03B0:  BRA     Z,3FC
03B2:  BRA     414
.................... 		{ 
.................... 			case 3: { 
.................... 						if(b){set_compare_time(3, SK_VAL1_UP, SK_VAL2_UP);} 
03B4:  CP0.B   97F
03B6:  BRA     Z,3C2
03B8:  MOV     #FA,W4
03BA:  MOV     W4,18E
03BC:  MOV     #1964,W4
03BE:  MOV     W4,18C
03C0:  BRA     3CA
.................... 						else{set_compare_time(3, SK_VAL1_DW, SK_VAL2_DW);} 
03C2:  MOV     #2FDA,W4
03C4:  MOV     W4,18E
03C6:  MOV     #1770,W4
03C8:  MOV     W4,18C
.................... 						break; 
03CA:  BRA     414
.................... 					} 
.................... 			case 4: { 
.................... 						if(b){set_compare_time(4, SK_VAL1_UP, SK_VAL2_UP);} 
03CC:  CP0.B   97F
03CE:  BRA     Z,3DA
03D0:  MOV     #FA,W4
03D2:  MOV     W4,194
03D4:  MOV     #1964,W4
03D6:  MOV     W4,192
03D8:  BRA     3E2
.................... 						else{set_compare_time(4, SK_VAL1_DW, SK_VAL2_DW);} 
03DA:  MOV     #2FDA,W4
03DC:  MOV     W4,194
03DE:  MOV     #1770,W4
03E0:  MOV     W4,192
.................... 						break; 
03E2:  BRA     414
.................... 					} 
.................... 			case 5: { 
.................... 						if(b){set_compare_time(5, SK_VAL1_UP, SK_VAL2_UP);} 
03E4:  CP0.B   97F
03E6:  BRA     Z,3F2
03E8:  MOV     #FA,W4
03EA:  MOV     W4,19A
03EC:  MOV     #1964,W4
03EE:  MOV     W4,198
03F0:  BRA     3FA
.................... 						else{set_compare_time(5, SK_VAL1_DW, SK_VAL2_DW);} 
03F2:  MOV     #2FDA,W4
03F4:  MOV     W4,19A
03F6:  MOV     #1770,W4
03F8:  MOV     W4,198
.................... 						break; 
03FA:  BRA     414
.................... 					} 
.................... 			case 6: { 
.................... 						if(b){set_compare_time(6, SK_VAL1_UP, SK_VAL2_UP);} 
03FC:  CP0.B   97F
03FE:  BRA     Z,40A
0400:  MOV     #FA,W4
0402:  MOV     W4,1A0
0404:  MOV     #1964,W4
0406:  MOV     W4,19E
0408:  BRA     412
.................... 						else{set_compare_time(6, SK_VAL1_DW, SK_VAL2_DW);} 
040A:  MOV     #2FDA,W4
040C:  MOV     W4,1A0
040E:  MOV     #1770,W4
0410:  MOV     W4,19E
.................... 						break; 
0412:  BRA     414
.................... 					} 
.................... 			default:{}	 
....................  
.................... 		} 
0414:  RETURN  
.................... } 
....................  
....................  
.................... #int_timer7  
.................... void timer7_isr(void) 
*
067E:  PUSH    42
0680:  PUSH    36
0682:  PUSH    32
0684:  MOV     W0,[W15++]
0686:  MOV     #2,W0
0688:  REPEAT  #C
068A:  MOV     [W0++],[W15++]
.................... {	 
.................... 	ziklReadCalibr++; 
068C:  INC     0854
.................... 	if(ziklREadCalibr>=MAX_COUNT_ZIKL_WAIT) 
068E:  MOV     854,W4
0690:  MOV     #320,W3
0692:  CP      W3,W4
0694:  BRA     GT,69E
.................... 	{ 
.................... 		errorRotate = ERROR_WAIT; 
0696:  MOV.B   #10,W0L
0698:  MOV.B   W0L,84C
.................... 		newStateAvt = S10;  
069A:  MOV     #200,W4
069C:  MOV     W4,852
.................... 	} 
.................... 	switch(currentStateAvt) 
069E:  MOV     84E,W0
06A0:  XOR     #0,W0
06A2:  BRA     Z,6CE
06A4:  XOR     #1,W0
06A6:  BRA     Z,6D8
06A8:  XOR     #3,W0
06AA:  BRA     Z,6E2
06AC:  XOR     #6,W0
06AE:  BRA     Z,6F0
06B0:  XOR     #C,W0
06B2:  BRA     Z,704
06B4:  XOR     #18,W0
06B6:  BRA     Z,70E
06B8:  XOR     #30,W0
06BA:  BRA     Z,718
06BC:  XOR     #60,W0
06BE:  BRA     Z,724
06C0:  XOR     #C0,W0
06C2:  BRA     Z,738
06C4:  XOR     #180,W0
06C6:  BRA     Z,742
06C8:  XOR     #300,W0
06CA:  BRA     Z,74C
06CC:  BRA     756
.................... 	{ 
.................... 		case S0 :{ initAvtomat(); newStateAvt = S1;    break;} 
06CE:  CALL    35A
06D2:  MOV     #1,W4
06D4:  MOV     W4,852
06D6:  BRA     760
.................... 		case S1 :{ resetCountZikl(); newStateAvt = S2;  break;} 
06D8:  CALL    396
06DC:  MOV     #2,W4
06DE:  MOV     W4,852
06E0:  BRA     760
.................... 		case S2 :{ setRotatePwm(1); newStateAvt = S3;  break;} 
06E2:  MOV.B   #1,W0L
06E4:  MOV.B   W0L,97C
06E6:  CALL    416
06EA:  MOV     #4,W4
06EC:  MOV     W4,852
06EE:  BRA     760
.................... 		case S3 :{ if(waitStop()){ newStateAvt = S4;  }else{ newStateAvt = S3;} break;}	 
06F0:  CALL    4D2
06F4:  CP0.B   W0L
06F6:  BRA     Z,6FE
06F8:  MOV     #8,W4
06FA:  MOV     W4,852
06FC:  BRA     702
06FE:  MOV     #4,W4
0700:  MOV     W4,852
0702:  BRA     760
.................... 		case S4 :{ readData1Adc(); newStateAvt = S5; break;} 
0704:  CALL    5B6
0708:  MOV     #10,W4
070A:  MOV     W4,852
070C:  BRA     760
.................... 		case S5 :{ resetCountZikl(); newStateAvt = S6; break;} 
070E:  CALL    396
0712:  MOV     #20,W4
0714:  MOV     W4,852
0716:  BRA     760
.................... 		case S6 :{ setRotatePwm(0); newStateAvt = S7; break;} 
0718:  CLR.B   97C
071A:  CALL    416
071E:  MOV     #40,W4
0720:  MOV     W4,852
0722:  BRA     760
.................... 		case S7 :{ if(waitStop()){ newStateAvt = S8;  }else{ newStateAvt = S7;} break;} 
0724:  CALL    4D2
0728:  CP0.B   W0L
072A:  BRA     Z,732
072C:  MOV     #80,W4
072E:  MOV     W4,852
0730:  BRA     736
0732:  MOV     #40,W4
0734:  MOV     W4,852
0736:  BRA     760
.................... 		case S8 :{ readData2Adc(); newStateAvt = S9; break;}	 
0738:  CALL    5C8
073C:  MOV     #100,W4
073E:  MOV     W4,852
0740:  BRA     760
.................... 		case S9 :{ sravnData(); newStateAvt = S10;  break;} 
0742:  CALL    5DA
0746:  MOV     #200,W4
0748:  MOV     W4,852
074A:  BRA     760
.................... 		case S10:{ stopTimer7(); setEnableSendData();  break;} 
074C:  CALL    644
0750:  CALL    66C
0754:  BRA     760
.................... 		default :{ stopTimer7(); setEnableSendData();  break;} 
0756:  CALL    644
075A:  CALL    66C
075E:  BRA     760
.................... 	}	 
.................... 	setDebugRS(); 
0760:  CALL    670
.................... 	updateState();  
0764:  CALL    674
....................  
0768:  BCLR.B  8A.0
076A:  MOV     #1A,W0
076C:  REPEAT  #C
076E:  MOV     [--W15],[W0--]
0770:  MOV     [--W15],W0
0772:  POP     32
0774:  POP     36
0776:  POP     42
0778:  RETFIE  
.................... } 
.................... void setDebugRS() 
.................... { 
.................... 	debugRS = 1; 
*
0670:  BSET.B  803.7
0672:  RETURN  
.................... } 
....................  
.................... void sendState( ) 
.................... { 
.................... 	if(debugRS ) 
.................... 	{ 
.................... 		switch(currentStateAvt) 
.................... 		{ 
.................... 			case S0 :{ sendRS(0x30); break;} 
.................... 			case S1 :{ sendRS(0x31); break;} 
.................... 			case S2 :{ sendRS(0x32); break;} 
.................... 			case S3 :{ sendRS(0x33); break;}	 
.................... 			case S4 :{ sendRS(0x34); break;} 
.................... 			case S5 :{ sendRS(0x35); break;} 
.................... 			case S6 :{ sendRS(0x36); break;} 
.................... 			case S7 :{ sendRS(0x37); break;} 
.................... 			case S8 :{ sendRS(0x38); break;}	 
.................... 			case S9 :{ sendRS(0x39);  break;} 
.................... 			case S10:{ sendRS(0x40);  break;} 
.................... 			default :{ sendRS(0x40);  break;} 
.................... 		} 
.................... 		debugRS = 0;  
.................... 	}	 
....................  
.................... } 
....................  
.................... //**************** 
.................... void sendDataCalibr() 
.................... { 
.................... 	setLimitAdcMotor(&m3, minAdc1, maxAdc1); 
*
147C:  MOV     #858,W4
147E:  MOV     W4,934
1480:  PUSH    80C
1482:  POP     936
1484:  PUSH    814
1486:  POP     938
1488:  CALL    13D0
.................... 	setLimitAdcMotor(&m4, maxAdc2, minAdc2); // перевернута шкала АЦП 
148C:  MOV     #888,W4
148E:  MOV     W4,934
1490:  PUSH    816
1492:  POP     936
1494:  PUSH    80E
1496:  POP     938
1498:  CALL    13D0
.................... 	setLimitAdcMotor(&m5, maxAdc3, minAdc3); // перевернута шкала АЦП 
149C:  MOV     #8B8,W4
149E:  MOV     W4,934
14A0:  PUSH    818
14A2:  POP     936
14A4:  PUSH    810
14A6:  POP     938
14A8:  CALL    13D0
.................... 	setLimitAdcMotor(&m6, minAdc4, maxAdc4); 
14AC:  MOV     #8E8,W4
14AE:  MOV     W4,934
14B0:  PUSH    812
14B2:  POP     936
14B4:  PUSH    81A
14B6:  POP     938
14B8:  CALL    13D0
....................  
.................... 	if(enabSendCalibrData) 
14BC:  BTSS.B  803.5
14BE:  BRA     151A
.................... 	{ 
.................... 		sendRS(adress);  
14C0:  MOV.B   802,W0L
14C2:  MOV.B   W0L,93E
14C4:  CALL    AA6
.................... 		sendRS(0x13); 
14C8:  MOV.B   #13,W0L
14CA:  MOV.B   W0L,93E
14CC:  CALL    AA6
.................... 		sendRS16(minADC1); 
14D0:  PUSH    80C
14D2:  POP     93E
14D4:  CALL    D3E
.................... 		sendRS16(minADC2); 
14D8:  PUSH    80E
14DA:  POP     93E
14DC:  CALL    D3E
.................... 		sendRS16(minADC3); 
14E0:  PUSH    810
14E2:  POP     93E
14E4:  CALL    D3E
.................... 		sendRS16(minADC4); 
14E8:  PUSH    812
14EA:  POP     93E
14EC:  CALL    D3E
.................... 		sendRS16(maxADC1); 
14F0:  PUSH    814
14F2:  POP     93E
14F4:  CALL    D3E
.................... 		sendRS16(maxADC2); 
14F8:  PUSH    816
14FA:  POP     93E
14FC:  CALL    D3E
.................... 		sendRS16(maxADC3); 
1500:  PUSH    818
1502:  POP     93E
1504:  CALL    D3E
.................... 		sendRS16(maxADC4); 
1508:  PUSH    81A
150A:  POP     93E
150C:  CALL    D3E
.................... 		sendRS(errorRotate);  
1510:  MOV.B   84C,W0L
1512:  MOV.B   W0L,93E
1514:  CALL    AA6
.................... 		enabSendCalibrData = 0;  
1518:  BCLR.B  803.5
.................... 	} 
151A:  RETURN  
.................... 	 
.................... 	 
.................... } 
.................... //**************** 
.................... void setEnableSendData() 
.................... { 
.................... 	enabSendCalibrData = 1;  
*
066C:  BSET.B  803.5
066E:  RETURN  
.................... } 
.................... //**************** 
.................... void readData1Adc() 
.................... { 
.................... 	readValADC11 = valAdc1; 
*
05B6:  PUSH    804
05B8:  POP     83C
.................... 	readValADC21 = valAdc2; 
05BA:  PUSH    806
05BC:  POP     840
.................... 	readValADC31 = valAdc3; 
05BE:  PUSH    808
05C0:  POP     844
.................... 	readValADC41 = valAdc4;  
05C2:  PUSH    80A
05C4:  POP     848
05C6:  RETURN  
.................... } 
....................  
.................... void readData2Adc() 
.................... { 
.................... 	readValADC12 = valAdc1; 
05C8:  PUSH    804
05CA:  POP     83E
.................... 	readValADC22 = valAdc2; 
05CC:  PUSH    806
05CE:  POP     842
.................... 	readValADC32 = valAdc3; 
05D0:  PUSH    808
05D2:  POP     846
.................... 	readValADC42 = valAdc4;  
05D4:  PUSH    80A
05D6:  POP     84A
05D8:  RETURN  
.................... } 
....................  
.................... //**************** 
.................... int1 waitStop() 
*
04D2:  MOV     W5,[W15++]
04D4:  MOV     W6,[W15++]
04D6:  MOV     W7,[W15++]
04D8:  MOV     W8,[W15++]
04DA:  BCLR.B  97C.0
.................... { 
.................... 	int1 boll = 0;  
.................... 	tempValADC11[indexDataRead] = valAdc1; 
04DC:  MOV     856,W4
04DE:  MUL.UU  W4,#2,W0
04E0:  MOV     #81C,W4
04E2:  ADD     W0,W4,W5
04E4:  MOV     804,W4
04E6:  MOV     W4,[W5+#0]
.................... 	tempValADC12[indexDataRead] = valAdc2; 
04E8:  MOV     856,W4
04EA:  MUL.UU  W4,#2,W0
04EC:  MOV     #824,W4
04EE:  ADD     W0,W4,W5
04F0:  MOV     806,W4
04F2:  MOV     W4,[W5+#0]
.................... 	tempValADC13[indexDataRead] = valAdc3; 
04F4:  MOV     856,W4
04F6:  MUL.UU  W4,#2,W0
04F8:  MOV     #82C,W4
04FA:  ADD     W0,W4,W5
04FC:  MOV     808,W4
04FE:  MOV     W4,[W5+#0]
.................... 	tempValADC14[indexDataRead] = valAdc4; 
0500:  MOV     856,W4
0502:  MUL.UU  W4,#2,W0
0504:  MOV     #834,W4
0506:  ADD     W0,W4,W5
0508:  MOV     80A,W4
050A:  MOV     W4,[W5+#0]
.................... 	indexDataRead++;  
050C:  INC     0856
.................... 	if(indexDataRead>=SIZE_TEMP_ADC) 
050E:  MOV     856,W4
0510:  CP      W4,#4
0512:  BRA     LT,516
.................... 	{ 
.................... 		indexDataRead = 0;  
0514:  CLR     856
.................... 	} 
.................... 	int1 a = getFullMasCalibr(tempValADC11[0], tempValADC11[1], tempValADC11[2], tempValADC11[3]);  
.................... 	int1 b = getFullMasCalibr(tempValADC12[0], tempValADC12[1], tempValADC12[2], tempValADC12[3]); 
.................... 	int1 c = getFullMasCalibr(tempValADC13[0], tempValADC13[1], tempValADC13[2], tempValADC13[3]); 
.................... 	int1 d = getFullMasCalibr(tempValADC14[0], tempValADC14[1], tempValADC14[2], tempValADC14[3]);  
0516:  PUSH    81C
0518:  POP     97E
051A:  PUSH    81E
051C:  POP     980
051E:  PUSH    820
0520:  POP     982
0522:  PUSH    822
0524:  POP     984
0526:  CALL    476
052A:  BCLR.B  97C.1
052C:  BTSC.B  0.0
052E:  BSET.B  97C.1
0530:  PUSH    824
0532:  POP     97E
0534:  PUSH    826
0536:  POP     980
0538:  PUSH    828
053A:  POP     982
053C:  PUSH    82A
053E:  POP     984
0540:  CALL    476
0544:  BCLR.B  97C.2
0546:  BTSC.B  0.0
0548:  BSET.B  97C.2
054A:  PUSH    82C
054C:  POP     97E
054E:  PUSH    82E
0550:  POP     980
0552:  PUSH    830
0554:  POP     982
0556:  PUSH    832
0558:  POP     984
055A:  CALL    476
055E:  BCLR.B  97C.3
0560:  BTSC.B  0.0
0562:  BSET.B  97C.3
0564:  PUSH    834
0566:  POP     97E
0568:  PUSH    836
056A:  POP     980
056C:  PUSH    838
056E:  POP     982
0570:  PUSH    83A
0572:  POP     984
0574:  CALL    476
0578:  BCLR.B  97C.4
057A:  BTSC.B  0.0
057C:  BSET.B  97C.4
.................... 	if(((a&b)&(c&d))) 
057E:  CLR     W0
0580:  BTSC.B  97C.1
0582:  INC     W0,W0
0584:  MOV.B   W0L,W6L
0586:  CLR     W0
0588:  BTSC.B  97C.2
058A:  INC     W0,W0
058C:  AND.B   W6L,W0L,W5L
058E:  CLR     W0
0590:  BTSC.B  97C.3
0592:  INC     W0,W0
0594:  MOV.B   W0L,W8L
0596:  CLR     W0
0598:  BTSC.B  97C.4
059A:  INC     W0,W0
059C:  AND.B   W8L,W0L,W0L
059E:  AND.B   W5L,W0L,W0L
05A0:  CP0.B   W0L
05A2:  BRA     Z,5A6
.................... 	{ 
.................... 		boll = 1;  
05A4:  BSET.B  97C.0
.................... 	}		 
.................... 	return boll;  
05A6:  CLR     W0
05A8:  BTSC.B  97C.0
05AA:  INC     W0,W0
05AC:  MOV     [--W15],W8
05AE:  MOV     [--W15],W7
05B0:  MOV     [--W15],W6
05B2:  MOV     [--W15],W5
05B4:  RETURN  
.................... } 
.................... //****************************** 
.................... void sravnData() 
.................... { 
.................... 	if(readValADC11>=readValADC12)  
*
05DA:  MOV     83E,W0
05DC:  MOV     83C,W4
05DE:  CP      W4,W0
05E0:  BRA     LT,5EC
.................... 	{  
.................... 		maxAdc1 = readValADC11;  
05E2:  PUSH    83C
05E4:  POP     814
.................... 		minAdc1 = readValADC12; 
05E6:  PUSH    83E
05E8:  POP     80C
.................... 	} 
05EA:  BRA     5F4
.................... 	else 
.................... 	{ 
.................... 		maxAdc1 = readValADC12;  
05EC:  PUSH    83E
05EE:  POP     814
.................... 		minAdc1 = readValADC11; 
05F0:  PUSH    83C
05F2:  POP     80C
.................... 	} 
....................  
.................... 	if(readValADC21>=readValADC22)  
05F4:  MOV     842,W0
05F6:  MOV     840,W4
05F8:  CP      W4,W0
05FA:  BRA     LT,606
.................... 	{  
.................... 		maxAdc2 = readValADC21;  
05FC:  PUSH    840
05FE:  POP     816
.................... 		minAdc2 = readValADC22; 
0600:  PUSH    842
0602:  POP     80E
.................... 	} 
0604:  BRA     60E
.................... 	else 
.................... 	{ 
.................... 		maxAdc2 = readValADC22;  
0606:  PUSH    842
0608:  POP     816
.................... 		minAdc2 = readValADC21; 
060A:  PUSH    840
060C:  POP     80E
.................... 	} 
....................  
.................... 	if(readValADC31>=readValADC32)  
060E:  MOV     846,W0
0610:  MOV     844,W4
0612:  CP      W4,W0
0614:  BRA     LT,620
.................... 	{  
.................... 		maxAdc3 = readValADC31;  
0616:  PUSH    844
0618:  POP     818
.................... 		minAdc3 = readValADC32; 
061A:  PUSH    846
061C:  POP     810
.................... 	} 
061E:  BRA     628
.................... 	else 
.................... 	{ 
.................... 		maxAdc3 = readValADC32;  
0620:  PUSH    846
0622:  POP     818
.................... 		minAdc3 = readValADC31; 
0624:  PUSH    844
0626:  POP     810
.................... 	} 
....................  
.................... 	if(readValADC41>=readValADC42)  
0628:  MOV     84A,W0
062A:  MOV     848,W4
062C:  CP      W4,W0
062E:  BRA     LT,63A
.................... 	{  
.................... 		maxAdc4 = readValADC41;  
0630:  PUSH    848
0632:  POP     81A
.................... 		minAdc4 = readValADC42; 
0634:  PUSH    84A
0636:  POP     812
.................... 	} 
0638:  BRA     642
.................... 	else 
.................... 	{ 
.................... 		maxAdc4 = readValADC42;  
063A:  PUSH    84A
063C:  POP     81A
.................... 		minAdc4 = readValADC41; 
063E:  PUSH    848
0640:  POP     812
.................... 	} 
0642:  RETURN  
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... void setRotatePwm(int1 b) 
.................... { 
....................  
.................... 		if(b) 
*
0416:  CP0.B   97C
0418:  BRA     Z,44C
.................... 		{ 
.................... 			testPWM(3, 1);  
041A:  MOV.B   #3,W0L
041C:  MOV.B   W0L,97E
041E:  MOV.B   #1,W0L
0420:  MOV.B   W0L,97F
0422:  CALL    39E
.................... 			testPWM(4, 1); 
0426:  MOV.B   #4,W0L
0428:  MOV.B   W0L,97E
042A:  MOV.B   #1,W0L
042C:  MOV.B   W0L,97F
042E:  CALL    39E
.................... 			testPWM(5, 1); 
0432:  MOV.B   #5,W0L
0434:  MOV.B   W0L,97E
0436:  MOV.B   #1,W0L
0438:  MOV.B   W0L,97F
043A:  CALL    39E
.................... 			testPWM(6, 1); 
043E:  MOV.B   #6,W0L
0440:  MOV.B   W0L,97E
0442:  MOV.B   #1,W0L
0444:  MOV.B   W0L,97F
0446:  CALL    39E
.................... 		} 
044A:  BRA     474
.................... 		else 
.................... 		{ 
.................... 			testPWM(3, 0);  
044C:  MOV.B   #3,W0L
044E:  MOV.B   W0L,97E
0450:  CLR.B   97F
0452:  CALL    39E
.................... 			testPWM(4, 0); 
0456:  MOV.B   #4,W0L
0458:  MOV.B   W0L,97E
045A:  CLR.B   97F
045C:  CALL    39E
.................... 			testPWM(5, 0); 
0460:  MOV.B   #5,W0L
0462:  MOV.B   W0L,97E
0464:  CLR.B   97F
0466:  CALL    39E
.................... 			testPWM(6, 0); 
046A:  MOV.B   #6,W0L
046C:  MOV.B   W0L,97E
046E:  CLR.B   97F
0470:  CALL    39E
.................... 		} 
0474:  RETURN  
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... void readCalibrTwo() 
.................... { 
.................... 	if((valAdc1&0xFFF0)<(minAdc1&0xFFF0)) 
.................... 	{ 
.................... 		maxAdc1 = minAdc1;  
.................... 		minAdc1 = valAdc1;  
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		maxAdc1 = valAdc1;  
.................... 	} 
....................  
.................... 	if((valAdc2&0xFFF0)<(minAdc2&0xFFF0)) 
.................... 	{ 
.................... 		maxAdc2 = minAdc2;  
.................... 		minAdc2 = valAdc2;  
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		maxAdc2 = valAdc2;  
.................... 	} 
....................  
.................... 	if((valAdc3&0xFFF0)<(minAdc3&0xFFF0)) 
.................... 	{ 
.................... 		maxAdc3 = minAdc3;  
.................... 		minAdc3 = valAdc3;  
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		maxAdc3 = valAdc3;  
.................... 	} 
....................  
.................... 	if((valAdc4&0xFFF0)<(minAdc4&0xFFF0)) 
.................... 	{ 
.................... 		maxAdc4 = minAdc4;  
.................... 		minAdc4 = valAdc4;  
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		maxAdc4 = valAdc4;  
.................... 	} 
.................... } 
....................  
.................... int1 getFullMasCalibr(int16 a, int16 b, int16 c, int16 d)  
0476:  MOV     W5,[W15++]
0478:  MOV     W6,[W15++]
.................... { 
....................  
.................... 	if((((a&ACCURACY_ADC)==(b&ACCURACY_ADC))&((c&ACCURACY_ADC)==(d&ACCURACY_ADC)))&((a&ACCURACY_ADC)==(c&ACCURACY_ADC))) 
047A:  MOV     #FFF0,W0
047C:  AND     97E,W0
047E:  MOV     W0,W5
0480:  MOV     #FFF0,W0
0482:  AND     980,W0
0484:  CP      W5,W0
0486:  BRA     Z,48C
0488:  CLR.B   W0
048A:  BRA     48E
048C:  MOV.B   #1,W0L
048E:  MOV.B   W0L,W5L
0490:  MOV     #FFF0,W0
0492:  AND     982,W0
0494:  MOV     W0,W6
0496:  MOV     #FFF0,W0
0498:  AND     984,W0
049A:  CP      W6,W0
049C:  BRA     Z,4A2
049E:  CLR.B   W0
04A0:  BRA     4A4
04A2:  MOV.B   #1,W0L
04A4:  AND.B   W5L,W0L,W5L
04A6:  MOV     #FFF0,W0
04A8:  AND     97E,W0
04AA:  MOV     W0,W6
04AC:  MOV     #FFF0,W0
04AE:  AND     982,W0
04B0:  CP      W6,W0
04B2:  BRA     Z,4B8
04B4:  CLR.B   W0
04B6:  BRA     4BA
04B8:  MOV.B   #1,W0L
04BA:  AND.B   W5L,W0L,W0L
04BC:  CP0.B   W0L
04BE:  BRA     Z,4C8
.................... 	{ 
.................... 		return 1;  
04C0:  MOV.B   #1,W0L
04C2:  MOV.B   W0L,0
04C4:  BRA     4CC
.................... 	} 
04C6:  BRA     4CC
.................... 	else 
.................... 	{ 
.................... 		return 0;  
04C8:  CLR.B   0
04CA:  BRA     4CC
.................... 	} 
04CC:  MOV     [--W15],W6
04CE:  MOV     [--W15],W5
04D0:  RETURN  
....................  
.................... } 
....................  
....................  
.................... #include "motor.c" 
.................... #include "motor.h" 
.................... #ifndef MOTOR_H 
.................... #define MOTOR_H 
....................  
.................... #define MIN_ERROR  2.0f // минимальная ошибка для доворота  
....................  
.................... #define MIN_DADC 0x0008  
....................  
.................... // Error 
.................... // bits 
.................... #define ERR_DADC 0x08 //(dADC<MIN_ADC) 
.................... #define ERR_VADC2_B   0x04 //vAdc1<vAdc2 
.................... #define ERR_VADC1_B   0x02 //vAdc1>vAdc2 
.................... #define ERR_VADC_RAVN 0x01 //vAdc1=vAdc2 
.................... #define MAX_INT_ERROR 50     
.................... #define MIN_INT_ERROR (-50)  
....................  
....................  
.................... typedef struct MotorAs 
.................... { 
.................... 	int canalPwm;  // пин ШИМ 
.................... 	int1 upValue; //флаг направления движения, вводит относительный верх и  низ у нескольких моторов 
.................... 	int16 minValAdc; //минимальное значение ацп на одном краю шкалы 
.................... 	int16 maxValAdc; //максимальное значение ацп на другом краю шкалы 
.................... 	int16 oldValAdc; // прошлое значение используемое для установки  
.................... 	int16 newValue; // новое значение в которое необходимо перейти стрелке 
.................... 	float dAdc; 	// разность макс и мин значения АЦП 
.................... 	float kP;  // 	(POL_POL_PERIOD/m->dAdc) где (POL_POL_PERIOD) знач ШИМ для макс  
.................... 				//скорости(1/4Шим(90градусов сдвиг между каналами ШИМ))))  
.................... 				// и m->dAdc диапазон шкалы в значениях АЦП 
.................... 	float kD;  
.................... 	float kI;  
.................... 	int8 Error;    // хранит ошибки и текущее состояние  
.................... 	int16 minSpeed; // минимальное значение ШИМ при котором стрелка двигается 
.................... 	int16 maxSpeed; // максимальное значение ШИМ при котором стрелка двигается (1/4 значения счетчика ШИМ) 
.................... 	int16 maxAccel; // максимальное ускорение 
.................... 	int16 minAccel; // минимальное ускорение  
.................... 	int16 oldSpeed; // значение скорости в прошлый перерасчет положения 
.................... 	int1 enabRotate; // разрешение вращения  
.................... 	signed int maxIEr; // максимальная ошибка интегр. сост  
.................... 	signed int minIEr; // минимальная ошибка интегр. сост 
.................... 	signed int integrError; 
.................... } Motor;  
....................  
....................   
....................   
.................... void initMotor(Motor * m, int cPwm, int16 tPwm, int16 vAdc1, int16 vAdc2);  
.................... void setLimitAdcMotor(Motor *m, int16 vAdc1, int16 vAdc2); 
.................... void setMinSpeed(Motor *m,int16 data);  
.................... void setMaxSpeed(Motor *m,int16 data);     
.................... void setRotate(Motor *m, int16 currentData, int16 newData);  
.................... int16 difSost(Motor *m, float data);  
.................... int16 intSost(Motor *m, int1 dir, float data);  
.................... int16 proSost(Motor *m, int16 data, float eData);  
.................... void setNewValueMotor (Motor *m, int16 data);  
.................... void setK(Motor *m); 
.................... void setMaxAccel(Motor *m, int16 data);   
....................  
....................  
.................... #endif 
....................  
....................  
.................... void initMotor(Motor * m, int cPwm,  int16 tPwm, int16 vAdc1, int16 vAdc2) 
*
08F4:  MOV     W5,[W15++]
08F6:  MOV     W6,[W15++]
.................... { 
.................... 	m->canalPwm = cPwm;  
08F8:  MOV     934,W5
08FA:  MOV     936,W4
08FC:  MOV     W4,[W5+#0]
.................... 	m->upValue = 0;   
08FE:  MOV     #2,W0
0900:  ADD     934,W0
0902:  MOV     W0,W5
0904:  MOV     #FE,W4
0906:  AND.B   W4L,[W5],[W5]
.................... 	m->minSpeed = 100; 
0908:  MOV     #1E,W0
090A:  ADD     934,W0
090C:  MOV     W0,W5
090E:  MOV.B   #64,W0L
0910:  MOV.B   W0L,[W5]
0912:  MOV.B   #0,W0L
0914:  MOV.B   W0L,[W5+#1]
.................... 	m->maxSpeed = POL_POL_PERIOD;   
0916:  MOV     #20,W0
0918:  ADD     934,W0
091A:  MOV     W0,W5
091C:  MOV.B   #35,W0L
091E:  MOV.B   W0L,[W5]
0920:  MOV.B   #C,W0L
0922:  MOV.B   W0L,[W5+#1]
.................... 	m->enabRotate = 1; 
0924:  MOV     #28,W0
0926:  ADD     934,W0
0928:  MOV     W0,W5
092A:  MOV     #1,W4
092C:  IOR.B    W4L,  [W5],[W5]
.................... 	m->Error = 0;  
092E:  MOV     #1C,W0
0930:  ADD     934,W0
0932:  MOV     W0,W5
0934:  CLR.B   [W5]
.................... 	m->oldValAdc = 0;  
0936:  MOV     #8,W0
0938:  ADD     934,W0
093A:  MOV     W0,W5
093C:  CLR.B   [W5]
093E:  MOV.B   #0,W0L
0940:  MOV.B   W0L,[W5+#1]
.................... 	m->newValue = 0;  
0942:  MOV     #A,W0
0944:  ADD     934,W0
0946:  MOV     W0,W5
0948:  CLR.B   [W5]
094A:  MOV.B   #0,W0L
094C:  MOV.B   W0L,[W5+#1]
.................... 	m->kP = 0;  
094E:  MOV     #10,W0
0950:  ADD     934,W0
0952:  MOV     W0,W5
0954:  CLR.B   [W5]
0956:  MOV.B   #0,W0L
0958:  MOV.B   W0L,[W5+#1]
095A:  MOV.B   #0,W0L
095C:  MOV.B   W0L,[W5+#2]
095E:  MOV.B   #0,W0L
0960:  MOV.B   W0L,[W5+#3]
.................... 	m->kD = 0;  
0962:  MOV     #14,W0
0964:  ADD     934,W0
0966:  MOV     W0,W5
0968:  CLR.B   [W5]
096A:  MOV.B   #0,W0L
096C:  MOV.B   W0L,[W5+#1]
096E:  MOV.B   #0,W0L
0970:  MOV.B   W0L,[W5+#2]
0972:  MOV.B   #0,W0L
0974:  MOV.B   W0L,[W5+#3]
.................... 	m->minAccel = 0;  
0976:  MOV     #24,W0
0978:  ADD     934,W0
097A:  MOV     W0,W5
097C:  CLR.B   [W5]
097E:  MOV.B   #0,W0L
0980:  MOV.B   W0L,[W5+#1]
.................... 	m->maxAccel = POL_POL_PERIOD;  
0982:  MOV     #22,W0
0984:  ADD     934,W0
0986:  MOV     W0,W5
0988:  MOV.B   #35,W0L
098A:  MOV.B   W0L,[W5]
098C:  MOV.B   #C,W0L
098E:  MOV.B   W0L,[W5+#1]
.................... 	m->oldSpeed = 0; 
0990:  MOV     #26,W0
0992:  ADD     934,W0
0994:  MOV     W0,W5
0996:  CLR.B   [W5]
0998:  MOV.B   #0,W0L
099A:  MOV.B   W0L,[W5+#1]
.................... 	m->integrError = 0; 
099C:  MOV     #2E,W0
099E:  ADD     934,W0
09A0:  MOV     W0,W5
09A2:  CLR.B   [W5]
09A4:  MOV.B   #0,W0L
09A6:  MOV.B   W0L,[W5+#1]
.................... 	m->maxIEr = (m->minSpeed<<3);  
09A8:  MOV     #2A,W0
09AA:  ADD     934,W0
09AC:  MOV     W0,W5
09AE:  MOV     #1E,W0
09B0:  ADD     934,W0
09B2:  MOV     [W0],W6
09B4:  SL      W6,#3,W0
09B6:  MOV     W0,[W5]
.................... 	m->minIEr = ((m->minSpeed<<3)*(-1));   
09B8:  MOV     #2C,W0
09BA:  ADD     934,W0
09BC:  MOV     W0,W5
09BE:  MOV     #1E,W0
09C0:  ADD     934,W0
09C2:  MOV     [W0],W6
09C4:  SL      W6,#3,W6
09C6:  MOV     #FFFF,W4
09C8:  MUL.US  W6,W4,W0
09CA:  MOV     W0,[W5]
09CC:  MOV     [--W15],W6
09CE:  MOV     [--W15],W5
09D0:  RETURN  
.................... } 
....................  
.................... void updateError(Motor *m) 
.................... { 
.................... 	int16 dAdc  = (m->maxValAdc - m->minValAdc); 
.................... 	if(dAdc < MIN_DADC) 
.................... 	{ 
.................... 		m->error |= ERR_DADC; 
.................... 		m->enabRotate = 0;  
.................... 	} 
.................... 	 
....................  
.................... } 
.................... void setLimitAdcMotor(Motor *m, int16 vAdc1, int16 vAdc2) 
*
13D0:  MOV     W5,[W15++]
13D2:  MOV     W6,[W15++]
.................... { 
.................... 	if(vAdc1>vAdc2) 
13D4:  MOV     938,W0
13D6:  MOV     936,W4
13D8:  CP      W4,W0
13DA:  BRA     LE,140A
.................... 	{ 
.................... 		m->upValue = 0;  
13DC:  MOV     #2,W0
13DE:  ADD     934,W0
13E0:  MOV     W0,W5
13E2:  MOV     #FE,W4
13E4:  AND.B   W4L,[W5],[W5]
.................... 		m->minValAdc = vAdc2;  
13E6:  MOV     #4,W0
13E8:  ADD     934,W0
13EA:  MOV     W0,W5
13EC:  MOV     938,W4
13EE:  MOV     W4,[W5+#0]
.................... 		m->maxValAdc = vAdc1;  
13F0:  MOV     #6,W0
13F2:  ADD     934,W0
13F4:  MOV     W0,W5
13F6:  MOV     936,W4
13F8:  MOV     W4,[W5+#0]
.................... 		m->Error |= ERR_VADC1_B;  
13FA:  MOV     #1C,W0
13FC:  ADD     934,W0
13FE:  MOV     W0,W5
1400:  MOV.B   [W5],W0L
1402:  CLR.B   1
1404:  IOR      W0,  #2,W0
1406:  MOV.B   W0L,[W5]
.................... 	} 
1408:  BRA     144E
.................... 	else 
.................... 	{	 
.................... 		if(vAdc1<vAdc2) 
140A:  MOV     936,W0
140C:  MOV     938,W4
140E:  CP      W4,W0
1410:  BRA     LE,1440
.................... 		{	 
.................... 			m->upValue = 1;  
1412:  MOV     #2,W0
1414:  ADD     934,W0
1416:  MOV     W0,W5
1418:  MOV     #1,W4
141A:  IOR.B    W4L,  [W5],[W5]
.................... 			m->minValAdc = vAdc1;  
141C:  MOV     #4,W0
141E:  ADD     934,W0
1420:  MOV     W0,W5
1422:  MOV     936,W4
1424:  MOV     W4,[W5+#0]
.................... 			m->maxValAdc = vAdc2; 
1426:  MOV     #6,W0
1428:  ADD     934,W0
142A:  MOV     W0,W5
142C:  MOV     938,W4
142E:  MOV     W4,[W5+#0]
.................... 			m->Error |= ERR_VADC2_B; 
1430:  MOV     #1C,W0
1432:  ADD     934,W0
1434:  MOV     W0,W5
1436:  MOV.B   [W5],W0L
1438:  CLR.B   1
143A:  IOR      W0,  #4,W0
143C:  MOV.B   W0L,[W5]
.................... 		} 
143E:  BRA     144E
.................... 		else 
.................... 		{ 
.................... 			m->Error |= ERR_VADC_RAVN;  
1440:  MOV     #1C,W0
1442:  ADD     934,W0
1444:  MOV     W0,W5
1446:  MOV.B   [W5],W0L
1448:  CLR.B   1
144A:  IOR      W0,  #1,W0
144C:  MOV.B   W0L,[W5]
.................... 		} 
.................... 	}  
.................... 	m->dAdc = ((float)(m->maxValAdc - m->minValAdc)); 
144E:  MOV     #C,W0
1450:  ADD     934,W0
1452:  MOV     W0,W5
1454:  MOV     #6,W0
1456:  ADD     934,W0
1458:  MOV     [W0],W6
145A:  MOV     #4,W0
145C:  ADD     934,W0
145E:  MOV     W0,W4
1460:  MOV     [W4],W0
1462:  SUB     W6,W0,W0
1464:  CALL    B70
1468:  MOV     #0,W4
146A:  MOV     [W4++],[W5++]
146C:  MOV     [W4++],[W5++]
.................... 	setK(m);  
146E:  PUSH    934
1470:  POP     946
1472:  CALL    C84
1476:  MOV     [--W15],W6
1478:  MOV     [--W15],W5
147A:  RETURN  
.................... //	m->newValue = m->maxValAdc;    
.................... }   
....................  
.................... void setMinSpeed(Motor *m, int16 data) 
*
0AD0:  MOV     W5,[W15++]
0AD2:  MOV     W6,[W15++]
.................... { 
.................... 	m->minSpeed = data;  
0AD4:  MOV     #1E,W0
0AD6:  ADD     93E,W0
0AD8:  MOV     W0,W5
0ADA:  MOV     940,W4
0ADC:  MOV     W4,[W5+#0]
.................... 	m->maxIEr = (m->minSpeed<<3);  
0ADE:  MOV     #2A,W0
0AE0:  ADD     93E,W0
0AE2:  MOV     W0,W5
0AE4:  MOV     #1E,W0
0AE6:  ADD     93E,W0
0AE8:  MOV     [W0],W6
0AEA:  SL      W6,#3,W0
0AEC:  MOV     W0,[W5]
.................... 	m->minIEr = ((m->minSpeed<<3)*(-1)); 
0AEE:  MOV     #2C,W0
0AF0:  ADD     93E,W0
0AF2:  MOV     W0,W5
0AF4:  MOV     #1E,W0
0AF6:  ADD     93E,W0
0AF8:  MOV     [W0],W6
0AFA:  SL      W6,#3,W6
0AFC:  MOV     #FFFF,W4
0AFE:  MUL.US  W6,W4,W0
0B00:  MOV     W0,[W5]
0B02:  MOV     [--W15],W6
0B04:  MOV     [--W15],W5
0B06:  RETURN  
.................... } 
....................  
.................... void setK(Motor *m) 
*
0C84:  MOV     W5,[W15++]
0C86:  MOV     W6,[W15++]
0C88:  MOV     W7,[W15++]
0C8A:  MOV     W8,[W15++]
.................... { 
.................... 	if(m->dAdc>0) 
0C8C:  MOV     #C,W0
0C8E:  ADD     946,W0
0C90:  MOV     #A,W4
0C92:  MOV     [W0++],[W4++]
0C94:  MOV     [W0++],[W4++]
0C96:  MOV     #0,W0
0C98:  MOV     #0,W1
0C9A:  MOV     W5,W2
0C9C:  MOV     W6,W3
0C9E:  CALL    B08
0CA2:  BRA     NC,CD0
.................... 	{ 
.................... 		m->kP = (m->maxSpeed/m->dAdc);  
0CA4:  MOV     #10,W0
0CA6:  ADD     946,W0
0CA8:  MOV     W0,W5
0CAA:  MOV     #20,W0
0CAC:  ADD     946,W0
0CAE:  MOV     [W0],W6
0CB0:  MOV     #C,W0
0CB2:  ADD     946,W0
0CB4:  MOV     #E,W4
0CB6:  MOV     [W0++],[W4++]
0CB8:  MOV     [W0++],[W4++]
0CBA:  MOV     W6,W0
0CBC:  CALL    B70
0CC0:  MOV     W7,W2
0CC2:  MOV     W8,W3
0CC4:  CALL    BBA
0CC8:  MOV     #0,W4
0CCA:  MOV     [W4++],[W5++]
0CCC:  MOV     [W4++],[W5++]
.................... 	} 
0CCE:  BRA     CEC
.................... 	else 
.................... 	{ 
.................... 		m->Error = 0;  
0CD0:  MOV     #1C,W0
0CD2:  ADD     946,W0
0CD4:  MOV     W0,W5
0CD6:  CLR.B   [W5]
.................... 		m->kP = 1; 	 
0CD8:  MOV     #10,W0
0CDA:  ADD     946,W0
0CDC:  MOV     W0,W5
0CDE:  CLR.B   [W5]
0CE0:  MOV.B   #0,W0L
0CE2:  MOV.B   W0L,[W5+#1]
0CE4:  MOV.B   #80,W0L
0CE6:  MOV.B   W0L,[W5+#2]
0CE8:  MOV.B   #3F,W0L
0CEA:  MOV.B   W0L,[W5+#3]
.................... 	} 
.................... //	m->kD = (m->kP*0.3f); 
.................... 	//m->kI = 0.01;//m->minSpeed; 
.................... 	m->kI = m->minSpeed;  
0CEC:  MOV     #18,W0
0CEE:  ADD     946,W0
0CF0:  MOV     W0,W5
0CF2:  MOV     #1E,W0
0CF4:  ADD     946,W0
0CF6:  MOV     W0,W4
0CF8:  MOV     [W4],W0
0CFA:  CALL    B70
0CFE:  MOV     #0,W4
0D00:  MOV     [W4++],[W5++]
0D02:  MOV     [W4++],[W5++]
0D04:  MOV     [--W15],W8
0D06:  MOV     [--W15],W7
0D08:  MOV     [--W15],W6
0D0A:  MOV     [--W15],W5
0D0C:  RETURN  
.................... } 
....................  
.................... void setMaxSpeed(Motor *m,int16 data) 
0D0E:  MOV     W5,[W15++]
.................... { 
.................... 	if(data>POL_POL_PERIOD) 
0D10:  MOV     940,W4
0D12:  MOV     #C35,W3
0D14:  CP      W3,W4
0D16:  BRA     GE,D28
.................... 	{ 
.................... 		m->maxSpeed = POL_POL_PERIOD;		 
0D18:  MOV     #20,W0
0D1A:  ADD     93E,W0
0D1C:  MOV     W0,W5
0D1E:  MOV.B   #35,W0L
0D20:  MOV.B   W0L,[W5]
0D22:  MOV.B   #C,W0L
0D24:  MOV.B   W0L,[W5+#1]
.................... 	} 
0D26:  BRA     D32
.................... 	else 
.................... 	{ 
.................... 		m->maxSpeed = data; 
0D28:  MOV     #20,W0
0D2A:  ADD     93E,W0
0D2C:  MOV     W0,W5
0D2E:  MOV     940,W4
0D30:  MOV     W4,[W5+#0]
.................... 	}  
....................  
.................... 	setK(m);  
0D32:  PUSH    93E
0D34:  POP     946
0D36:  CALL    C84
0D3A:  MOV     [--W15],W5
0D3C:  RETURN  
.................... } 
....................  
.................... int16 difSost(Motor *m, float data) 
*
1710:  MOV     W5,[W15++]
1712:  CLR     958
1714:  MOV     #1E,W0
1716:  ADD     952,W0
1718:  MOV     [W0],W5
171A:  MOV     W5,95A
171C:  LSR     95A
.................... {	 
.................... 	int16 result = 0; 
.................... 	int16 d = (m->minSpeed>>1);    
.................... 	if(data>d)//(MIN_ERROR)) 
171E:  MOV     95A,W0
1720:  CALL    B70
1724:  MOV     954,W2
1726:  MOV     956,W3
1728:  CALL    B08
172C:  BRA     NC,1732
.................... 	{ 
.................... 		result = d; //data*m->kD; //m->minSpeed>>1;  
172E:  PUSH    95A
1730:  POP     958
.................... 	} 
.................... 	return result;  
1732:  PUSH    958
1734:  POP     0
1736:  MOV     [--W15],W5
1738:  RETURN  
.................... } 
.................... int16  intSost(Motor *m,int1 dir,  float data) 
*
1638:  MOV     W5,[W15++]
163A:  MOV     W6,[W15++]
163C:  CLR     956
.................... { 
.................... 	int16 result = 0; 
.................... 	 
.................... 	if(dir) 
163E:  CP0.B   950
1640:  BRA     Z,1656
.................... 	{ 
.................... 		m->integrError +=((int16)data);  
1642:  MOV     #2E,W0
1644:  ADD     94E,W0
1646:  MOV     W0,W5
1648:  MOV     952,W0
164A:  MOV     954,W1
164C:  CALL    15E0
1650:  MOV     W0,W6
1652:  ADD     W6,[W5],[W5]
.................... 	} 
1654:  BRA     166A
.................... 	else 
.................... 	{ 
.................... 		m->integrError -= ((int16)data); 
1656:  MOV     #2E,W0
1658:  ADD     94E,W0
165A:  MOV     W0,W5
165C:  MOV     952,W0
165E:  MOV     954,W1
1660:  CALL    15E0
1664:  MOV     W0,W6
1666:  MOV     [W5],W4
1668:  SUB     W4,W6,[W5]
.................... 	}	 
....................  
.................... 	if(m->integrError> m->maxIEr ) 
166A:  MOV     #2E,W0
166C:  ADD     94E,W0
166E:  MOV     [W0],W5
1670:  MOV     #2A,W0
1672:  ADD     94E,W0
1674:  MOV     W0,W4
1676:  MOV     [W4],W0
1678:  CP      W0,W5
167A:  BRA     GE,1688
.................... 	{ 
.................... 		m->integrError = m->maxIEr;  
167C:  MOV     #2E,W0
167E:  ADD     94E,W0
1680:  MOV     W0,W5
1682:  MOV     #2A,W0
1684:  ADD     94E,W0
1686:  MOV     [W0],[W5]
.................... 	} 
.................... 	 
.................... 	if(m->integrError< m->minIEr) 
1688:  MOV     #2E,W0
168A:  ADD     94E,W0
168C:  MOV     [W0],W5
168E:  MOV     #2C,W0
1690:  ADD     94E,W0
1692:  MOV     W0,W4
1694:  MOV     [W4],W0
1696:  CP      W5,W0
1698:  BRA     GE,16A6
.................... 	{ 
.................... 		m->integrError = m->minIEr; 
169A:  MOV     #2E,W0
169C:  ADD     94E,W0
169E:  MOV     W0,W5
16A0:  MOV     #2C,W0
16A2:  ADD     94E,W0
16A4:  MOV     [W0],[W5]
.................... 	} 
.................... 	 
.................... 	if(m->integrError<0) 
16A6:  MOV     #2E,W0
16A8:  ADD     94E,W0
16AA:  MOV     [W0],W5
16AC:  CP      W5,#0
16AE:  BRA     GE,16DC
.................... 	{ 
.................... 		float d =  (((float)m->integrError)*(-0.1f)); 	 
16B0:  MOV     #2E,W0
16B2:  ADD     94E,W0
16B4:  MOV     W0,W4
16B6:  MOV     [W4],W0
16B8:  CALL    B70
16BC:  MOV     W0,W5
16BE:  MOV     W1,W6
16C0:  MOV     W5,W0
16C2:  MOV     W6,W1
16C4:  MOV     #CCCD,W2
16C6:  MOV     #BDCC,W3
16C8:  CALL    151C
16CC:  MOV     W0,958
16CE:  MOV     W1,95A
.................... 		result = ((int16) d); 
16D0:  MOV     958,W0
16D2:  MOV     95A,W1
16D4:  CALL    15E0
16D8:  MOV     W0,956
.................... 	} 
16DA:  BRA     1706
.................... 	else 
.................... 	{ 
.................... 		float d = (((float)m->integrError)*(0.1f));  
16DC:  MOV     #2E,W0
16DE:  ADD     94E,W0
16E0:  MOV     W0,W4
16E2:  MOV     [W4],W0
16E4:  CALL    B70
16E8:  MOV     W0,W5
16EA:  MOV     W1,W6
16EC:  MOV     W5,W0
16EE:  MOV     W6,W1
16F0:  MOV     #CCCD,W2
16F2:  MOV     #3DCC,W3
16F4:  CALL    151C
16F8:  MOV     W0,95C
16FA:  MOV     W1,95E
.................... 		result = ((int16) d); 
16FC:  MOV     95C,W0
16FE:  MOV     95E,W1
1700:  CALL    15E0
1704:  MOV     W0,956
.................... 	} 
.................... 	 
.................... 	//if(data>MIN_ERROR) 
.................... 	{ 
.................... 		 //result = ((int16)(data*m->kI)); 
.................... 		 //result = (((int16)m->integrError)&0xFFFF);    
.................... 		  
.................... 	} 
....................  
.................... 	return result;  
1706:  PUSH    956
1708:  POP     0
170A:  MOV     [--W15],W6
170C:  MOV     [--W15],W5
170E:  RETURN  
.................... } 
....................  
.................... int16 proSost(Motor *m, int16 data, float eData) 
*
160C:  MOV     #10,W0
160E:  ADD     94A,W0
1610:  MOV     W0,W4
1612:  MOV     #0,W3
1614:  MOV     [W4++],[W3++]
1616:  MOV     [W4++],[W3++]
1618:  MOV     W0,W2
161A:  MOV     W1,W3
161C:  MOV     94E,W0
161E:  MOV     950,W1
1620:  CALL    151C
1624:  MOV     W0,952
1626:  MOV     W1,954
1628:  MOV     952,W0
162A:  MOV     954,W1
162C:  CALL    15E0
1630:  MOV     W0,956
.................... { 
.................... 	 
.................... 	//float ps =((((float)(data*POL_POL_PERIOD))/m->dAdc)); 
.................... 	float ps =((float)(eData*m->kP)); 
.................... 	int16 newSpeed = ((int16) ps);  
....................  
.................... 	// введение ограничений на величину изменения АЦП между измерениями    
.................... 	// текущая скорость  
.................... /*	int16 Vtek = 0; 
.................... 	// ускорение  
.................... 	int16 Atek = 0;  
.................... 	 
.................... 	if(data>m->oldValAdc) 
.................... 	{ 
.................... 		Vtek = (data - m->oldValAdc); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		Vtek = (m->oldValAdc - data);  
.................... 	} 
....................  
.................... 	if(Vtek>m->oldSpeed) 
.................... 	{ 
.................... 		Atek = (Vtek - m->oldSpeed); 		 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		Atek = (m->oldSpeed - Vtek);  
.................... 	} 
.................... 	m->oldSpeed = Vtek;  
.................... 	int16 kor = 0;  
.................... 	 
.................... 	if(Atek>m->maxAccel) 
.................... 	{ 
.................... 		kor = Atek - m->maxAccel;  
.................... 	} 
.................... 	float nS; */ 
.................... /*	if(newSpeed>kor) 
.................... 	{ 
.................... 		nS =(((float) newSpeed)*0.9f); 
.................... 		newSpeed = ((int16) ns);   
....................  	}  */  
.................... 	return newSpeed; 
1632:  PUSH    956
1634:  POP     0
1636:  RETURN  
.................... 	 
.................... } 
....................  
.................... void setNewValueMotor(Motor *m, int16 data) 
.................... { 
.................... 	m->newValue = (data&0xFFFF);  
....................  
.................... }  
....................  
.................... void setRotate(Motor *m, int16 currentDataS, int16 newData) 
*
173A:  MOV     W5,[W15++]
173C:  MOV     W6,[W15++]
173E:  MOV     W7,[W15++]
1740:  MOV     W8,[W15++]
.................... {	 
....................  m->newValue = (newData&0xFFFE); 
1742:  MOV     #A,W0
1744:  ADD     936,W0
1746:  MOV     W0,W5
1748:  MOV     #FFFE,W0
174A:  AND     93A,W0
174C:  MOV     W0,[W5]
.................... int16 currentData =  (currentDataS&0xFFFE); 
174E:  PUSH    938
1750:  POP     93C
1752:  MOV     #FFFE,W0
1754:  AND     93C
.................... // проверка на завершение калибровки ацп 
.................... if(m->enabRotate) 
1756:  MOV     #28,W0
1758:  ADD     936,W0
175A:  MOV.B   [W0],W4L
175C:  BTSS    W4.0
175E:  BRA     1A80
.................... 	{ 
.................... 	 
.................... 		if((m->Error&0x02)|(m->Error&0x04)) // если ацп работает и значения отличаются 
1760:  MOV     #1C,W0
1762:  ADD     936,W0
1764:  MOV.B   [W0],W5L
1766:  SE      W5,W5
1768:  AND     W5,#2,W5
176A:  MOV     #1C,W0
176C:  ADD     936,W0
176E:  MOV.B   [W0],W7L
1770:  SE      W7,W7
1772:  AND     W7,#4,W0
1774:  IOR      W5,  W0,W0
1776:  CP0     W0
1778:  BRA     Z,1A80
.................... 		{ 
.................... 			int16 n = 0;  
.................... 			float error = 0;  
177A:  CLR     93E
177C:  CLR     940
177E:  CLR     942
.................... 			if(currentData>m->newValue)// направление движения 
1780:  MOV     #A,W0
1782:  ADD     936,W0
1784:  MOV     W0,W4
1786:  MOV     [W4],W0
1788:  MOV     93C,W4
178A:  CP      W4,W0
178C:  BRA     LE,18E2
.................... 			{//niz 
.................... 				error = currentData - m->newValue; // рассогласование 
178E:  MOV     #A,W0
1790:  ADD     936,W0
1792:  MOV     W0,W4
1794:  MOV     [W4],W0
1796:  MOV     93C,W4
1798:  SUB     W4,W0,W0
179A:  CALL    B70
179E:  MOV     W0,940
17A0:  MOV     W1,942
.................... 				n = ((proSost(m,currentData, error)+ intSost(m,1, error))- difSost(m, currentData)); // значение ШИМ 
17A2:  PUSH    936
17A4:  POP     94A
17A6:  PUSH    93C
17A8:  POP     94C
17AA:  PUSH    940
17AC:  POP     94E
17AE:  PUSH    942
17B0:  POP     950
17B2:  CALL    160C
17B6:  MOV     W0,W5
17B8:  MOV.B   #1,W0L
17BA:  MOV.B   W0L,950
17BC:  PUSH    936
17BE:  POP     94E
17C0:  PUSH    940
17C2:  POP     952
17C4:  PUSH    942
17C6:  POP     954
17C8:  CALL    1638
17CC:  ADD     W0,W5,W5
17CE:  MOV     93C,W0
17D0:  CALL    B70
17D4:  MOV.D   W0,W6
17D6:  PUSH    936
17D8:  POP     952
17DA:  MOV     W6,954
17DC:  MOV     W7,956
17DE:  CALL    1710
17E2:  SUB     W5,W0,W0
17E4:  MOV     W0,93E
.................... 				if(m->upValue) // двигатели крутятся в разные стороны потому понятие верх и низ для каждого индивидуально 
17E6:  MOV     #2,W0
17E8:  ADD     936,W0
17EA:  MOV.B   [W0],W4L
17EC:  BTSS    W4.0
17EE:  BRA     1844
.................... 				{				// и верх совпал с макс ацп 
.................... 					switch(m->canalPwm&0xFF) // для индексов  
17F0:  MOV     936,W0
17F2:  MOV     [W0],W5
17F4:  MOV     W5,W0
17F6:  AND     #FF,W0
17F8:  XOR     #3,W0
17FA:  BRA     Z,180A
17FC:  XOR     #7,W0
17FE:  BRA     Z,1818
1800:  XOR     #1,W0
1802:  BRA     Z,1826
1804:  XOR     #3,W0
1806:  BRA     Z,1834
1808:  BRA     1842
.................... 					{ 
.................... 						case 3: { set_compare_time(3, n,(n+POL_PERIOD)); break; } 
180A:  MOV     #186A,W4
180C:  MOV     93E,W3
180E:  ADD     W3,W4,W5
1810:  PUSH    93E
1812:  POP     18E
1814:  MOV     W5,18C
1816:  BRA     1842
.................... 						case 4: { set_compare_time(4, n,(n+POL_PERIOD)); break; } 
1818:  MOV     #186A,W4
181A:  MOV     93E,W3
181C:  ADD     W3,W4,W5
181E:  PUSH    93E
1820:  POP     194
1822:  MOV     W5,192
1824:  BRA     1842
.................... 						case 5: { set_compare_time(5, n,(n+POL_PERIOD)); break; } 
1826:  MOV     #186A,W4
1828:  MOV     93E,W3
182A:  ADD     W3,W4,W5
182C:  PUSH    93E
182E:  POP     19A
1830:  MOV     W5,198
1832:  BRA     1842
.................... 						case 6: { set_compare_time(6, n,(n+POL_PERIOD)); break; } 
1834:  MOV     #186A,W4
1836:  MOV     93E,W3
1838:  ADD     W3,W4,W5
183A:  PUSH    93E
183C:  POP     1A0
183E:  MOV     W5,19E
1840:  BRA     1842
.................... 						default: {};  
.................... 					} 
.................... 				} 
1842:  BRA     18D6
.................... 				else 
.................... 				{ 
.................... 					if(n>TIME_PWM) 
1844:  MOV     93E,W4
1846:  MOV     #30D4,W3
1848:  CP      W3,W4
184A:  BRA     GE,1854
.................... 					{ 
.................... 						n = n-TIME_PWM;  
184C:  MOV     93E,W4
184E:  MOV     #30D4,W3
1850:  SUB     W4,W3,W0
1852:  MOV     W0,93E
.................... 					} 
.................... 					switch(m->canalPwm&0xFF) // для стрелок 
1854:  MOV     936,W0
1856:  MOV     [W0],W5
1858:  MOV     W5,W0
185A:  AND     #FF,W0
185C:  XOR     #3,W0
185E:  BRA     Z,186E
1860:  XOR     #7,W0
1862:  BRA     Z,1888
1864:  XOR     #1,W0
1866:  BRA     Z,18A2
1868:  XOR     #3,W0
186A:  BRA     Z,18BC
186C:  BRA     18D6
.................... 					{ 
.................... 						case 3: { set_compare_time(3,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
186E:  MOV     #30D4,W4
1870:  MOV     93E,W3
1872:  SUB     W4,W3,W5
1874:  MOV     #30D4,W4
1876:  MOV     93E,W3
1878:  SUB     W4,W3,W0
187A:  MOV     #30D4,W4
187C:  SUB     W4,W0,W0
187E:  MOV     #186A,W4
1880:  SUB     W4,W0,W6
1882:  MOV     W5,18E
1884:  MOV     W6,18C
1886:  BRA     18D6
.................... 						case 4: { set_compare_time(4,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
1888:  MOV     #30D4,W4
188A:  MOV     93E,W3
188C:  SUB     W4,W3,W5
188E:  MOV     #30D4,W4
1890:  MOV     93E,W3
1892:  SUB     W4,W3,W0
1894:  MOV     #30D4,W4
1896:  SUB     W4,W0,W0
1898:  MOV     #186A,W4
189A:  SUB     W4,W0,W6
189C:  MOV     W5,194
189E:  MOV     W6,192
18A0:  BRA     18D6
.................... 						case 5: { set_compare_time(5,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
18A2:  MOV     #30D4,W4
18A4:  MOV     93E,W3
18A6:  SUB     W4,W3,W5
18A8:  MOV     #30D4,W4
18AA:  MOV     93E,W3
18AC:  SUB     W4,W3,W0
18AE:  MOV     #30D4,W4
18B0:  SUB     W4,W0,W0
18B2:  MOV     #186A,W4
18B4:  SUB     W4,W0,W6
18B6:  MOV     W5,19A
18B8:  MOV     W6,198
18BA:  BRA     18D6
.................... 						case 6: { set_compare_time(6,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
18BC:  MOV     #30D4,W4
18BE:  MOV     93E,W3
18C0:  SUB     W4,W3,W5
18C2:  MOV     #30D4,W4
18C4:  MOV     93E,W3
18C6:  SUB     W4,W3,W0
18C8:  MOV     #30D4,W4
18CA:  SUB     W4,W0,W0
18CC:  MOV     #186A,W4
18CE:  SUB     W4,W0,W6
18D0:  MOV     W5,1A0
18D2:  MOV     W6,19E
18D4:  BRA     18D6
.................... 						default: {};  
.................... 					} 
.................... 				} 
.................... 				m->oldValAdc = currentData;  // прошлое значения для которого производился расчет Шим 
18D6:  MOV     #8,W0
18D8:  ADD     936,W0
18DA:  MOV     W0,W5
18DC:  MOV     93C,W4
18DE:  MOV     W4,[W5+#0]
.................... 					 
.................... 			} 
18E0:  BRA     1A80
.................... 			else 
.................... 			{ 
.................... 				if(currentData<m->newValue)// направление движения 
18E2:  MOV     #A,W0
18E4:  ADD     936,W0
18E6:  MOV     W0,W4
18E8:  MOV     [W4],W0
18EA:  MOV     93C,W4
18EC:  CP      W4,W0
18EE:  BRA     GE,1A3C
.................... 				{//vverx 
.................... 					error = m->newValue -currentData;// рассогласование			 
18F0:  MOV     #A,W0
18F2:  ADD     936,W0
18F4:  MOV     [W0],W5
18F6:  MOV     93C,W4
18F8:  SUB     W5,W4,W0
18FA:  CALL    B70
18FE:  MOV     W0,940
1900:  MOV     W1,942
.................... 			       	n = ((proSost(m,currentData, error)+ intSost(m,0, error))- difSost(m, error)); // значение ШИМ 
1902:  PUSH    936
1904:  POP     94A
1906:  PUSH    93C
1908:  POP     94C
190A:  PUSH    940
190C:  POP     94E
190E:  PUSH    942
1910:  POP     950
1912:  CALL    160C
1916:  MOV     W0,W5
1918:  CLR.B   950
191A:  PUSH    936
191C:  POP     94E
191E:  PUSH    940
1920:  POP     952
1922:  PUSH    942
1924:  POP     954
1926:  CALL    1638
192A:  ADD     W0,W5,W5
192C:  PUSH    936
192E:  POP     952
1930:  PUSH    940
1932:  POP     954
1934:  PUSH    942
1936:  POP     956
1938:  CALL    1710
193C:  SUB     W5,W0,W0
193E:  MOV     W0,93E
.................... 					if(m->upValue)// двигатели крутятся в разные стороны потому понятие верх и низ для каждого индивидуально 
1940:  MOV     #2,W0
1942:  ADD     936,W0
1944:  MOV.B   [W0],W4L
1946:  BTSS    W4.0
1948:  BRA     19DE
.................... 					{ 
.................... 						if(n>TIME_PWM) 
194A:  MOV     93E,W4
194C:  MOV     #30D4,W3
194E:  CP      W3,W4
1950:  BRA     GE,195A
.................... 						{ 
.................... 							n = n-TIME_PWM;  
1952:  MOV     93E,W4
1954:  MOV     #30D4,W3
1956:  SUB     W4,W3,W0
1958:  MOV     W0,93E
.................... 						} 
.................... 						switch(m->canalPwm&0xFF) // для индексов  
195A:  MOV     936,W0
195C:  MOV     [W0],W5
195E:  MOV     W5,W0
1960:  AND     #FF,W0
1962:  XOR     #3,W0
1964:  BRA     Z,1974
1966:  XOR     #7,W0
1968:  BRA     Z,198E
196A:  XOR     #1,W0
196C:  BRA     Z,19A8
196E:  XOR     #3,W0
1970:  BRA     Z,19C2
1972:  BRA     19DC
.................... 						{ 
.................... 							case 3: { set_compare_time(3,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
1974:  MOV     #30D4,W4
1976:  MOV     93E,W3
1978:  SUB     W4,W3,W5
197A:  MOV     #30D4,W4
197C:  MOV     93E,W3
197E:  SUB     W4,W3,W0
1980:  MOV     #30D4,W4
1982:  SUB     W4,W0,W0
1984:  MOV     #186A,W4
1986:  SUB     W4,W0,W6
1988:  MOV     W5,18E
198A:  MOV     W6,18C
198C:  BRA     19DC
.................... 							case 4: { set_compare_time(4,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
198E:  MOV     #30D4,W4
1990:  MOV     93E,W3
1992:  SUB     W4,W3,W5
1994:  MOV     #30D4,W4
1996:  MOV     93E,W3
1998:  SUB     W4,W3,W0
199A:  MOV     #30D4,W4
199C:  SUB     W4,W0,W0
199E:  MOV     #186A,W4
19A0:  SUB     W4,W0,W6
19A2:  MOV     W5,194
19A4:  MOV     W6,192
19A6:  BRA     19DC
.................... 							case 5: { set_compare_time(5,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
19A8:  MOV     #30D4,W4
19AA:  MOV     93E,W3
19AC:  SUB     W4,W3,W5
19AE:  MOV     #30D4,W4
19B0:  MOV     93E,W3
19B2:  SUB     W4,W3,W0
19B4:  MOV     #30D4,W4
19B6:  SUB     W4,W0,W0
19B8:  MOV     #186A,W4
19BA:  SUB     W4,W0,W6
19BC:  MOV     W5,19A
19BE:  MOV     W6,198
19C0:  BRA     19DC
.................... 							case 6: { set_compare_time(6,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
19C2:  MOV     #30D4,W4
19C4:  MOV     93E,W3
19C6:  SUB     W4,W3,W5
19C8:  MOV     #30D4,W4
19CA:  MOV     93E,W3
19CC:  SUB     W4,W3,W0
19CE:  MOV     #30D4,W4
19D0:  SUB     W4,W0,W0
19D2:  MOV     #186A,W4
19D4:  SUB     W4,W0,W6
19D6:  MOV     W5,1A0
19D8:  MOV     W6,19E
19DA:  BRA     19DC
.................... 							default: {};  
.................... 						} 
.................... 					} 
19DC:  BRA     1A30
.................... 					else 
.................... 					{ 
.................... 		 
.................... 						switch(m->canalPwm&0xFF)// для стрелок 
19DE:  MOV     936,W0
19E0:  MOV     [W0],W5
19E2:  MOV     W5,W0
19E4:  AND     #FF,W0
19E6:  XOR     #3,W0
19E8:  BRA     Z,19F8
19EA:  XOR     #7,W0
19EC:  BRA     Z,1A06
19EE:  XOR     #1,W0
19F0:  BRA     Z,1A14
19F2:  XOR     #3,W0
19F4:  BRA     Z,1A22
19F6:  BRA     1A30
.................... 						{ 
.................... 							case 3: { set_compare_time(3, n,(n+POL_PERIOD)); break; } 
19F8:  MOV     #186A,W4
19FA:  MOV     93E,W3
19FC:  ADD     W3,W4,W5
19FE:  PUSH    93E
1A00:  POP     18E
1A02:  MOV     W5,18C
1A04:  BRA     1A30
.................... 							case 4: { set_compare_time(4, n,(n+POL_PERIOD)); break; } 
1A06:  MOV     #186A,W4
1A08:  MOV     93E,W3
1A0A:  ADD     W3,W4,W5
1A0C:  PUSH    93E
1A0E:  POP     194
1A10:  MOV     W5,192
1A12:  BRA     1A30
.................... 							case 5: { set_compare_time(5, n,(n+POL_PERIOD)); break; } 
1A14:  MOV     #186A,W4
1A16:  MOV     93E,W3
1A18:  ADD     W3,W4,W5
1A1A:  PUSH    93E
1A1C:  POP     19A
1A1E:  MOV     W5,198
1A20:  BRA     1A30
.................... 							case 6: { set_compare_time(6, n,(n+POL_PERIOD)); break; } 
1A22:  MOV     #186A,W4
1A24:  MOV     93E,W3
1A26:  ADD     W3,W4,W5
1A28:  PUSH    93E
1A2A:  POP     1A0
1A2C:  MOV     W5,19E
1A2E:  BRA     1A30
.................... 							default: {};  
.................... 						} 
.................... 						 
.................... 					} 
.................... 					m->oldValAdc = currentData;  // прошлое значения для которого производился расчет Шим 
1A30:  MOV     #8,W0
1A32:  ADD     936,W0
1A34:  MOV     W0,W5
1A36:  MOV     93C,W4
1A38:  MOV     W4,[W5+#0]
.................... 								 
.................... 				} 
1A3A:  BRA     1A80
.................... 				else // двигатель стоит в заданной позиции, движение не требуется 
.................... 				{ 
.................... 					switch(m->canalPwm&0xFF) 
1A3C:  MOV     936,W0
1A3E:  MOV     [W0],W5
1A40:  MOV     W5,W0
1A42:  AND     #FF,W0
1A44:  XOR     #3,W0
1A46:  BRA     Z,1A56
1A48:  XOR     #7,W0
1A4A:  BRA     Z,1A5E
1A4C:  XOR     #1,W0
1A4E:  BRA     Z,1A66
1A50:  XOR     #3,W0
1A52:  BRA     Z,1A6E
1A54:  BRA     1A76
.................... 					{ 
.................... 						case 3: { set_compare_time(3,0,POL_PERIOD); break; } 
1A56:  CLR     18E
1A58:  MOV     #186A,W4
1A5A:  MOV     W4,18C
1A5C:  BRA     1A76
.................... 						case 4: { set_compare_time(4,0,POL_PERIOD); break; } 
1A5E:  CLR     194
1A60:  MOV     #186A,W4
1A62:  MOV     W4,192
1A64:  BRA     1A76
.................... 						case 5: { set_compare_time(5,0,POL_PERIOD); break; } 
1A66:  CLR     19A
1A68:  MOV     #186A,W4
1A6A:  MOV     W4,198
1A6C:  BRA     1A76
.................... 						case 6: { set_compare_time(6,0,POL_PERIOD); break; } 
1A6E:  CLR     1A0
1A70:  MOV     #186A,W4
1A72:  MOV     W4,19E
1A74:  BRA     1A76
.................... 						default: {};  
.................... 					} 
.................... 					m->oldValAdc = currentData;  // прошлое значения для которого производился расчет Шим		 
1A76:  MOV     #8,W0
1A78:  ADD     936,W0
1A7A:  MOV     W0,W5
1A7C:  MOV     93C,W4
1A7E:  MOV     W4,[W5+#0]
.................... 				} 
.................... 			} 
....................  
.................... 		} 
.................... 			 
.................... 	} 
1A80:  MOV     [--W15],W8
1A82:  MOV     [--W15],W7
1A84:  MOV     [--W15],W6
1A86:  MOV     [--W15],W5
1A88:  RETURN  
.................... 	 
.................... } 
....................  
.................... void setMaxAccel(Motor *m, int16 data) 
*
0AC0:  MOV     W5,[W15++]
.................... { 
.................... 	m->maxAccel = data;  
0AC2:  MOV     #22,W0
0AC4:  ADD     93E,W0
0AC6:  MOV     W0,W5
0AC8:  MOV     940,W4
0ACA:  MOV     W4,[W5+#0]
0ACC:  MOV     [--W15],W5
0ACE:  RETURN  
.................... } 
....................  
....................  
.................... #include "ioPin.c" 
.................... #include "ioPin.h" 
.................... #ifndef IOPIN_H 
.................... #define IOPIN_H 
....................  
.................... #define STATE_OUT PIN_D8 
....................  
.................... int1 getStateOutError();  
....................  
.................... #endif  
....................  
....................  
.................... int1 getStateOutError() 
*
0A94:  BCLR.B  934.0
.................... { 
.................... 	int1 b = 0;   
.................... 	if(!input(STATE_OUT)) 
0A96:  BSET.B  2D3.0
0A98:  BTSC.B  2D5.0
0A9A:  BRA     A9E
.................... 	{ 
.................... 		b = 1;  
0A9C:  BSET.B  934.0
.................... 	} 
.................... 	return b;  
0A9E:  CLR     W0
0AA0:  BTSC.B  934.0
0AA2:  INC     W0,W0
0AA4:  RETURN  
.................... } 
....................  
....................  
....................  
.................... void obmenRS();  
....................  
....................  
....................  
....................  
.................... void main() 
*
1AFA:  MOV     #2780,W15
1AFC:  MOV     #27FF,W0
1AFE:  MOV     W0,20
1B00:  NOP     
1B02:  MOV     #4444,W0
1B04:  MOV     W0,A8
1B06:  MOV     #4444,W0
1B08:  MOV     W0,B0
1B0A:  BSET.B  81.7
1B0C:  MOV     #800,W0
1B0E:  MOV     #FFE,W1
1B10:  REPEAT  W1
1B12:  CLR     [W0++]
1B14:  BCLR.B  2DE.6
1B16:  BCLR.B  2E2.6
1B18:  CLR     800
1B1A:  MOV     #8000,W4
1B1C:  MOV     W4,220
1B1E:  MOV     #400,W4
1B20:  MOV     W4,222
1B22:  MOV     #15,W4
1B24:  MOV     W4,228
1B26:  CLR.B   802
1B28:  BCLR.B  803.0
1B2A:  BCLR.B  803.1
1B2C:  BCLR.B  803.2
1B2E:  BCLR.B  803.3
1B30:  BCLR.B  803.4
1B32:  CLR     804
1B34:  CLR     806
1B36:  CLR     808
1B38:  CLR     80A
1B3A:  CLR     80C
1B3C:  CLR     80E
1B3E:  CLR     810
1B40:  CLR     812
1B42:  CLR     814
1B44:  CLR     816
1B46:  CLR     818
1B48:  CLR     81A
1B4A:  CLR     83C
1B4C:  CLR     83E
1B4E:  CLR     840
1B50:  CLR     842
1B52:  CLR     844
1B54:  CLR     846
1B56:  CLR     848
1B58:  CLR     84A
1B5A:  CLR.B   84C
1B5C:  CLR     84E
1B5E:  CLR     850
1B60:  CLR     852
1B62:  BCLR.B  803.5
1B64:  BCLR.B  803.6
1B66:  CLR     854
1B68:  CLR     856
1B6A:  BCLR.B  803.7
1B6C:  CLR     918
1B6E:  CLR     91A
1B70:  CLR     91C
1B72:  CLR     91E
1B74:  CLR.B   84D
1B76:  CLR.B   920
1B78:  CLR     922
1B7A:  BCLR.B  921.0
1B7C:  CLR     924
1B7E:  BCLR.B  921.1
1B80:  MOV     #2F,W4
1B82:  MOV     W4,930
1B84:  BCLR.B  921.2
1B86:  CLR     932
1B88:  SETM    32C
1B8A:  SETM    32A
1B8C:  CLR     81C
1B8E:  CLR     81E
1B90:  CLR     820
1B92:  CLR     822
1B94:  CLR     824
1B96:  CLR     826
1B98:  CLR     828
1B9A:  CLR     82A
1B9C:  CLR     82C
1B9E:  CLR     82E
1BA0:  CLR     830
1BA2:  CLR     832
1BA4:  CLR     834
1BA6:  CLR     836
1BA8:  CLR     838
1BAA:  CLR     83A
1BAC:  CLR     926
1BAE:  CLR     928
1BB0:  CLR     92A
1BB2:  CLR     92C
1BB4:  CLR     92E
.................... { 
.................... 	init_PLL();  
1BB6:  CALL    77A
.................... 	initRS();  
1BBA:  CALL    79C
.................... 	adress = ADRES1;  
1BBE:  MOV.B   #85,W0L
1BC0:  MOV.B   W0L,802
.................... 	initDMA();  
1BC2:  CALL    7B4
.................... 	crc = getChecksum();  
1BC6:  CALL    7FA
1BCA:  MOV     W0,932
.................... 	initLed();  
1BCC:  CALL    844
.................... 	initADC();  
1BD0:  CALL    898
.................... 	initPWM();  
1BD4:  CALL    9D2
.................... 	 
.................... 	enable_interrupts(INTR_GLOBAL); 		 
1BD8:  BCLR.B  81.7
1BDA:  CLR     42
1BDC:  BSET.B  81.7
.................... 	onOffPWMCanal(0x01);  
1BDE:  MOV.B   #1,W0L
1BE0:  MOV.B   W0L,942
1BE2:  CALL    8E4
.................... 	startAvtomatCalibr();  
1BE6:  CALL    A84
.................... 	 
....................  
....................   
.................... 	 
.................... 	while(TRUE) 
.................... 	{ 
.................... 		// отключение силовой части в случае замыкания 
.................... 		if(getStateOutError()) 
1BEA:  CALL    A94
1BEE:  CP0.B   W0L
1BF0:  BRA     Z,1BF8
.................... 		{ 
.................... 			onOffPWMCanal(0x00);  
1BF2:  CLR.B   942
1BF4:  CALL    8E4
.................... 		} 
.................... 		readDmaAdc();  
1BF8:  CALL    24C
.................... 		obmenRS();  
1BFC:  CALL    F6A
.................... 		sendDataCalibr();  
1C00:  CALL    147C
.................... 	//	sendState(); 
.................... 	//	testPoAdc(canalPwm, dataCanal3);  
.................... 	//	if(dmaAdcFlag) 
.................... 		{ 
.................... 			rotate(); 
1C04:  CALL    1A8A
.................... 	//		dmaAdcFlag = 0; 	  
.................... 		}	 
1C08:  BRA     1BEA
.................... 			//rotate(); 	 
.................... 		 
....................  
.................... 	} 
....................  
....................  
.................... } 
....................  
1C0A:  PWRSAV  #0
.................... void obmenRS() 
*
0F6A:  MOV     W5,[W15++]
0F6C:  MOV     #C,W5
0F6E:  REPEAT  #3
0F70:  MOV     [W5++],[W15++]
.................... { 
.................... 	if(FLAG) 
0F72:  BTSS.B  921.1
0F74:  BRA     13C6
.................... 	{ 
.................... 		if(buffer[0] == adress) 
0F76:  MOV.B   926,W0L
0F78:  CP.B    802
0F7A:  BRA     NZ,13A6
.................... 		{			 	 
.................... 			switch(buffer[1]) 
0F7C:  MOV.B   927,W0L
0F7E:  SE      W0,W0
0F80:  XOR     #19,W0
0F82:  BRA     Z,FCA
0F84:  XOR     #F,W0
0F86:  BRA     Z,FF6
0F88:  XOR     #1,W0
0F8A:  BRA     Z,1042
0F8C:  XOR     #2,W0
0F8E:  BRA     Z,10AE
0F90:  XOR     #1,W0
0F92:  BRA     Z,10FA
0F94:  XOR     #7,W0
0F96:  BRA     Z,1168
0F98:  XOR     #1,W0
0F9A:  BRA     Z,1180
0F9C:  XOR     #3,W0
0F9E:  BRA     Z,11A4
0FA0:  XOR     #51,W0
0FA2:  BRA     Z,11D8
0FA4:  XOR     #71,W0
0FA6:  BRA     Z,1234
0FA8:  XOR     #B,W0
0FAA:  BRA     Z,1258
0FAC:  XOR     #8,W0
0FAE:  BRA     Z,127C
0FB0:  XOR     #73,W0
0FB2:  BRA     Z,12A0
0FB4:  XOR     #3,W0
0FB6:  BRA     Z,12C4
0FB8:  XOR     #5,W0
0FBA:  BRA     Z,12E8
0FBC:  XOR     #F,W0
0FBE:  BRA     Z,12FC
0FC0:  XOR     #E,W0
0FC2:  BRA     Z,130C
0FC4:  XOR     #13,W0
0FC6:  BRA     Z,131C
0FC8:  BRA     137E
.................... 			{	 
.................... 					case 0x19:  
.................... 					{ 
.................... 						int8 outData = 0;  
0FCA:  CLR.B   934
.................... 						if(input(PIN_D8)) 
0FCC:  BSET.B  2D3.0
0FCE:  BTSS.B  2D5.0
0FD0:  BRA     FDA
.................... 						{outData |= 0x01; } 
0FD2:  MOV.B   934,W0L
0FD4:  SE      W0,W0
0FD6:  BSET    W0.0
0FD8:  MOV.B   W0L,934
.................... 						  
.................... 						sendRS(adress);  
0FDA:  MOV.B   802,W0L
0FDC:  MOV.B   W0L,93E
0FDE:  CALL    AA6
.................... 						sendRS(0x19);  
0FE2:  MOV.B   #19,W0L
0FE4:  MOV.B   W0L,93E
0FE6:  CALL    AA6
.................... 						sendRS(outData);  
0FEA:  MOV.B   934,W0L
0FEC:  MOV.B   W0L,93E
0FEE:  CALL    AA6
.................... 						indW = 0;  
0FF2:  CLR     924
.................... 						break;  
0FF4:  BRA     139C
.................... 						 
.................... 					}	 
.................... 					case 0x16:  
.................... 					{ 
.................... 						int16 data = make16(buffer[2], buffer[3]);  
0FF6:  MOV.B   929,W0L
0FF8:  MOV.B   W0L,936
0FFA:  MOV.B   928,W0L
0FFC:  MOV.B   W0L,937
.................... 						setMaxAccel(&m3, data);  
0FFE:  MOV     #858,W4
1000:  MOV     W4,93E
1002:  PUSH    936
1004:  POP     940
1006:  CALL    AC0
.................... 						setMaxAccel(&m4, data); 
100A:  MOV     #888,W4
100C:  MOV     W4,93E
100E:  PUSH    936
1010:  POP     940
1012:  CALL    AC0
.................... 						setMaxAccel(&m5, data); 
1016:  MOV     #8B8,W4
1018:  MOV     W4,93E
101A:  PUSH    936
101C:  POP     940
101E:  CALL    AC0
.................... 						setMaxAccel(&m6, data); 
1022:  MOV     #8E8,W4
1024:  MOV     W4,93E
1026:  PUSH    936
1028:  POP     940
102A:  CALL    AC0
.................... 						indW = 0;  
102E:  CLR     924
.................... 					 
.................... 						sendRS(adress);  
1030:  MOV.B   802,W0L
1032:  MOV.B   W0L,93E
1034:  CALL    AA6
.................... 						sendRS(0x16);  
1038:  MOV.B   #16,W0L
103A:  MOV.B   W0L,93E
103C:  CALL    AA6
.................... 						break;  
1040:  BRA     139C
.................... 	 
.................... 					}  
.................... 					case 0x17:  
.................... 					{ 
.................... 						int16 data = make16(buffer[3], buffer[4]); 
1042:  MOV.B   92A,W0L
1044:  MOV.B   W0L,938
1046:  MOV.B   929,W0L
1048:  MOV.B   W0L,939
.................... 						switch(buffer[2]&0xFF)  
104A:  MOV.B   928,W0L
104C:  SE      W0,W0
104E:  AND     #FF,W0
1050:  XOR     #3,W0
1052:  BRA     Z,1062
1054:  XOR     #7,W0
1056:  BRA     Z,1070
1058:  XOR     #1,W0
105A:  BRA     Z,107E
105C:  XOR     #3,W0
105E:  BRA     Z,108C
1060:  BRA     109A
.................... 						{ 
.................... 							case 3: {setMinSpeed(&m3, data);  break;} 
1062:  MOV     #858,W4
1064:  MOV     W4,93E
1066:  PUSH    938
1068:  POP     940
106A:  CALL    AD0
106E:  BRA     109A
.................... 							case 4: {setMinSpeed(&m4, data); break;} 
1070:  MOV     #888,W4
1072:  MOV     W4,93E
1074:  PUSH    938
1076:  POP     940
1078:  CALL    AD0
107C:  BRA     109A
.................... 							case 5: {setMinSpeed(&m5, data); break;} 
107E:  MOV     #8B8,W4
1080:  MOV     W4,93E
1082:  PUSH    938
1084:  POP     940
1086:  CALL    AD0
108A:  BRA     109A
.................... 							case 6: {setMinSpeed(&m6, data); break;} 
108C:  MOV     #8E8,W4
108E:  MOV     W4,93E
1090:  PUSH    938
1092:  POP     940
1094:  CALL    AD0
1098:  BRA     109A
.................... 						}				 
.................... 						 
.................... 						 
.................... 					 
.................... 					 
.................... 						indW = 0;  
109A:  CLR     924
.................... 					 
.................... 						sendRS(adress);  
109C:  MOV.B   802,W0L
109E:  MOV.B   W0L,93E
10A0:  CALL    AA6
.................... 						sendRS(0x17);  
10A4:  MOV.B   #17,W0L
10A6:  MOV.B   W0L,93E
10A8:  CALL    AA6
.................... 						break;  
10AC:  BRA     139C
.................... 	 
.................... 					}  
.................... 					case 0x15:  
.................... 					{ 
.................... 						int16 data = make16(buffer[2], buffer[3]);  
10AE:  MOV.B   929,W0L
10B0:  MOV.B   W0L,93A
10B2:  MOV.B   928,W0L
10B4:  MOV.B   W0L,93B
.................... 						setMaxSpeed(&m3, data);  
10B6:  MOV     #858,W4
10B8:  MOV     W4,93E
10BA:  PUSH    93A
10BC:  POP     940
10BE:  CALL    D0E
.................... 						setMaxSpeed(&m4, data); 
10C2:  MOV     #888,W4
10C4:  MOV     W4,93E
10C6:  PUSH    93A
10C8:  POP     940
10CA:  CALL    D0E
.................... 						setMaxSpeed(&m5, data); 
10CE:  MOV     #8B8,W4
10D0:  MOV     W4,93E
10D2:  PUSH    93A
10D4:  POP     940
10D6:  CALL    D0E
.................... 						setMaxSpeed(&m6, data); 
10DA:  MOV     #8E8,W4
10DC:  MOV     W4,93E
10DE:  PUSH    93A
10E0:  POP     940
10E2:  CALL    D0E
.................... 						indW = 0;  
10E6:  CLR     924
.................... 					 
.................... 						sendRS(adress);  
10E8:  MOV.B   802,W0L
10EA:  MOV.B   W0L,93E
10EC:  CALL    AA6
.................... 						sendRS(0x15);  
10F0:  MOV.B   #15,W0L
10F2:  MOV.B   W0L,93E
10F4:  CALL    AA6
.................... 						break;  
10F8:  BRA     139C
.................... 	 
.................... 					}  
.................... 					case 0x14:  
.................... 					{ 
.................... 						enabRegul = buffer[2]&0x01;  
10FA:  MOV.B   928,W0L
10FC:  SE      W0,W0
10FE:  AND     W0,#1,W0
1100:  BCLR.B  921.0
1102:  BTSC.B  0.0
1104:  BSET.B  921.0
.................... 						canalPwm = (buffer[3]&0xFF);  
1106:  MOV.B   929,W0L
1108:  SE      W0,W0
110A:  AND     #FF,W0
110C:  MOV.B   W0L,920
.................... 						dataCanal3 = make16(buffer[4], buffer[5]);  
110E:  MOV.B   92B,W0L
1110:  MOV.B   W0L,922
1112:  MOV.B   92A,W0L
1114:  MOV.B   W0L,923
.................... 						switch(canalPwm) 
1116:  MOV.B   920,W0L
1118:  SE      W0,W0
111A:  XOR     #3,W0
111C:  BRA     Z,112C
111E:  XOR     #7,W0
1120:  BRA     Z,1132
1122:  XOR     #1,W0
1124:  BRA     Z,1138
1126:  XOR     #3,W0
1128:  BRA     Z,113E
112A:  BRA     1144
.................... 						{ 
.................... 							case 3: {newValueM3 = dataCanal3; break; } 
112C:  PUSH    922
112E:  POP     918
1130:  BRA     1154
.................... 							case 4: {newValueM4 = dataCanal3; break; } 
1132:  PUSH    922
1134:  POP     91A
1136:  BRA     1154
.................... 							case 5: {newValueM5 = dataCanal3; break; } 
1138:  PUSH    922
113A:  POP     91C
113C:  BRA     1154
.................... 							case 6: {newValueM6 = dataCanal3; break; } 
113E:  PUSH    922
1140:  POP     91E
1142:  BRA     1154
.................... 							default: {newValueM3 = dataCanal3;  
1144:  PUSH    922
1146:  POP     918
.................... 									  newValueM4 = dataCanal3;  
1148:  PUSH    922
114A:  POP     91A
.................... 									  newValueM5 = dataCanal3;  
114C:  PUSH    922
114E:  POP     91C
.................... 									  newValueM6 = dataCanal3; }  
1150:  PUSH    922
1152:  POP     91E
.................... 						} 
.................... 						sendRS(adress);  
1154:  MOV.B   802,W0L
1156:  MOV.B   W0L,93E
1158:  CALL    AA6
.................... 						sendRS(0x14); 
115C:  MOV.B   #14,W0L
115E:  MOV.B   W0L,93E
1160:  CALL    AA6
.................... 						indW = 0;   
1164:  CLR     924
.................... 						break;  
1166:  BRA     139C
.................... 					} 
.................... 					case 0x13:  
.................... 					{ 
.................... 						//setLimitAdcMotor(&m3, minAdc1, maxAdc1); 
.................... 						sendRS(adress);  
1168:  MOV.B   802,W0L
116A:  MOV.B   W0L,93E
116C:  CALL    AA6
.................... 						sendRS(0x13);  
1170:  MOV.B   #13,W0L
1172:  MOV.B   W0L,93E
1174:  CALL    AA6
.................... 						startAvtomatCalibr();  
1178:  CALL    A84
.................... 					//	sendRS16(m3->newValue); 
.................... 					 
.................... 							 
.................... 						//startAvtomatCalibr();  
.................... 					/*	sendRS(adress);  
.................... 						sendRS(0x13); 
.................... 						sendRS16(minADC1); 
.................... 						sendRS16(minADC2); 
.................... 						sendRS16(minADC3); 
.................... 						sendRS16(minADC4); 
.................... 						sendRS16(maxADC1); 
.................... 						sendRS16(maxADC2); 
.................... 						sendRS16(maxADC3); 
.................... 						sendRS16(maxADC4);*/	 
.................... 						indW = 0;   
117C:  CLR     924
.................... 						break; 
117E:  BRA     139C
....................  
.................... 					} 
.................... 					case 0x12:  
.................... 					{ 
.................... 						onOffPWMCanal(buffer[2]&0x01);  
1180:  MOV.B   928,W0L
1182:  SE      W0,W0
1184:  AND     W0,#1,W5
1186:  PUSH    942
1188:  MOV.B   W5L,[W15-#2]
118A:  POP     942
118C:  CALL    8E4
.................... 						sendRS(adress);  
1190:  MOV.B   802,W0L
1192:  MOV.B   W0L,93E
1194:  CALL    AA6
.................... 						sendRS(0x12); 
1198:  MOV.B   #12,W0L
119A:  MOV.B   W0L,93E
119C:  CALL    AA6
.................... 						indW = 0;   
11A0:  CLR     924
.................... 						break;  
11A2:  BRA     139C
.................... 					} 
.................... 					case 0x11: 
.................... 					{ 
.................... 						sendRS(adress);  
11A4:  MOV.B   802,W0L
11A6:  MOV.B   W0L,93E
11A8:  CALL    AA6
.................... 						sendRS(0x11);  
11AC:  MOV.B   #11,W0L
11AE:  MOV.B   W0L,93E
11B0:  CALL    AA6
.................... 						sendRS16(valAdc1);  
11B4:  PUSH    804
11B6:  POP     93E
11B8:  CALL    D3E
.................... 						sendRS16(valAdc2);  
11BC:  PUSH    806
11BE:  POP     93E
11C0:  CALL    D3E
.................... 						sendRS16(valAdc3);  
11C4:  PUSH    808
11C6:  POP     93E
11C8:  CALL    D3E
.................... 						sendRS16(valAdc4);  
11CC:  PUSH    80A
11CE:  POP     93E
11D0:  CALL    D3E
.................... 						indW = 0;  
11D4:  CLR     924
.................... 						break; 
11D6:  BRA     139C
.................... 					} 
.................... 					case COM_SET_ALL_UI:  
.................... 					{ 
.................... 						if(indW>=6) 
11D8:  MOV     924,W4
11DA:  CP      W4,#6
11DC:  BRA     LT,1232
.................... 						{ 
.................... 							//change   uStr	uInd	Pstr		Pind	UPblenk 
.................... 						//	setPwm((buffer[2]&0xFF), (buffer[3]&0xFF), (buffer[4]&0xFF),(buffer[5]&0xFF), (buffer[6]&0xFF));  
.................... 											//uStr	uInd	Pstr		Pind	UPblenk 
.................... 							ansComSetAllUi((buffer[2]&0xFF), (buffer[3]&0xFF), (buffer[4]&0xFF),(buffer[5]&0xFF), (buffer[6]&0xFF));  
11DE:  MOV.B   928,W0L
11E0:  SE      W0,W0
11E2:  MOV     W0,W5
11E4:  AND     #FF,W5
11E6:  MOV.B   929,W0L
11E8:  SE      W0,W0
11EA:  MOV     W0,W6
11EC:  AND     #FF,W6
11EE:  MOV.B   92A,W0L
11F0:  SE      W0,W0
11F2:  MOV     W0,W7
11F4:  AND     #FF,W7
11F6:  MOV.B   92B,W0L
11F8:  SE      W0,W0
11FA:  MOV     W0,W8
11FC:  AND     #FF,W8
11FE:  MOV.B   92C,W0L
1200:  SE      W0,W0
1202:  MOV     W0,W9
1204:  AND     #FF,W9
1206:  PUSH    94A
1208:  MOV.B   W5L,[W15-#2]
120A:  POP     94A
120C:  PUSH    94A
120E:  MOV.B   W6L,[W15-#1]
1210:  POP     94A
1212:  PUSH    94C
1214:  MOV.B   W7L,[W15-#2]
1216:  POP     94C
1218:  PUSH    94C
121A:  MOV.B   W8L,[W15-#1]
121C:  POP     94C
121E:  PUSH    94E
1220:  MOV.B   W9L,[W15-#2]
1222:  POP     94E
1224:  CALL    D8C
.................... 							runVD(LED_GREEN);   
1228:  MOV     #AAAA,W4
122A:  MOV     W4,93E
122C:  CALL    822
.................... 							indW = 0; 
1230:  CLR     924
.................... 						} 
.................... 						break;  
1232:  BRA     139C
.................... 					}  
.................... 					case COM_SET_UGOL_STR: 
.................... 					{ 
.................... 						if(indW>=3)// проверка на полный буффер 
1234:  MOV     924,W4
1236:  CP      W4,#3
1238:  BRA     LT,1256
.................... 						{ 
.................... 							//change 
.................... 						//	setUstr(buffer[2]&0xFF);  
.................... 							ansComSetUgolStr(buffer[2]&0xFF); 
123A:  MOV.B   928,W0L
123C:  SE      W0,W0
123E:  MOV     W0,W5
1240:  AND     #FF,W5
1242:  PUSH    942
1244:  MOV.B   W5L,[W15-#2]
1246:  POP     942
1248:  CALL    DCC
.................... 							runVD(LED_GREEN); 
124C:  MOV     #AAAA,W4
124E:  MOV     W4,93E
1250:  CALL    822
.................... 							indW = 0;  
1254:  CLR     924
.................... 						} 
.................... 						break;  
1256:  BRA     139C
.................... 					} 
.................... 				 
.................... 				 
.................... 					case COM_SET_UGOL_IND: 
.................... 					{ 
.................... 						if(indW>=3)// проверка на полный буффер 
1258:  MOV     924,W4
125A:  CP      W4,#3
125C:  BRA     LT,127A
.................... 						{ 
.................... 							//change 
.................... 					//		setUind(buffer[2]&0xFF);  
.................... 							ansComSetUgolInd(buffer[2]&0xFF); 
125E:  MOV.B   928,W0L
1260:  SE      W0,W0
1262:  MOV     W0,W5
1264:  AND     #FF,W5
1266:  PUSH    942
1268:  MOV.B   W5L,[W15-#2]
126A:  POP     942
126C:  CALL    DEC
.................... 							runVD(LED_GREEN); 
1270:  MOV     #AAAA,W4
1272:  MOV     W4,93E
1274:  CALL    822
.................... 							indW = 0;  
1278:  CLR     924
.................... 						} 
.................... 						break; 
127A:  BRA     139C
.................... 					} 
....................  
.................... 					case COM_SET_PRG_STR: 
.................... 					{ 
.................... 						if(indW>=3)// проверка на полный буффер 
127C:  MOV     924,W4
127E:  CP      W4,#3
1280:  BRA     LT,129E
.................... 						{ 
.................... 							//change 
.................... 						//	setPstr(buffer[2]&0xFF);  
.................... 							ansComSetPrgStr(buffer[2]&0xFF); 
1282:  MOV.B   928,W0L
1284:  SE      W0,W0
1286:  MOV     W0,W5
1288:  AND     #FF,W5
128A:  PUSH    942
128C:  MOV.B   W5L,[W15-#2]
128E:  POP     942
1290:  CALL    E0C
.................... 							runVD(LED_GREEN); 
1294:  MOV     #AAAA,W4
1296:  MOV     W4,93E
1298:  CALL    822
.................... 							indW = 0;  
129C:  CLR     924
.................... 						} 
.................... 						break; 
129E:  BRA     139C
.................... 					} 
....................  
.................... 					case COM_SET_PRG_IND: 
.................... 					{ 
.................... 						if(indW>=3)// проверка на полный буффер 
12A0:  MOV     924,W4
12A2:  CP      W4,#3
12A4:  BRA     LT,12C2
.................... 						{ 
.................... 							//change 
.................... 						//	setPind(buffer[2]&0xFF);  
.................... 							ansComSetPrgInd(buffer[2]&0xFF); 
12A6:  MOV.B   928,W0L
12A8:  SE      W0,W0
12AA:  MOV     W0,W5
12AC:  AND     #FF,W5
12AE:  PUSH    942
12B0:  MOV.B   W5L,[W15-#2]
12B2:  POP     942
12B4:  CALL    E2C
.................... 							runVD(LED_GREEN); 
12B8:  MOV     #AAAA,W4
12BA:  MOV     W4,93E
12BC:  CALL    822
.................... 							indW = 0;  
12C0:  CLR     924
.................... 						} 
.................... 						break; 
12C2:  BRA     139C
.................... 					} 
....................  
.................... 					case COM_SET_UP_BLN: 
.................... 					{ 
.................... 						if(indW>=3)// проверка на полный буффер 
12C4:  MOV     924,W4
12C6:  CP      W4,#3
12C8:  BRA     LT,12E6
.................... 						{ 
.................... 							//change 
.................... 						//	setUPbln(buffer[2]&0xFF);  
.................... 							ansComSetUPbln(buffer[2]&0xFF); 
12CA:  MOV.B   928,W0L
12CC:  SE      W0,W0
12CE:  MOV     W0,W5
12D0:  AND     #FF,W5
12D2:  PUSH    942
12D4:  MOV.B   W5L,[W15-#2]
12D6:  POP     942
12D8:  CALL    E4C
.................... 							runVD(LED_GREEN); 
12DC:  MOV     #AAAA,W4
12DE:  MOV     W4,93E
12E0:  CALL    822
.................... 							indW = 0;  
12E4:  CLR     924
.................... 						} 
.................... 						break; 
12E6:  BRA     139C
.................... 					} 
.................... 				//**************************************** 
.................... 				// CRC 
.................... 				case COM_READ_CRC: 
.................... 				{ 
.................... 						ansReadCrc(crc); 
12E8:  PUSH    932
12EA:  POP     93E
12EC:  CALL    E6C
.................... 						runVD(LED_GREEN); 
12F0:  MOV     #AAAA,W4
12F2:  MOV     W4,93E
12F4:  CALL    822
.................... 						indW = 0; 
12F8:  CLR     924
.................... 					 
.................... 					break;  
12FA:  BRA     139C
.................... 				} 
.................... 				case COM_INFO: 
.................... 				{ 
.................... 						ansComInfo(); 
12FC:  CALL    EA0
.................... 						runVD(LED_GREEN); 
1300:  MOV     #AAAA,W4
1302:  MOV     W4,93E
1304:  CALL    822
.................... 						indW = 0; 
1308:  CLR     924
.................... 					 
.................... 					break;  
130A:  BRA     139C
.................... 				} 
.................... 				case COM_READ_ID: 
.................... 				{ 
.................... 						ansComId(); 
130C:  CALL    EFE
.................... 						runVD(LED_GREEN); 
1310:  MOV     #AAAA,W4
1312:  MOV     W4,93E
1314:  CALL    822
.................... 						indW = 0; 
1318:  CLR     924
.................... 					 
.................... 					break;  
131A:  BRA     139C
.................... 				} 
.................... 				case COM_RESET_MK: 
.................... 				{ 
.................... 					int d = (buffer[2]&0xFF);  
131C:  MOV.B   928,W0L
131E:  SE      W0,W0
1320:  MOV     W0,W4
1322:  AND     #FF,W4
1324:  MOV     W4,93C
.................... 					switch (d) 
1326:  MOV     93C,W0
1328:  XOR     #AA,W0
132A:  BRA     Z,132E
132C:  BRA     1354
.................... 					{ 
.................... 						case 0xAA: 
.................... 						{ 
.................... 							sendRS(buffer[0]);  
132E:  MOV.B   926,W0L
1330:  MOV.B   W0L,93E
1332:  CALL    AA6
.................... 							sendRS(buffer[1]); 
1336:  MOV.B   927,W0L
1338:  MOV.B   W0L,93E
133A:  CALL    AA6
.................... 							sendRS(buffer[2]); 
133E:  MOV.B   928,W0L
1340:  MOV.B   W0L,93E
1342:  CALL    AA6
.................... 							runVD(LED_GREEN);  
1346:  MOV     #AAAA,W4
1348:  MOV     W4,93E
134A:  CALL    822
.................... 							reset_cpu();  
134E:  RESET   
.................... 							indW=0; 
1350:  CLR     924
.................... 							break;  
1352:  BRA     137A
.................... 						} 
.................... 						default:  
.................... 						{ 
.................... 							ansComRst(((~buffer[1])&0xFF), buffer[2]);  
1354:  COM.B   0927,W0L
1356:  CLR.B   1
1358:  MOV.B   W0L,W5L
135A:  AND     #FF,W5
135C:  PUSH    942
135E:  MOV.B   W5L,[W15-#2]
1360:  POP     942
1362:  MOV     W0,[W15++]
1364:  MOV.B   928,W0L
1366:  MOV.B   W0L,943
1368:  MOV     [--W15],W0
136A:  CALL    F36
.................... 							runVD(LED_RED); 
136E:  MOV     #5555,W4
1370:  MOV     W4,93E
1372:  CALL    822
.................... 							indW=0;  
1376:  CLR     924
.................... 							break;  
1378:  BRA     137A
.................... 						 
....................  
.................... 						}  
.................... 					} 
.................... 					indW = 0; 
137A:  CLR     924
.................... 					 
.................... 					break;  
137C:  BRA     139C
.................... 				} 
.................... 				default: 
.................... 				{ 
.................... 					ansErrorCom(buffer[1]&0xFF);  
137E:  MOV.B   927,W0L
1380:  SE      W0,W0
1382:  MOV     W0,W5
1384:  AND     #FF,W5
1386:  PUSH    942
1388:  MOV.B   W5L,[W15-#2]
138A:  POP     942
138C:  CALL    F54
.................... 					runVD(LED_RED); 
1390:  MOV     #5555,W4
1392:  MOV     W4,93E
1394:  CALL    822
.................... 					indW = 0; 
1398:  CLR     924
.................... 				 
.................... 					break; 
139A:  BRA     139C
.................... 				 
.................... 				}  
....................  
.................... 			} 
.................... 			 
.................... 			buffer[0]=0; 
139C:  CLR.B   926
.................... 			buffer[1]=0;  
139E:  CLR.B   927
.................... 			buffer[2]=0; 
13A0:  CLR.B   928
.................... 			indW = 0;  
13A2:  CLR     924
.................... 		} 
13A4:  BRA     13A8
.................... 		else 
.................... 		{ 
.................... 		 
.................... 			indW = 0;  
13A6:  CLR     924
.................... 	 
.................... 		} 
.................... 	 
.................... 	 
.................... 	 
.................... 		 
.................... 		 
.................... 		flag = 0;  
13A8:  BCLR.B  921.1
....................  
.................... 		if(indW>SIZE_RS_BUFFER) 
13AA:  MOV     924,W4
13AC:  CP      W4,#A
13AE:  BRA     LE,13C6
.................... 		{ 
.................... 			indW = 0; 
13B0:  CLR     924
.................... 			buffer[0]=0; 
13B2:  CLR.B   926
.................... 			buffer[1]=0;  
13B4:  CLR.B   927
.................... 			buffer[2]=0; 
13B6:  CLR.B   928
.................... 			buffer[3]=0;  
13B8:  CLR.B   929
.................... 			buffer[4]=0;  
13BA:  CLR.B   92A
.................... 			buffer[5]=0;  
13BC:  CLR.B   92B
.................... 			buffer[6]=0;  
13BE:  CLR.B   92C
.................... 			buffer[7]=0;  
13C0:  CLR.B   92D
.................... 			buffer[8]=0; 
13C2:  CLR.B   92E
.................... 			buffer[9]=0;    
13C4:  CLR.B   92F
.................... 		} 
.................... 	} 
13C6:  MOV     #12,W5
13C8:  REPEAT  #3
13CA:  MOV     [--W15],[W5--]
13CC:  MOV     [--W15],W5
13CE:  RETURN  
....................  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: 0000  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: 0000  
   Word  3L: 0007   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 0083   PR_PLL IESO
          H: 0000  
   Word  5L: 00C6   HS NOOSCIO
          H: 0000  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00E6   PUT64
          H: 0000  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: 0000  

ROM data:
00ABFE: 6C17                                       l.
