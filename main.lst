CCS PCD C Compiler, Version 5.051, 43599               26-апр-16 11:35

               Filename:   F:\work\UAPP\main.lst

               ROM used:   9104 bytes (21%)
                           Largest free fragment is 34928
               RAM used:   479 (6%) at main() level
                           611 (7%) worst case
               Stack used: 86 locations (32 in main + 54 for interrupts)
               Stack size: 128

*
0000:  GOTO    2244
*
000E:  DATA    4A,03,00
*
001C:  DATA    24,03,00
*
002A:  DATA    BC,02,00
*
0044:  DATA    76,02,00
*
004A:  DATA    FC,02,00
004C:  DATA    00,02,00
*
0074:  DATA    8E,06,00
.................... #include "main.h" 
.................... #include "24HJ64GP206.h" 
.................... //////////// Standard Header file for the PIC24HJ64GP206 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24HJ64GP206 
*
07DC:  MOV     W1,32
07DE:  CP0     W3
07E0:  BRA     Z,808
07E2:  BTSC.B  0.0
07E4:  BRA     7F2
07E6:  TBLRDL.B[W0++],[W2++]
07E8:  DEC     W3,W3
07EA:  BRA     Z,808
07EC:  TBLRDL.B[W0],[W2++]
07EE:  DEC     W3,W3
07F0:  BRA     Z,808
07F2:  DEC     W0,W0
07F4:  TBLRDH.B[W0++],[W2++]
07F6:  DEC     W3,W3
07F8:  BRA     Z,808
07FA:  CLR.B   [W2++]
07FC:  DEC     W3,W3
07FE:  INC     W0,W0
0800:  CP0     W0
0802:  BTSC.B  42.1
0804:  INC     0032
0806:  BRA     7DE
0808:  RETURN  
*
0D2E:  MOV     W5,[W15++]
0D30:  MOV     W6,[W15++]
0D32:  MOV     #8E,W1
0D34:  BCLR    W6.0
0D36:  BTSS    W0.F
0D38:  BRA     D40
0D3A:  BSET    W6.0
0D3C:  NEG     W0,W0
0D3E:  BRA     D40
0D40:  CP0     W0
0D42:  BRA     Z,D6C
0D44:  BTSC    W0.F
0D46:  BRA     D50
0D48:  BCLR.B  42.0
0D4A:  RLC     W0,W0
0D4C:  DEC     W1,W1
0D4E:  BRA     D44
0D50:  SWAP    W1
0D52:  BCLR.B  42.0
0D54:  RRC     W1,W1
0D56:  BCLR    W0.F
0D58:  SWAP    W0
0D5A:  XOR.B   W0L,W1L,W1L
0D5C:  AND.B   #0,W0L
0D5E:  BTSC    W6.0
0D60:  BSET    W1.F
0D62:  BRA     D72
0D64:  MOV.B   W1L,W0L
0D66:  BSET    W1.7
0D68:  AND.B   #0,W1L
0D6A:  BRA     D72
0D6C:  CLR     W0
0D6E:  CLR     W1
0D70:  BRA     D72
0D72:  MOV     [--W15],W6
0D74:  MOV     [--W15],W5
0D76:  RETURN  
*
0DC8:  MOV     W5,[W15++]
0DCA:  MOV     W6,[W15++]
0DCC:  MOV     W7,[W15++]
0DCE:  XOR     W1,W3,W4
0DD0:  BTSS    W4.F
0DD2:  BRA     DE0
0DD4:  BCLR.B  42.0
0DD6:  BCLR.B  42.1
0DD8:  BTSS    W1.F
0DDA:  BRA     E28
0DDC:  BSET.B  42.0
0DDE:  BRA     E28
0DE0:  MOV     W1,W4
0DE2:  MOV     W0,W5
0DE4:  MOV     W3,W6
0DE6:  MOV     W2,W7
0DE8:  RLC     W1,W1
0DEA:  SWAP    W1
0DEC:  RLC     W3,W3
0DEE:  SWAP    W3
0DF0:  SUB.B   W3L,W1L,W1L
0DF2:  BRA     Z,DFE
0DF4:  BTSS    W4.F
0DF6:  BRA     E28
0DF8:  MOV     #1,W0
0DFA:  XOR.B   42
0DFC:  BRA     E28
0DFE:  MOV.B   W4L,W1L
0E00:  MOV.B   W6L,W3L
0E02:  BCLR    W1.7
0E04:  BCLR    W3.7
0E06:  SUB.B   W3L,W1L,W1L
0E08:  BRA     Z,E14
0E0A:  BTSS    W4.F
0E0C:  BRA     E28
0E0E:  MOV     #1,W0
0E10:  XOR.B   42
0E12:  BRA     E28
0E14:  SUB     W7,W5,W1
0E16:  BRA     Z,E22
0E18:  BTSS    W4.F
0E1A:  BRA     E28
0E1C:  MOV     #1,W0
0E1E:  XOR.B   42
0E20:  BRA     E28
0E22:  BCLR.B  42.0
0E24:  BRA     E28
0E26:  BRA     E28
0E28:  MOV     [--W15],W7
0E2A:  MOV     [--W15],W6
0E2C:  MOV     [--W15],W5
0E2E:  RETURN  
0E30:  MOV     W5,[W15++]
0E32:  MOV     #C,W5
0E34:  REPEAT  #4
0E36:  MOV     [W5++],[W15++]
0E38:  CLR     W9
0E3A:  XOR     W1,W3,W9
0E3C:  MOV     W1,W6
0E3E:  MOV     W0,W5
0E40:  MOV     W3,W8
0E42:  MOV     W2,W7
0E44:  RLC     W1,W1
0E46:  SWAP    W1
0E48:  ZE      W1,W1
0E4A:  CP0     W1
0E4C:  BRA     Z,EEA
0E4E:  RLC     W3,W3
0E50:  SWAP    W3
0E52:  ZE      W3,W3
0E54:  CP0     W3
0E56:  BRA     Z,EEA
0E58:  CLR     W0
0E5A:  SUB.B   W1L,W3L,W0L
0E5C:  BRA     NC,E64
0E5E:  ADD.B   #7F,W0L
0E60:  BRA     C,EEA
0E62:  BRA     E6A
0E64:  SUB.B   #81,W0L
0E66:  BRA     NC,EEA
0E68:  BRA     Z,EEA
0E6A:  MOV     W5,W1
0E6C:  MOV     W6,W2
0E6E:  BSET    W2.7
0E70:  AND     #FF,W2
0E72:  AND     #FF,W8
0E74:  BSET    W8.7
0E76:  MOV     #19,W10
0E78:  CLR     W3
0E7A:  CLR     W4
0E7C:  SUB     W1,W7,W1
0E7E:  SUBB    W2,W8,W2
0E80:  BRA     N,E86
0E82:  BRA     C,E8C
0E84:  BRA     NZ,E8E
0E86:  ADD     W1,W7,W1
0E88:  ADDC    W2,W8,W2
0E8A:  BRA     E8E
0E8C:  BSET    W4.0
0E8E:  DEC     W10,W10
0E90:  BRA     Z,EA0
0E92:  BCLR.B  42.0
0E94:  RLC     W1,W1
0E96:  RLC     W2,W2
0E98:  BCLR.B  42.0
0E9A:  RLC     W4,W4
0E9C:  RLC     W3,W3
0E9E:  BRA     E7C
0EA0:  CLR     W10
0EA2:  BTSC    W3.8
0EA4:  BRA     EA8
0EA6:  BRA     EB4
0EA8:  BCLR.B  42.0
0EAA:  RRC     W3,W3
0EAC:  BCLR    W3.7
0EAE:  RRC     W4,W4
0EB0:  RLC     W10,W10
0EB2:  BRA     EB8
0EB4:  DEC     W0,W0
0EB6:  BRA     Z,EEA
0EB8:  BTSC    W10.F
0EBA:  BRA     NC,EC6
0EBC:  RLC     W1,W1
0EBE:  RLC     W2,W2
0EC0:  SUB     W1,W7,W1
0EC2:  SUBB    W2,W8,W2
0EC4:  BRA     NC,ED8
0EC6:  INC     W4,W4
0EC8:  BRA     NZ,ED8
0ECA:  INC     W3,W3
0ECC:  BRA     NZ,ED8
0ECE:  INC     W0,W0
0ED0:  BRA     Z,EEA
0ED2:  BRA     ED8
0ED4:  DEC     W0,W0
0ED6:  BRA     Z,EEA
0ED8:  SWAP    W0
0EDA:  RRC     W0,W1
0EDC:  BSET    W1.F
0EDE:  BTSS    W9.F
0EE0:  BCLR    W1.F
0EE2:  BCLR    W3.7
0EE4:  XOR.B   W3L,W1L,W1L
0EE6:  MOV     W4,W0
0EE8:  BRA     EF0
0EEA:  MOV     #0,W0
0EEC:  MOV     #0,W1
0EEE:  BRA     EF0
0EF0:  MOV     #14,W5
0EF2:  REPEAT  #4
0EF4:  MOV     [--W15],[W5--]
0EF6:  MOV     [--W15],W5
0EF8:  RETURN  
*
1C66:  MOV     W5,[W15++]
1C68:  MOV     #C,W5
1C6A:  REPEAT  #4
1C6C:  MOV     [W5++],[W15++]
1C6E:  MOV     W0,W4
1C70:  MOV     W1,W5
1C72:  MOV     W3,W7
1C74:  MOV     W2,W6
1C76:  BCLR.B  42.0
1C78:  BCLR.B  42.1
1C7A:  RLC     W1,W1
1C7C:  SWAP    W1
1C7E:  AND     #FF,W1
1C80:  CP0     W1
1C82:  BRA     Z,1D1A
1C84:  BCLR.B  42.0
1C86:  BCLR.B  42.1
1C88:  RLC     W3,W3
1C8A:  SWAP    W3
1C8C:  AND     #FF,W3
1C8E:  CP0     W3
1C90:  BRA     Z,1D1A
1C92:  ZE      W0,W0
1C94:  ADD.B   W3L,W1L,W0L
1C96:  BRA     C,1CA0
1C98:  SUB     #7F,W0
1C9A:  BRA     Z,1D1A
1C9C:  BRA     NC,1D1A
1C9E:  BRA     1CA4
1CA0:  ADD.B   #81,W0L
1CA2:  BRA     C,1D1A
1CA4:  XOR     W5,W7,W10
1CA6:  BCLR.B  42.0
1CA8:  BCLR.B  42.1
1CAA:  AND     #FF,W5
1CAC:  BSET    W5.7
1CAE:  BCLR.B  42.0
1CB0:  AND     #FF,W7
1CB2:  BSET    W7.7
1CB4:  MUL.UU  W4,W6,W2
1CB6:  MUL.UU  W5,W6,W8
1CB8:  ADDC    W8,W3,W3
1CBA:  MOV     W9,W1
1CBC:  BTSC.B  42.0
1CBE:  INC     W1,W1
1CC0:  BCLR.B  42.0
1CC2:  MUL.UU  W7,W4,W8
1CC4:  ADDC    W8,W3,W3
1CC6:  ADDC    W9,W1,W1
1CC8:  MUL.UU  W5,W7,W8
1CCA:  ADDC    W8,W1,W1
1CCC:  INC     W0,W0
1CCE:  CP0     W1
1CD0:  BTSC.B  42.1
1CD2:  BRA     1CD6
1CD4:  BRA     1CDC
1CD6:  CP0     W3
1CD8:  BTSC.B  42.1
1CDA:  BRA     1CE6
1CDC:  BTSC    W1.F
1CDE:  BRA     1CE6
1CE0:  RLC     W3,W3
1CE2:  RLC     W1,W1
1CE4:  DEC     W0,W0
1CE6:  MOV     W1,W2
1CE8:  BCLR.B  42.0
1CEA:  BTSS    W3.7
1CEC:  BRA     1D00
1CEE:  MOV     #FF00,W7
1CF0:  AND     W3,W7,W3
1CF2:  ADD     #100,W3
1CF4:  ADDC    W2,#0,W2
1CF6:  CP0     W2
1CF8:  BRA     NZ,1D00
1CFA:  CP0     W3
1CFC:  BRA     NZ,1D00
1CFE:  INC     W0,W0
1D00:  SWAP    W0
1D02:  BCLR.B  42.0
1D04:  BCLR.B  42.1
1D06:  RRC     W0,W1
1D08:  BTSC    W10.F
1D0A:  BSET    W1.F
1D0C:  BCLR    W2.F
1D0E:  SWAP    W2
1D10:  XOR.B   W2L,W1L,W1L
1D12:  SWAP    W3
1D14:  MOV.B   W3L,W2L
1D16:  MOV     W2,W0
1D18:  BRA     1D20
1D1A:  MOV     #0,W0
1D1C:  MOV     #0,W1
1D1E:  BRA     1D20
1D20:  MOV     #14,W5
1D22:  REPEAT  #4
1D24:  MOV     [--W15],[W5--]
1D26:  MOV     [--W15],W5
1D28:  RETURN  
1D2A:  MOV     W0,W2
1D2C:  MOV     W1,W3
1D2E:  MOV.B   W1L,W0L
1D30:  SWAP    W0
1D32:  BSET    W0.F
1D34:  RLC     W1,W1
1D36:  SWAP    W1
1D38:  ZE      W1,W1
1D3A:  MOV     #8E,W4
1D3C:  SUB.B   W4L,W1L,W1L
1D3E:  BRA     Z,1D4C
1D40:  CP0     W0
1D42:  BRA     Z,1D4C
1D44:  BCLR.B  42.0
1D46:  RRC     W0,W0
1D48:  DEC     W1,W1
1D4A:  BRA     NZ,1D40
1D4C:  BTSS    W3.F
1D4E:  BRA     1D54
1D50:  NEG     W0,W0
1D52:  BRA     1D54
1D54:  RETURN  
....................  
.................... #list 
....................  
.................... #include "uart.h" 
....................  
....................  
.................... #word MCU_U1MODE = 0x220 
.................... #bit    MCU_STSEL = MCU_U1MODE.0 
.................... #bit    MCU_PDSEL0 = MCU_U1MODE.1 
.................... #bit    MCU_PDSEL1 = MCU_U1MODE.2 
.................... #bit    MCU_BRGH = MCU_U1MODE.3 
.................... #bit    MCU_URXINV = MCU_U1MODE.4 
.................... #bit    MCU_ABAUD = MCU_U1MODE.5 
.................... #bit    MCU_LPBACK = MCU_U1MODE.6 
.................... #bit    MCU_WAKE = MCU_U1MODE.7 
.................... #bit    MCU_UEN0 = MCU_U1MODE.8 
.................... #bit    MCU_UEN1 = MCU_U1MODE.9 
.................... #bit    MCU_RTSMD = MCU_U1MODE.11 
.................... #bit    MCU_IREN = MCU_U1MODE.12 
.................... #bit    MCU_USIDL = MCU_U1MODE.13 
.................... #bit    MCU_UARTEN = MCU_U1MODE.15 
.................... #word MCU_U1STA = 0x222 
.................... #bit    MCU_URXDA = MCU_U1STA.0 
.................... #bit    MCU_OERR = MCU_U1STA.1 
.................... #bit    MCU_FERR = MCU_U1STA.2 
.................... #bit    MCU_PERR = MCU_U1STA.3 
.................... #bit    MCU_RIDLE = MCU_U1STA.4 
.................... #bit    MCU_ADDEN = MCU_U1STA.5 
.................... #bit    MCU_URXISEL0 = MCU_U1STA.6 
.................... #bit    MCU_URXISEL1 = MCU_U1STA.7 
.................... #bit    MCU_TRMT = MCU_U1STA.8 
.................... #bit    MCU_UTXBF = MCU_U1STA.9 
.................... #bit    MCU_UTXEN = MCU_U1STA.10 
.................... #bit    MCU_UTXBRK = MCU_U1STA.11 
.................... #bit    MCU_UTXISEL0 = MCU_U1STA.13 
.................... #bit    MCU_UTXINV = MCU_U1STA.14 
.................... #bit    MCU_UTXISEL1 = MCU_U1STA.15 
.................... #word MCU_U1TXREG = 0x224 
.................... //#word MCU_U1TXREG = 0x224 
.................... #bit    MCU_UTXREG0 = MCU_U1TXREG.0 
.................... #bit    MCU_UTXREG1 = MCU_U1TXREG.1 
.................... #bit    MCU_UTXREG2 = MCU_U1TXREG.2 
.................... #bit    MCU_UTXREG3 = MCU_U1TXREG.3 
.................... #bit    MCU_UTXREG4 = MCU_U1TXREG.4 
.................... #bit    MCU_UTXREG5 = MCU_U1TXREG.5 
.................... #bit    MCU_UTXREG6 = MCU_U1TXREG.6 
.................... #bit    MCU_UTXREG7 = MCU_U1TXREG.7 
.................... #bit    MCU_UTXREG8 = MCU_U1TXREG.8 
.................... #word MCU_U1RXREG = 0x226 
.................... //#word MCU_U1RXREG = 0x226 
.................... #bit    MCU_URXREG0 = MCU_U1RXREG.0 
.................... #bit    MCU_URXREG1 = MCU_U1RXREG.1 
.................... #bit    MCU_URXREG2 = MCU_U1RXREG.2 
.................... #bit    MCU_URXREG3 = MCU_U1RXREG.3 
.................... #bit    MCU_URXREG4 = MCU_U1RXREG.4 
.................... #bit    MCU_URXREG5 = MCU_U1RXREG.5 
.................... #bit    MCU_URXREG6 = MCU_U1RXREG.6 
.................... #bit    MCU_URXREG7 = MCU_U1RXREG.7 
.................... #bit    MCU_URXREG8 = MCU_U1RXREG.8 
.................... #word MCU_U1BRG = 0x228 
....................  
....................  
....................  
.................... #ZERO_RAM 
.................... #DEVICE ADC=12 
....................  
.................... #FUSES NOWDT     	  	   		 //No Watch Dog Timer  
.................... #FUSES HS 
.................... #FUSES PR_PLL                 //High speed Osc (> 4mhz)  
.................... #FUSES PUT64                     //Power Up Timer  
.................... #FUSES NOPROTECT                 //Code not protected from reads  
.................... #FUSES NODEBUG                   //No Debug mode for ICD  
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... //*- CRC -*// 
.................... #rom getenv("PROGRAM_MEMORY")-2 = CHECKSUM 
....................  
.................... #define FREQUENCY 80000000  //!!!!PR_PLL 
.................... #use delay(clock=FREQUENCY, oscilator=FREQUENCY) 
....................  
.................... #use rs232(UART1, baud=115200, BITS =8,PARITY=N, STOP=1, ENABLE=PIN_F6, ERRORS, STREAM = RS1) 
*
029A:  BTSS.B  222.0
029C:  BRA     29A
029E:  PUSH    222
02A0:  POP     800
02A2:  MOV     226,W0
02A4:  BCLR.B  222.1
02A6:  RETURN  
....................  
.................... #use standard_io(All) 
....................  
....................  
.................... int8 adress = 0;  
....................  
....................  
.................... //ID 
.................... #define ID1 0x17 
.................... #define ID2 0x03 
.................... #define ID3 0x20 
.................... #define ID4 0x16 
....................  
.................... //adress 
.................... #define ADRES1    0x85 
.................... #define ADRES2    0x85 
....................  
.................... //commands  
.................... //PWM 
.................... #define COM_SET_PWM_RK       0x31 //устанавливает значения всех стрелок, бленкеров, индексов 
.................... #define COM_SET_SPEED		 0x33 //максим и мин скорости	 
.................... 	//parameters PWM 
.................... 	#define SEL_SET_PWM_RK		 0x10 //значения всех стрелок, бленкеров, индексов 
.................... 	#define SEL_SET_PWM5	     0x05 //только стрелка угла атаки 	 
.................... 	#define SEL_SET_PWM3         0x03 //индекс угла атаки 		 
.................... 	#define SEL_SET_PWM4         0x04 //стрелка перегрузки   
.................... 	#define SEL_SET_PWM6         0x06 //индекс перегрузки  
.................... 	#define SEL_SET_RK           0x07 //бленкер угла атаки & блекнкер перегрузки 
.................... #define COM_READ_SPEED       0x43  // чтение установленых макс и мин скорости 
.................... //ADC 
.................... #define COM_RUN_CALIBR       0x32 //запуск калибровки АЦП 
.................... #define COM_READ_ADC         0x40 //текущее значение АЦП 
.................... #define COM_LIMIT_ADC		 0x41 //измеренные минимум и максимум АЦП 
.................... #define COM_READ_ERROR		 0x42 //текущее состояние мотора () 
.................... //PWM_POWER 
.................... #define COM_ONOFF_PWM		 0x35 // включение и отключение Шим 
....................  
.................... // 
.................... #define COM_READ_CRC	     0x47 //чтение контрольной суммы 
.................... #define COM_INFO			 0x48 //поддерживаемы команды  
.................... #define COM_READ_ID		     0x46 //идентификатор 
.................... #define COM_RESET_MK		 0x55 //программный перезапуск МК	 
.................... 	#define RESET_MK_WORD_2      0xAA //2 е -слово используемое в команде перезапуска МК 
....................  
....................  
.................... //add modul  
....................  
.................... #include "Led.c"      // timer5 
.................... // used timer5  
....................  
.................... #define LED_GREEN_ON {output_high(PIN_G7); output_low(PIN_G0);} 
.................... #define LED_GREEN_OFF {output_low(PIN_G7); output_high(PIN_G0);} 
.................... #define LED_RED_ON {output_high(PIN_G8); output_low(PIN_G1);} 
.................... #define LED_RED_OFF {output_low(PIN_G8); output_high(PIN_G1);} 
....................  
.................... // color vd 
.................... #define LED_RED   0x5555 
.................... #define LED_GREEN 0xAAAA 
....................  
.................... int1 runRedVd = 0;  
.................... int1 runGreenVd = 0;  
.................... int1 periodRed = 0; 
.................... int1 periodGreen = 0; 
....................  
.................... void runVD(int color);  
.................... void initLed();  
....................  
.................... static const int16 time = 15625; //10Hz//23528; // Fcy = Fosc/2; t=Fcy*256 (t.k. (TMR_INTERNAL|TMR_DIV_BY_256) 
.................... //************************************************************ 
.................... //* 
.................... //************************************************************ 
.................... void initLed() 
.................... { 
.................... 	setup_timer5(TMR_INTERNAL|TMR_DIV_BY_256, time ); 
*
0854:  CLR     120
0856:  MOV     #3D09,W4
0858:  MOV     W4,11C
085A:  MOV     #8030,W4
085C:  MOV     W4,120
.................... 	set_timer5(0); 
085E:  CLR     118
.................... 	enable_interrupts(INT_TIMER5); 
0860:  BSET.B  97.4
.................... 	runVD(LED_GREEN);  
0862:  MOV     #AAAA,W4
0864:  MOV     W4,97E
0866:  CALL    832
.................... 	runVD(LED_RED);  
086A:  MOV     #5555,W4
086C:  MOV     W4,97E
086E:  CALL    832
0872:  RETURN  
.................... } 
.................... //************************************************************ 
.................... // управление светодиодом 
.................... //************************************************************ 
.................... void runVD(int color) 
.................... { 
....................  
.................... 	switch(color) 
*
0832:  MOV     97E,W0
0834:  MOV     #5555,W4
0836:  CP      W0,W4
0838:  BRA     Z,842
083A:  MOV     #AAAA,W4
083C:  CP      W0,W4
083E:  BRA     Z,84A
0840:  BRA     852
.................... 	{ 
.................... 		case LED_RED:  
.................... 		{ 
.................... 			if(!periodRed)  
0842:  BTSC.B  803.2
0844:  BRA     848
.................... 			{ 
.................... 				runRedVd = 1; 				 
0846:  BSET.B  803.0
.................... 			} 		 
.................... 			break;  
0848:  BRA     852
.................... 		} 
.................... 		case LED_GREEN:  
.................... 		{ 
.................... 			if(!periodGreen) 
084A:  BTSC.B  803.3
084C:  BRA     850
.................... 			{ 
.................... 				runGreenVd = 1;  
084E:  BSET.B  803.1
.................... 			}  
.................... 			break;  
0850:  BRA     852
.................... 		} 
.................... 		default: 
.................... 		{ 
....................  
.................... 		} 
.................... 	} 
0852:  RETURN  
.................... } 
....................  
....................  
....................  
.................... //*************************************************************** 
.................... //* 
.................... //*************************************************************** 
.................... #int_timer5 
.................... void timer5_isr(void) 
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
.................... 	if(runRedVd) 
020E:  BTSS.B  803.0
0210:  BRA     220
.................... 	{ 
.................... 		LED_RED_ON; 
0212:  BCLR.B  2E5.0
0214:  BSET.B  2E9.0
0216:  BCLR.B  2E4.1
0218:  BCLR.B  2E8.1
.................... 		runRedVd = 0; 
021A:  BCLR.B  803.0
.................... 		periodRed = 1;  
021C:  BSET.B  803.2
.................... 	} 
021E:  BRA     22A
.................... 	else  
.................... 	{	 
.................... 	 	LED_RED_OFF; 
0220:  BCLR.B  2E5.0
0222:  BCLR.B  2E9.0
0224:  BCLR.B  2E4.1
0226:  BSET.B  2E8.1
.................... 		periodRed = 0;  
0228:  BCLR.B  803.2
.................... 	 
.................... 	} 
.................... 	 
.................... 	if(runGreenVd) 
022A:  BTSS.B  803.1
022C:  BRA     23C
.................... 	{ 
.................... 			LED_GREEN_OFF; 
022E:  BCLR.B  2E4.7
0230:  BCLR.B  2E8.7
0232:  BCLR.B  2E4.0
0234:  BSET.B  2E8.0
.................... 			runGreenVd = 0;  
0236:  BCLR.B  803.1
.................... 			periodGreen = 1;   
0238:  BSET.B  803.3
.................... 	} 
023A:  BRA     246
.................... 	else 
.................... 	{ 
.................... 		LED_GREEN_ON;  
023C:  BCLR.B  2E4.7
023E:  BSET.B  2E8.7
0240:  BCLR.B  2E4.0
0242:  BCLR.B  2E8.0
.................... 		periodGreen = 0;  
0244:  BCLR.B  803.3
....................  
.................... 	} 
.................... 	clear_interrupt(INT_TIMER5); 
0246:  BCLR.B  87.4
.................... //	disable_interrupts(INT_TIMER5); 
.................... 	set_timer5(0); 
0248:  CLR     118
....................   
.................... } 
....................  
....................  
.................... #include "PLL.c" 
.................... #include "PLL.h" 
.................... #ifndef PLL_H 
.................... #define PLL_H 
....................  
....................  
....................  
.................... // OSCILLATOR CONFIGURATION  
024A:  BCLR.B  87.4
024C:  MOV     #1A,W0
024E:  REPEAT  #C
0250:  MOV     [--W15],[W0--]
0252:  MOV     [--W15],W0
0254:  POP     32
0256:  POP     36
0258:  POP     42
025A:  RETFIE  
.................... #WORD CLKDIV = 0x0744         //PLLPOST(6,7) - PLLPRE(0,1,2,3,4)  
....................  
.................... #BIT PLLPOST_0 = CLKDIV.6  
.................... #BIT PLLPOST_1 = CLKDIV.7  
....................  
.................... #BIT PLLPRE_0 = CLKDIV.0  
.................... #BIT PLLPRE_1 = CLKDIV.1  
.................... #BIT PLLPRE_2 = CLKDIV.2  
.................... #BIT PLLPRE_3 = CLKDIV.3  
.................... #BIT PLLPRE_4 = CLKDIV.4  
....................  
.................... #WORD PLLFBD = 0x0746         //PLLDIV(0,1,2,3,4,5,6,7,8)  
....................  
.................... #BIT PLLDIV_0 = PLLFBD.0  
.................... #BIT PLLDIV_1 = PLLFBD.1  
.................... #BIT PLLDIV_2 = PLLFBD.2  
.................... #BIT PLLDIV_3 = PLLFBD.3  
.................... #BIT PLLDIV_4 = PLLFBD.4  
.................... #BIT PLLDIV_5 = PLLFBD.5  
.................... #BIT PLLDIV_6 = PLLFBD.6  
.................... #BIT PLLDIV_7 = PLLFBD.7  
.................... #BIT PLLDIV_8 = PLLFBD.8 
....................  
....................  
.................... void init_PLL();  
....................  
.................... #endif 
....................  
.................... void init_PLL() 
.................... { 
.................... 	//********* ”становка рабочей частоты 80 ћvц при кварце 16 ћvц ********* 
.................... // OSCILLATOR CONFIGURATION 
.................... // PLLPRE=4  Luego N1=2  
....................    PLLPRE_0 = 0;  
*
078A:  BCLR.B  744.0
....................    PLLPRE_1 = 1;  
078C:  BSET.B  744.1
....................    PLLPRE_2 = 0;  
078E:  BCLR.B  744.2
....................    PLLPRE_3 = 0;  
0790:  BCLR.B  744.3
....................    PLLPRE_4 = 0;  
0792:  BCLR.B  744.4
....................  
....................    // PLLPOST=0  Luego N2=0 
....................    PLLPOST_0 = 0;  
0794:  BCLR.B  744.6
....................    PLLPOST_1 = 0;  
0796:  BCLR.B  744.7
....................  
....................    // PLLDIV=30  Luego M=26  
....................    PLLDIV_0 = 0;  
0798:  BCLR.B  746.0
....................    PLLDIV_1 = 1;  
079A:  BSET.B  746.1
....................    PLLDIV_2 = 1;  
079C:  BSET.B  746.2
....................    PLLDIV_3 = 0;  
079E:  BCLR.B  746.3
....................    PLLDIV_4 = 0;  
07A0:  BCLR.B  746.4
....................    PLLDIV_5 = 1;  
07A2:  BSET.B  746.5
....................    PLLDIV_6 = 0;  
07A4:  BCLR.B  746.6
....................    PLLDIV_7 = 0;  
07A6:  BCLR.B  746.7
....................    PLLDIV_8 = 0;  
07A8:  BCLR.B  747.0
07AA:  RETURN  
.................... //********************************************************************** 
.................... } 
....................  
.................... #include "AZP.c"      // dma1, adc 
.................... #include "AZP.h" 
.................... #ifndef AZP_H 
.................... #define AZP_H 
....................  
.................... #include "ADC.h" 
.................... #ifndef ADC_H 
.................... #define ADC_H 
....................  
.................... #word MCU_ADC1BUF0 = 0x300 
.................... #word MCU_AD1CON1 = 0x320 
.................... #bit    MCU_DONE = MCU_AD1CON1.0 
.................... #bit    MCU_SAMP = MCU_AD1CON1.1 
.................... #bit    MCU_ASAM = MCU_AD1CON1.2 
.................... #bit    MCU_SIMSAM = MCU_AD1CON1.3 
.................... #bit    MCU_SSRC0 = MCU_AD1CON1.5 
.................... #bit    MCU_SSRC1 = MCU_AD1CON1.6 
.................... #bit    MCU_SSRC2 = MCU_AD1CON1.7 
.................... #bit    MCU_FORM0 = MCU_AD1CON1.8 
.................... #bit    MCU_FORM1 = MCU_AD1CON1.9 
.................... #bit    MCU_AD12B = MCU_AD1CON1.10 
.................... #bit    MCU_ADDMABM = MCU_AD1CON1.12 
.................... #bit    MCU_ADSIDL = MCU_AD1CON1.13 
.................... #bit    MCU_ADON = MCU_AD1CON1.15 
.................... #word MCU_AD1CON2 = 0x322 
.................... #bit    MCU_ALTS = MCU_AD1CON2.0 
.................... #bit    MCU_BUFM = MCU_AD1CON2.1 
.................... #bit    MCU_SMPI0 = MCU_AD1CON2.2 
.................... #bit    MCU_SMPI1 = MCU_AD1CON2.3 
.................... #bit    MCU_SMPI2 = MCU_AD1CON2.4 
.................... #bit    MCU_SMPI3 = MCU_AD1CON2.5 
.................... #bit    MCU_BUFS = MCU_AD1CON2.7 
.................... #bit    MCU_CHPS0 = MCU_AD1CON2.8 
.................... #bit    MCU_CHPS1 = MCU_AD1CON2.9 
.................... #bit    MCU_CSCNA = MCU_AD1CON2.10 
.................... #bit    MCU_VCFG0 = MCU_AD1CON2.13 
.................... #bit    MCU_VCFG1 = MCU_AD1CON2.14 
.................... #bit    MCU_VCFG2 = MCU_AD1CON2.15 
.................... #word MCU_AD1CON3 = 0x324 
.................... #bit    MCU_ADCS0 = MCU_AD1CON3.0 
.................... #bit    MCU_ADCS1 = MCU_AD1CON3.1 
.................... #bit    MCU_ADCS2 = MCU_AD1CON3.2 
.................... #bit    MCU_ADCS3 = MCU_AD1CON3.3 
.................... #bit    MCU_ADCS4 = MCU_AD1CON3.4 
.................... #bit    MCU_ADCS5 = MCU_AD1CON3.5 
.................... #bit    MCU_ADCS6 = MCU_AD1CON3.6 
.................... #bit    MCU_ADCS7 = MCU_AD1CON3.7 
.................... #bit    MCU_SAMC0 = MCU_AD1CON3.8 
.................... #bit    MCU_SAMC1 = MCU_AD1CON3.9 
.................... #bit    MCU_SAMC2 = MCU_AD1CON3.10 
.................... #bit    MCU_SAMC3 = MCU_AD1CON3.11 
.................... #bit    MCU_SAMC4 = MCU_AD1CON3.12 
.................... #bit    MCU_ADRC = MCU_AD1CON3.15 
.................... #word MCU_AD1CHS123 = 0x326 
.................... #bit    MCU_CH123SA = MCU_AD1CHS123.0 
.................... #bit    MCU_CH123NA0 = MCU_AD1CHS123.1 
.................... #bit    MCU_CH123NA1 = MCU_AD1CHS123.2 
.................... #bit    MCU_CH123SB = MCU_AD1CHS123.8 
.................... #bit    MCU_CH123NB0 = MCU_AD1CHS123.9 
.................... #bit    MCU_CH123NB1 = MCU_AD1CHS123.10 
.................... #word MCU_AD1CHS0 = 0x328 
.................... #bit    MCU_CH0SA0 = MCU_AD1CHS0.0 
.................... #bit    MCU_CH0SA1 = MCU_AD1CHS0.1 
.................... #bit    MCU_CH0SA2 = MCU_AD1CHS0.2 
.................... #bit    MCU_CH0SA3 = MCU_AD1CHS0.3 
.................... #bit    MCU_CH0SA4 = MCU_AD1CHS0.4 
.................... #bit    MCU_CH0NA = MCU_AD1CHS0.7 
.................... #bit    MCU_CH0SB0 = MCU_AD1CHS0.8 
.................... #bit    MCU_CH0SB1 = MCU_AD1CHS0.9 
.................... #bit    MCU_CH0SB2 = MCU_AD1CHS0.10 
.................... #bit    MCU_CH0SB3 = MCU_AD1CHS0.11 
.................... #bit    MCU_CH0SB4 = MCU_AD1CHS0.12 
.................... #bit    MCU_CH0NB = MCU_AD1CHS0.15 
.................... //#word MCU_AD1PCFGH = 0x32A 
.................... #word MCU_AD1PCFGH = 0x32A 
.................... #bit    MCU_PCFG16 = MCU_AD1PCFGH.0 
.................... #bit    MCU_PCFG17 = MCU_AD1PCFGH.1 
.................... #word MCU_AD1PCFGL = 0x32C 
.................... #bit    MCU_PCFG0 = MCU_AD1PCFGL.0 
.................... #bit    MCU_PCFG1 = MCU_AD1PCFGL.1 
.................... #bit    MCU_PCFG2 = MCU_AD1PCFGL.2 
.................... #bit    MCU_PCFG3 = MCU_AD1PCFGL.3 
.................... #bit    MCU_PCFG4 = MCU_AD1PCFGL.4 
.................... #bit    MCU_PCFG5 = MCU_AD1PCFGL.5 
.................... #bit    MCU_PCFG6 = MCU_AD1PCFGL.6 
.................... #bit    MCU_PCFG7 = MCU_AD1PCFGL.7 
.................... #bit    MCU_PCFG8 = MCU_AD1PCFGL.8 
.................... #bit    MCU_PCFG9 = MCU_AD1PCFGL.9 
.................... #bit    MCU_PCFG10 = MCU_AD1PCFGL.10 
.................... #bit    MCU_PCFG11 = MCU_AD1PCFGL.11 
.................... #bit    MCU_PCFG12 = MCU_AD1PCFGL.12 
.................... #bit    MCU_PCFG13 = MCU_AD1PCFGL.13 
.................... #bit    MCU_PCFG14 = MCU_AD1PCFGL.14 
.................... #bit    MCU_PCFG15 = MCU_AD1PCFGL.15 
.................... //#word MCU_AD1CSSH = 0x32E 
.................... #word MCU_AD1CSSH = 0x32E 
.................... #bit    MCU_CSS16 = MCU_AD1CSSH.0 
.................... #bit    MCU_CSS17 = MCU_AD1CSSH.1 
.................... #word MCU_AD1CSSL = 0x330 
.................... #bit    MCU_CSS0 = MCU_AD1CSSL.0 
.................... #bit    MCU_CSS1 = MCU_AD1CSSL.1 
.................... #bit    MCU_CSS2 = MCU_AD1CSSL.2 
.................... #bit    MCU_CSS3 = MCU_AD1CSSL.3 
.................... #bit    MCU_CSS4 = MCU_AD1CSSL.4 
.................... #bit    MCU_CSS5 = MCU_AD1CSSL.5 
.................... #bit    MCU_CSS6 = MCU_AD1CSSL.6 
.................... #bit    MCU_CSS7 = MCU_AD1CSSL.7 
.................... #bit    MCU_CSS8 = MCU_AD1CSSL.8 
.................... #bit    MCU_CSS9 = MCU_AD1CSSL.9 
.................... #bit    MCU_CSS10 = MCU_AD1CSSL.10 
.................... #bit    MCU_CSS11 = MCU_AD1CSSL.11 
.................... #bit    MCU_CSS12 = MCU_AD1CSSL.12 
.................... #bit    MCU_CSS13 = MCU_AD1CSSL.13 
.................... #bit    MCU_CSS14 = MCU_AD1CSSL.14 
.................... #bit    MCU_CSS15 = MCU_AD1CSSL.15 
.................... #word MCU_AD1CON4 = 0x332 
.................... #word MCU_DMA0STB = 0x386 
.................... #word MCU_DMACS0 = 0x3E0 
.................... #bit    MCU_XWCOL0 = MCU_DMACS0.0 
.................... #bit    MCU_XWCOL1 = MCU_DMACS0.1 
.................... #bit    MCU_XWCOL2 = MCU_DMACS0.2 
.................... #bit    MCU_XWCOL3 = MCU_DMACS0.3 
.................... #bit    MCU_XWCOL4 = MCU_DMACS0.4 
.................... #bit    MCU_XWCOL5 = MCU_DMACS0.5 
.................... #bit    MCU_XWCOL6 = MCU_DMACS0.6 
.................... #bit    MCU_XWCOL7 = MCU_DMACS0.7 
.................... #bit    MCU_PWCOL0 = MCU_DMACS0.8 
.................... #bit    MCU_PWCOL1 = MCU_DMACS0.9 
.................... #bit    MCU_PWCOL2 = MCU_DMACS0.10 
.................... #bit    MCU_PWCOL3 = MCU_DMACS0.11 
.................... #bit    MCU_PWCOL4 = MCU_DMACS0.12 
.................... #bit    MCU_PWCOL5 = MCU_DMACS0.13 
.................... #bit    MCU_PWCOL6 = MCU_DMACS0.14 
.................... #bit    MCU_PWCOL7 = MCU_DMACS0.15 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //ADC INPUT 
.................... #define AV1 PIN_B2  //AN2 
.................... #define AV2 PIN_B3  //AN3 
.................... #define AV3 PIN_B13 //AN13 
.................... #define AV4 PIN_B14 //AN14 
....................  
.................... #define SIZE_DMA_ADC_BUF 4 
.................... #BANK_DMA  
.................... static volatile int16 dmaAdcBuf[SIZE_DMA_ADC_BUF]; 
....................  
.................... int1 dmaAdcFlag = 0;   
....................  
.................... int16 valAdc1 = 0;  
.................... int16 valAdc2 = 0;  
.................... int16 valAdc3 = 0;  
.................... int16 valAdc4 = 0;  
....................  
....................  
.................... void clearAdcDmaBuf(); 
.................... void initAdcDma();   
.................... void initADC();  
.................... void readDmaAdc(); 
....................  
.................... //int1 tempDma = 0;  
....................  
....................  
....................  
....................   
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... void clearAdcDmaBuf()  
.................... { 
.................... 	memset(dmaAdcBuf, 0x00, sizeof(dmaAdcBuf));   
*
0874:  MOV     #2000,W1
0876:  MOV     #0,W2
0878:  REPEAT  #7
087A:  CLR.B   [W1++]
087C:  RETURN  
.................... } 
....................  
.................... void initAdcDma() 
.................... { 
....................  
.................... 	clearAdcDmaBuf();  
087E:  CALL    874
.................... 	setup_dma(2, DMA_IN_ADC1, DMA_WORD); 
0882:  CLR.B   399
0884:  MOV.B   #D,W0L
0886:  MOV.B   W0L,39A
0888:  MOV     #300,W4
088A:  MOV     W4,3A0
.................... 	dma_start(2,DMA_CONTINOUS, &dmaAdcBuf[0]);  
088C:  BCLR.B  399.7
088E:  CLR.B   398
0890:  MOV     #2000,W4
0892:  MOV     W4,39C
0894:  BTSS.B  399.6
0896:  BRA     89E
0898:  MOV     #7,W4
089A:  MOV     W4,3A2
089C:  BRA     8A2
089E:  MOV     #3,W4
08A0:  MOV     W4,3A2
08A2:  BSET.B  399.7
.................... 	enable_interrupts(INT_DMA2);	 
08A4:  BSET.B  97.0
08A6:  RETURN  
.................... } 
....................  
.................... #INT_DMA2 
.................... void DMA2Interrupts() 
*
0276:  PUSH    42
0278:  PUSH    36
027A:  PUSH    32
027C:  MOV     W0,[W15++]
027E:  MOV     #2,W0
0280:  REPEAT  #C
0282:  MOV     [W0++],[W15++]
.................... { 
.................... 	//dmaAdcFlag = 1;  
.................... 	readDmaAdc(); 
0284:  CALL    25C
.................... 	//runVD(LED_RED);	 
0288:  BCLR.B  87.0
028A:  MOV     #1A,W0
028C:  REPEAT  #C
028E:  MOV     [--W15],[W0--]
0290:  MOV     [--W15],W0
0292:  POP     32
0294:  POP     36
0296:  POP     42
0298:  RETFIE  
.................... } 
....................  
.................... void readDmaAdc() 
.................... { 
.................... 	//if(dmaAdcFlag) 
.................... 	//{ 
.................... 		valAdc1 = (dmaAdcBuf[0]&0xFFFF); 
*
025C:  MOV     2000,W0
025E:  MOV     W0,W4
0260:  MOV     W4,804
.................... 		valAdc2 = (dmaAdcBuf[1]&0xFFFF); 
0262:  MOV     2002,W0
0264:  MOV     W0,W4
0266:  MOV     W4,806
.................... 		valAdc3 = (dmaAdcBuf[2]&0xFFFF); 
0268:  MOV     2004,W0
026A:  MOV     W0,W4
026C:  MOV     W4,808
.................... 		valAdc4 = (dmaAdcBuf[3]&0xFFFF);  
026E:  MOV     2006,W0
0270:  MOV     W0,W4
0272:  MOV     W4,80A
0274:  RETURN  
.................... 	//	dmaAdcFlag = 1; 
.................... 	/*	tempDma = !tempDma;  
.................... 		if(tempDma) 
.................... 		{	output_high(PIN_G1); } 
.................... 		else {output_low(PIN_G1); }*/ 
.................... 			  
.................... 	  
.................... 	//} 
.................... } 
....................  
.................... void initADC() 
.................... { 
.................... 	//1)set mode 12 bit 
.................... 	MCU_ADON = 0; 
*
08A8:  BCLR.B  321.7
.................... 	MCU_AD12B = 1;  
08AA:  BSET.B  321.2
.................... 	//2)SET VOLTAGE REFERENSE 	  
.................... 	MCU_VCFG0 = 0;  
08AC:  BCLR.B  323.5
.................... 	MCU_VCFG1 = 0;  
08AE:  BCLR.B  323.6
.................... 	MCU_VCFG2 = 0;  
08B0:  BCLR.B  323.7
.................... 	//3)SELECT ANALOG CONVERSION CLOCK 
.................... 	MCU_AD1CON3 = 0x0606; //0000_0100_0000_0100 
08B2:  MOV     #606,W4
08B4:  MOV     W4,324
.................... 	 					  // AutoSample 4TAD 
.................... 						  // TAD = 5*Tcy	 
.................... 						  // Tcy = 1/Fcy  
.................... 						  // Fcy = Fosc/2 
.................... 	//4)select port pins 
.................... 	MCU_PCFG16 = 0x01; 
08B6:  BSET.B  32A.0
.................... 	MCU_PCFG17 = 0x01;  
08B8:  BSET.B  32A.1
.................... 	MCU_AD1PCFGL = 0x9FF3; 
08BA:  MOV     #9FF3,W4
08BC:  MOV     W4,32C
.................... 	//5)determine inputs to channels 
.................... 	MCU_AD1CHS0 = 0x0006;  
08BE:  MOV     #6,W4
08C0:  MOV     W4,328
.................... 	//6)DETERMINE how many Sample/Hold channels 
.................... 	MCU_CHPS0 = 0;  
08C2:  BCLR.B  323.0
.................... 	MCU_CHPS1 = 0;  
08C4:  BCLR.B  323.1
.................... 	//7)Determine how sampling will occur 
.................... 	 
.................... 	MCU_SIMSAM = 0; 
08C6:  BCLR.B  320.3
.................... 	MCU_CSS16 = 0;  
08C8:  BCLR.B  32E.0
.................... 	MCU_CSS17 = 0;  
08CA:  BCLR.B  32E.1
.................... 	MCU_AD1CSSL = 0x600C;  
08CC:  MOV     #600C,W4
08CE:  MOV     W4,330
.................... 	//8)Auto sampling  
.................... 	MCU_ASAM = 1; 
08D0:  BSET.B  320.2
.................... 	//Select conversion trigger and sampling time 
.................... 	MCU_SSRC0 = 1; // internal counter ends sampling and start conversion (auto-convert) 
08D2:  BSET.B  320.5
.................... 	MCU_SSRC1 = 1; 
08D4:  BSET.B  320.6
.................... 	MCU_SSRC2 = 1;  
08D6:  BSET.B  320.7
.................... 	//Select how conversion results 
.................... 	MCU_FORM0 = 0; 
08D8:  BCLR.B  321.0
.................... 	MCU_FORM1 = 0; 
08DA:  BCLR.B  321.1
.................... 	//Select interrupt rate or DMA buffer pointer increment rate 
.................... 	MCU_SMPI0 = 1;  
08DC:  BSET.B  322.2
.................... 	MCU_SMPI1 = 1; 
08DE:  BSET.B  322.3
.................... 	MCU_SMPI2 = 0; 
08E0:  BCLR.B  322.4
.................... 	MCU_SMPI3 = 0; 
08E2:  BCLR.B  322.5
.................... 	//Select the number of samples  
.................... 	//in DMA buffer for each ADC module input 
.................... 	MCU_AD1CON4 = 0; // 1 WORD   
08E4:  CLR     332
.................... 	// Select the data format 
....................  
.................... 	//Configure DMA channel (if needed) 
.................... 	initAdcDma();	 
08E6:  CALL    87E
....................  
.................... 	//Configure ADC interrupt (if required) 
.................... 	 
.................... 	MCU_ADDMABM = 0;  
08EA:  BCLR.B  321.4
.................... 	MCU_CSCNA = 1; 
08EC:  BSET.B  323.2
.................... 	MCU_BUFM = 0; 
08EE:  BCLR.B  322.1
.................... 	//Turn on ADC module  
.................... 	 MCU_ADON = 1;  
08F0:  BSET.B  321.7
08F2:  RETURN  
.................... 	 	 
.................... } 
....................  
....................  
....................  
.................... #include "pwmUap.c"   //pwm, timer3 // 
.................... #include "pwmUap.h" 
.................... #ifndef PWMUAP_H 
.................... #define PWMUAP_H 
....................  
.................... #include "CalibrAdcPwm.h" 
.................... #ifndef CALIBRADCPWM_H 
.................... #define CALIBRADCPWM_H 
....................  
.................... #include "pwmUap.h" 
.................... #ifndef PWMUAP_H 
.................... #define PWMUAP_H 
....................  
.................... #include "CalibrAdcPwm.h" 
.................... #include "motor.h" 
....................  
.................... //PWM OUTPUT 
.................... #define CANAL1_PWM PIN_D0 
.................... #define CANAL2_PWM PIN_D1 
.................... #define CANAL3_PWM PIN_D2 
.................... #define CANAL4_PWM PIN_D3 
.................... #define CANAL5_PWM PIN_D4 
.................... #define CANAL6_PWM PIN_D5 
....................  
....................  
.................... #define PIN_BLENK1 PIN_F0 
.................... #define PIN_BLENK2 PIN_F1  
.................... #define BLENK1_ON  output_low(PIN_BLENK1);  
.................... #define BLENK1_OFF output_high(PIN_BLENK1);  
.................... #define BLENK2_ON  output_low(PIN_BLENK2);  
.................... #define BLENK2_OFF output_high(PIN_BLENK2); 
....................  
....................  
....................  
.................... Motor m3;  
.................... Motor m4;  
.................... Motor m5;  
.................... Motor m6;  
....................  
.................... int16 newValueM3 = 0;  
.................... int16 newValueM4 = 0;  
.................... int16 newValueM5 = 0;  
.................... int16 newValueM6 = 0;  
.................... int8  newValueRk = 0;  
.................... //ENAB POWER PWM 
.................... #define SD_PIN PIN_G15 // shutdown IR2014S 
.................... #define ON_PWR_PWM output_high(SD_PIN) 
.................... #define OFF_PWR_PWM output_low(SD_PIN) 
.................... //Time Pwm  
.................... #define TIME_PWM 12500 
....................  
.................... #define POL_PERIOD (TIME_PWM>>1) 
.................... #define POL_POL_PERIOD (POL_PERIOD>>1) 
....................  
....................  
.................... // начальная настройка  
.................... void initPWM(); 
.................... //поворот  
.................... void rotate();  
.................... // включение, отключение силовой части   
.................... void onOffPWMCanal(int1 b);  
.................... // установка нового значения с АЦП до которого будет осуществлен поворот   
.................... void setPwm3456(int16 pwm3, int16 pwm4, int16 pwm5, int16 pwm6, int8 blenk); 
.................... void setPwm3(int16 data);  
.................... void setPwm4(int16 data);  
.................... void setPwm5(int16 data);  
.................... void setPwm6(int16 data);  
.................... // управление бленкерами  
.................... void setRk(int8 data); 
.................... // установить выводы согласно нового значения  
.................... void updateRk();  
....................  
.................... // test 
.................... //int8 canalPwm = 0;  
.................... //int16 dataCanal3 = 0;  
.................... //int1 enabRegul = 0;  
....................  
....................  
....................  
....................  
....................   
....................  
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "AZP.h" 
.................... #ifndef AZP_H 
.................... #define AZP_H 
....................  
.................... #include "ADC.h" 
....................  
.................... //ADC INPUT 
.................... #define AV1 PIN_B2  //AN2 
.................... #define AV2 PIN_B3  //AN3 
.................... #define AV3 PIN_B13 //AN13 
.................... #define AV4 PIN_B14 //AN14 
....................  
.................... #define SIZE_DMA_ADC_BUF 4 
.................... #BANK_DMA  
.................... static volatile int16 dmaAdcBuf[SIZE_DMA_ADC_BUF]; 
....................  
.................... int1 dmaAdcFlag = 0;   
....................  
.................... int16 valAdc1 = 0;  
.................... int16 valAdc2 = 0;  
.................... int16 valAdc3 = 0;  
.................... int16 valAdc4 = 0;  
....................  
....................  
.................... void clearAdcDmaBuf(); 
.................... void initAdcDma();   
.................... void initADC();  
.................... void readDmaAdc(); 
....................  
.................... //int1 tempDma = 0;  
....................  
....................  
....................  
....................   
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define TIME_TEST_ADC_PWM 31250  //200ms 
.................... #define MAX_COUNT_ZIKL_WAIT 200 
....................  
.................... #define ERROR_WAIT (1<<4) 
.................... #define ACCURACY_ADC 0xFFF0 
....................  
.................... #define SK_VAL1_UP 250 
.................... #define SK_VAL2_UP (POL_PERIOD + SK_VAL1_UP) 
.................... #define SK_VAL1_DW (TIME_PWM-SK_VAL1_UP) 
.................... #define SK_VAL2_DW (POL_PERIOD-(TIME_PWM-SK_VAL1_DW)) 
.................... //states  
.................... #define S0  0x0000 
.................... #define S1  0x0001 
.................... #define S2  0x0002 
.................... #define S3  0x0004 
.................... #define S4  0x0008 
.................... #define S5  0x0010 
.................... #define S6  0x0020 
.................... #define S7  0x0040 
.................... #define S8  0x0080 
.................... #define S9  0x0100 
.................... #define S10 0x0200 
....................  
.................... // граничные значения с АЦП при нахождении указателей 
.................... // в максимальном и минимальном положени по шкале 
.................... //min  
.................... int16 minAdc1 = 0;  
.................... int16 minAdc2 = 0;  
.................... int16 minAdc3 = 0;  
.................... int16 minAdc4 = 0;  
.................... //max 
.................... int16 maxAdc1 = 0;  
.................... int16 maxAdc2 = 0;  
.................... int16 maxAdc3 = 0;  
.................... int16 maxAdc4 = 0;  
....................  
.................... #define SIZE_TEMP_ADC 4 
.................... int16 tempValADC11[SIZE_TEMP_ADC] = {0,0,0,0};  
.................... int16 tempValADC12[SIZE_TEMP_ADC] = {0,0,0,0}; 
.................... int16 tempValADC13[SIZE_TEMP_ADC] = {0,0,0,0}; 
.................... int16 tempValADC14[SIZE_TEMP_ADC] = {0,0,0,0}; 
....................  
.................... int16 readValADC11 = 0;  
.................... int16 readValADC12 = 0; 
.................... int16 readValADC21 = 0; 
.................... int16 readValADC22 = 0; 
.................... int16 readValADC31 = 0; 
.................... int16 readValADC32 = 0; 
.................... int16 readValADC41 = 0; 
.................... int16 readValADC42 = 0; 
....................  
.................... int8 errorRotate = 0; 
....................  
.................... int16 currentStateAvt = 0;  
.................... int16 oldStateAvt = 0;  
.................... int16 newStateAvt = 0;  
.................... int1 enabSendCalibrData = 0;   
.................... int1 endCalibrMotor = 0;  
....................  
.................... void setPositionEndCalibr(); 
....................  
.................... void initAvtomat();  
.................... void startAvtomatCalibr();  
.................... void startTimer7();  
.................... void resetCountZikl();  
.................... void resetAvtomat();  
.................... void updateState();  
.................... void readData1Adc();  
.................... void readData2Adc();  
.................... void sravnData(); 
.................... void setEnableSendData();   
.................... void sendDataCalibr();  
.................... void stopTimer7(); 
.................... void setRotatePwm(int1 b);  
.................... int1 waitStop();  
.................... void sendState( );  
....................  
.................... int16 ziklReadCalibr = 0; 
.................... int16 indexDataRead = 0;     
....................  
....................  
.................... int1 getFullMasCalibr(int16 a, int16 b, int16 c, int16 d);  
....................  
....................  
.................... int1 debugRS = 0;  
.................... void setDebugRS(); 
....................  
.................... #endif 
....................  
.................... #include "motor.h" 
.................... #ifndef MOTOR_H 
.................... #define MOTOR_H 
....................  
.................... //#define MIN_ERROR  2.0f // минимальная ошибка для доворота  
....................  
.................... #define MIN_DADC 0x00FF //минимальная разница между граничными значениями АЦП 
....................  
.................... // Error 
.................... // bits 
.................... #define END_CALIBR    0x80 // флаг окончания калибровки 
.................... #define ERROR_CLBR   0x40 // вышло время калибровки, значения не прочитались 
.................... #define ERR_PWR_ANALOG_ON (0x20) // силовая часть включена 
.................... #define ERR_PWR_KZ    	   (0x10) // замыкание силовой части  
.................... #define ERR_DADC      0x08 //(dADC<MIN_ADC) // мотор не крутится положение макс и мин ацп менее MIN_DADC  
.................... #define ERR_VADC2_B   0x04 //vAdc1<vAdc2 // определяет верх и низ 
.................... #define ERR_VADC1_B   0x02 //vAdc1>vAdc2 // определяет верх и низ 
.................... #define ERR_VADC_RAVN 0x01 //vAdc1=vAdc2 // калибровки не было  
.................... //#define MAX_INT_ERROR 50     
.................... //#define MIN_INT_ERROR (-50)  
....................  
....................  
.................... typedef struct MotorAs 
.................... { 
.................... 	int canalPwm;  // пин ШИМ 
.................... 	int1 upValue; //флаг направления движения, вводит относительный верх и  низ у нескольких моторов 
.................... 	int16 minValAdc; //минимальное значение ацп на одном краю шкалы 
.................... 	int16 maxValAdc; //максимальное значение ацп на другом краю шкалы 
.................... 	int16 oldValAdc; // прошлое значение используемое для установки  
.................... 	int16 newValue; // новое значение в которое необходимо перейти стрелке 
.................... 	float dAdc; 	// разность макс и мин значения АЦП 
.................... 	float kP;  // 	(m->maxSpeed/m->dAdc) где (m->maxSpeed = POL_POL_PERIOD(default)) знач ШИМ для макс  
.................... 				//скорости(1/4Шим(90градусов сдвиг между каналами ШИМ))))  
.................... 				// и m->dAdc диапазон шкалы в значениях АЦП 
.................... 	float kD;  
.................... 	float kI;  
.................... 	int8 Error;    // хранит ошибки и текущее состояние  
.................... 	int16 minSpeed; // минимальное значение ШИМ при котором стрелка двигается 
.................... 	int16 maxSpeed; // максимальное значение ШИМ при котором стрелка двигается (1/4 значения счетчика ШИМ) 
.................... 	int16 maxAccel; // максимальное ускорение 
.................... 	int16 minAccel; // минимальное ускорение  
.................... 	int16 oldSpeed; // значение скорости в прошлый перерасчет положения 
.................... 	int1 enabRotate; // разрешение вращения  
.................... 	signed int maxIEr; // максимальная ошибка интегр. сост  
.................... 	signed int minIEr; // минимальная ошибка интегр. сост 
.................... 	signed int integrError; 
.................... } Motor;  
....................  
....................   
....................   
.................... void initMotor(Motor * m, int cPwm, int16 tPwm, int16 vAdc1, int16 vAdc2);  
.................... void setLimitAdcMotor(Motor *m, int16 vAdc1, int16 vAdc2); 
.................... void setMinSpeed(Motor *m,int16 data);  
.................... void setMaxSpeed(Motor *m,int16 data);     
.................... void setRotate(Motor *m, int16 currentData, int16 newData);  
.................... int16 difSost(Motor *m, float data);  
.................... int16 intSost(Motor *m, int1 dir, float data);  
.................... int16 proSost(Motor *m, int16 data, float eData);  
.................... void setNewValueMotor (Motor *m, int16 data);  
.................... void setK(Motor *m); 
.................... void setMaxAccel(Motor *m, int16 data);   
....................  
.................... void setIntError(Motor *m,signed int minE, signed int maxE); 
.................... void setOrError(Motor *m, int8 data);  
.................... void setAndError(Motor *m, int8 data);  
.................... //void setError(Motor *m, int8 data);  
.................... void updateError(Motor *m); 
.................... //void setMinRotate(int16 min_error);   
....................  
.................... //get setting motor 
.................... int16 getMinSpeed(Motor *m);  
.................... int16 getMaxSpeed(Motor *m);  
.................... int16 getMinAccel(Motor *m);  
.................... int16 getMaxAccel(Motor *m);  
.................... int8  getError(Motor *m);  
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... //PWM OUTPUT 
.................... #define CANAL1_PWM PIN_D0 
.................... #define CANAL2_PWM PIN_D1 
.................... #define CANAL3_PWM PIN_D2 
.................... #define CANAL4_PWM PIN_D3 
.................... #define CANAL5_PWM PIN_D4 
.................... #define CANAL6_PWM PIN_D5 
....................  
....................  
.................... #define PIN_BLENK1 PIN_F0 
.................... #define PIN_BLENK2 PIN_F1  
.................... #define BLENK1_ON  output_low(PIN_BLENK1);  
.................... #define BLENK1_OFF output_high(PIN_BLENK1);  
.................... #define BLENK2_ON  output_low(PIN_BLENK2);  
.................... #define BLENK2_OFF output_high(PIN_BLENK2); 
....................  
....................  
....................  
.................... Motor m3;  
.................... Motor m4;  
.................... Motor m5;  
.................... Motor m6;  
....................  
.................... int16 newValueM3 = 0;  
.................... int16 newValueM4 = 0;  
.................... int16 newValueM5 = 0;  
.................... int16 newValueM6 = 0;  
.................... int8  newValueRk = 0;  
.................... //ENAB POWER PWM 
.................... #define SD_PIN PIN_G15 // shutdown IR2014S 
.................... #define ON_PWR_PWM output_high(SD_PIN) 
.................... #define OFF_PWR_PWM output_low(SD_PIN) 
.................... //Time Pwm  
.................... #define TIME_PWM 12500 
....................  
.................... #define POL_PERIOD (TIME_PWM>>1) 
.................... #define POL_POL_PERIOD (POL_PERIOD>>1) 
....................  
....................  
.................... // начальная настройка  
.................... void initPWM(); 
.................... //поворот  
.................... void rotate();  
.................... // включение, отключение силовой части   
.................... void onOffPWMCanal(int1 b);  
.................... // установка нового значения с АЦП до которого будет осуществлен поворот   
.................... void setPwm3456(int16 pwm3, int16 pwm4, int16 pwm5, int16 pwm6, int8 blenk); 
.................... void setPwm3(int16 data);  
.................... void setPwm4(int16 data);  
.................... void setPwm5(int16 data);  
.................... void setPwm6(int16 data);  
.................... // управление бленкерами  
.................... void setRk(int8 data); 
.................... // установить выводы согласно нового значения  
.................... void updateRk();  
....................  
.................... // test 
.................... //int8 canalPwm = 0;  
.................... //int16 dataCanal3 = 0;  
.................... //int1 enabRegul = 0;  
....................  
....................  
....................  
....................  
....................   
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... void initPWM() 
.................... { 
.................... 	onOffPWMCanal(0);  
*
0AB0:  CLR.B   980
0AB2:  CALL    932
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_8, TIME_PWM); 
0AB6:  CLR     112
0AB8:  MOV     #30D4,W4
0ABA:  MOV     W4,10E
0ABC:  MOV     #8010,W4
0ABE:  MOV     W4,112
.................... 	setup_compare( 1,COMPARE_CONT_PULSE | COMPARE_TIMER3); 
0AC0:  MOV     #D,W4
0AC2:  MOV     W4,184
.................... 	setup_compare( 2,COMPARE_CONT_PULSE | COMPARE_TIMER3); 
0AC4:  MOV     #D,W4
0AC6:  MOV     W4,18A
.................... 	setup_compare( 3,COMPARE_CONT_PULSE | COMPARE_TIMER3 ); 
0AC8:  MOV     #D,W4
0ACA:  MOV     W4,190
.................... 	setup_compare( 4,COMPARE_CONT_PULSE | COMPARE_TIMER3 ); 
0ACC:  MOV     #D,W4
0ACE:  MOV     W4,196
.................... 	setup_compare( 5,COMPARE_CONT_PULSE | COMPARE_TIMER3 ); 
0AD0:  MOV     #D,W4
0AD2:  MOV     W4,19C
.................... 	setup_compare( 6,COMPARE_CONT_PULSE | COMPARE_TIMER3 ); 
0AD4:  MOV     #D,W4
0AD6:  MOV     W4,1A2
.................... 	set_compare_time(1, 0, POL_PERIOD); 
0AD8:  CLR     182
0ADA:  MOV     #186A,W4
0ADC:  MOV     W4,180
.................... 	set_compare_time(2, POL_PERIOD, 0); 
0ADE:  MOV     #186A,W4
0AE0:  MOV     W4,188
0AE2:  CLR     186
.................... 	set_compare_time(3, 0,POL_PERIOD); //3125, 9375); 
0AE4:  CLR     18E
0AE6:  MOV     #186A,W4
0AE8:  MOV     W4,18C
.................... 	set_compare_time(4, 0,POL_PERIOD);//3125, 9375); 
0AEA:  CLR     194
0AEC:  MOV     #186A,W4
0AEE:  MOV     W4,192
.................... 	set_compare_time(5, 0,POL_PERIOD); //9375, 3125); 
0AF0:  CLR     19A
0AF2:  MOV     #186A,W4
0AF4:  MOV     W4,198
.................... 	set_compare_time(6, 0,POL_PERIOD);//3125, 9375); 
0AF6:  CLR     1A0
0AF8:  MOV     #186A,W4
0AFA:  MOV     W4,19E
.................... 	 
....................  
.................... 	initMotor(&m3, 3, TIME_PWM, 0, 0);  
0AFC:  MOV     #858,W4
0AFE:  MOV     W4,940
0B00:  MOV     #3,W4
0B02:  MOV     W4,942
0B04:  MOV     #30D4,W4
0B06:  MOV     W4,944
0B08:  CLR     946
0B0A:  CLR     948
0B0C:  CALL    9D2
.................... 	initMotor(&m4, 4, TIME_PWM, 0, 0);  
0B10:  MOV     #888,W4
0B12:  MOV     W4,940
0B14:  MOV     #4,W4
0B16:  MOV     W4,942
0B18:  MOV     #30D4,W4
0B1A:  MOV     W4,944
0B1C:  CLR     946
0B1E:  CLR     948
0B20:  CALL    9D2
.................... 	initMotor(&m5, 5, TIME_PWM, 0, 0);  
0B24:  MOV     #8B8,W4
0B26:  MOV     W4,940
0B28:  MOV     #5,W4
0B2A:  MOV     W4,942
0B2C:  MOV     #30D4,W4
0B2E:  MOV     W4,944
0B30:  CLR     946
0B32:  CLR     948
0B34:  CALL    9D2
.................... 	initMotor(&m6, 6, TIME_PWM, 0, 0); 	 
0B38:  MOV     #8E8,W4
0B3A:  MOV     W4,940
0B3C:  MOV     #6,W4
0B3E:  MOV     W4,942
0B40:  MOV     #30D4,W4
0B42:  MOV     W4,944
0B44:  CLR     946
0B46:  CLR     948
0B48:  CALL    9D2
0B4C:  RETURN  
.................... } 
....................  
....................  
....................  
.................... void rotate() 
.................... { 
.................... 	if(endCalibrMotor) 
*
21D4:  BTSS.B  803.6
21D6:  BRA     2242
.................... 	{ 
.................... 		//output_low(PIN_G0); 
.................... 		for(int i = 3; i<7; i++) 
21D8:  MOV     #3,W4
21DA:  MOV     W4,940
21DC:  MOV     940,W4
21DE:  CP      W4,#7
21E0:  BRA     GE,2242
.................... 		{ 
.................... 			switch(i) 
21E2:  MOV     940,W0
21E4:  XOR     #3,W0
21E6:  BRA     Z,21F6
21E8:  XOR     #7,W0
21EA:  BRA     Z,2208
21EC:  XOR     #1,W0
21EE:  BRA     Z,221A
21F0:  XOR     #3,W0
21F2:  BRA     Z,222C
21F4:  BRA     223E
.................... 			{ 
.................... 				case 3: {setRotate(&m3, valAdc1, newValueM3); break;} 
21F6:  MOV     #858,W4
21F8:  MOV     W4,942
21FA:  PUSH    804
21FC:  POP     944
21FE:  PUSH    918
2200:  POP     946
2202:  CALL    1E84
2206:  BRA     223E
.................... 				case 4: {setRotate(&m4, valAdc2, newValueM4); break;} 
2208:  MOV     #888,W4
220A:  MOV     W4,942
220C:  PUSH    806
220E:  POP     944
2210:  PUSH    91A
2212:  POP     946
2214:  CALL    1E84
2218:  BRA     223E
.................... 				case 5: {setRotate(&m5, valAdc3, newValueM5); break;} 
221A:  MOV     #8B8,W4
221C:  MOV     W4,942
221E:  PUSH    808
2220:  POP     944
2222:  PUSH    91C
2224:  POP     946
2226:  CALL    1E84
222A:  BRA     223E
.................... 				case 6: {setRotate(&m6, valAdc4, newValueM6); break;} 
222C:  MOV     #8E8,W4
222E:  MOV     W4,942
2230:  PUSH    80A
2232:  POP     944
2234:  PUSH    91E
2236:  POP     946
2238:  CALL    1E84
223C:  BRA     223E
.................... 				default: {} 
.................... 			} 
223E:  INC     0940
2240:  BRA     21DC
.................... 		} 
.................... 		//output_high(PIN_G0);	 
.................... 	} 
2242:  RETURN  
.................... } 
....................  
....................  
.................... void onOffPWMCanal(int1 b) 
.................... { 
.................... 	 
.................... 	if(b==0) 
*
0932:  CP0.B   980
0934:  BRA     NZ,96C
.................... 	{ 
.................... 		OFF_PWR_PWM; 
0936:  BCLR.B  2E5.7
0938:  BCLR.B  2E9.7
.................... 		setAndError(&m3, ERR_PWR_ANALOG_ON); 
093A:  MOV.B   #20,W0L
093C:  MOV.B   W0L,984
093E:  MOV     #858,W4
0940:  MOV     W4,982
0942:  CALL    8F4
.................... 		setAndError(&m4, ERR_PWR_ANALOG_ON); 
0946:  MOV.B   #20,W0L
0948:  MOV.B   W0L,984
094A:  MOV     #888,W4
094C:  MOV     W4,982
094E:  CALL    8F4
.................... 		setAndError(&m5, ERR_PWR_ANALOG_ON); 
0952:  MOV.B   #20,W0L
0954:  MOV.B   W0L,984
0956:  MOV     #8B8,W4
0958:  MOV     W4,982
095A:  CALL    8F4
.................... 		setAndError(&m6, ERR_PWR_ANALOG_ON); 
095E:  MOV.B   #20,W0L
0960:  MOV.B   W0L,984
0962:  MOV     #8E8,W4
0964:  MOV     W4,982
0966:  CALL    8F4
.................... 	} 
096A:  BRA     9D0
.................... 	else 
.................... 	{ 
.................... 		 
.................... 		ON_PWR_PWM; 
096C:  BCLR.B  2E5.7
096E:  BSET.B  2E9.7
.................... 		setOrError(&m3, ERR_PWR_ANALOG_ON); 
0970:  MOV.B   #20,W0L
0972:  MOV.B   W0L,984
0974:  MOV     #858,W4
0976:  MOV     W4,982
0978:  CALL    914
.................... 		setOrError(&m4, ERR_PWR_ANALOG_ON); 
097C:  MOV.B   #20,W0L
097E:  MOV.B   W0L,984
0980:  MOV     #888,W4
0982:  MOV     W4,982
0984:  CALL    914
.................... 		setOrError(&m5, ERR_PWR_ANALOG_ON); 
0988:  MOV.B   #20,W0L
098A:  MOV.B   W0L,984
098C:  MOV     #8B8,W4
098E:  MOV     W4,982
0990:  CALL    914
.................... 		setOrError(&m6, ERR_PWR_ANALOG_ON); 
0994:  MOV.B   #20,W0L
0996:  MOV.B   W0L,984
0998:  MOV     #8E8,W4
099A:  MOV     W4,982
099C:  CALL    914
.................... 		setAndError(&m3, ERR_PWR_KZ); 
09A0:  MOV.B   #10,W0L
09A2:  MOV.B   W0L,984
09A4:  MOV     #858,W4
09A6:  MOV     W4,982
09A8:  CALL    8F4
.................... 		setAndError(&m4, ERR_PWR_KZ); 
09AC:  MOV.B   #10,W0L
09AE:  MOV.B   W0L,984
09B0:  MOV     #888,W4
09B2:  MOV     W4,982
09B4:  CALL    8F4
.................... 		setAndError(&m5, ERR_PWR_KZ); 
09B8:  MOV.B   #10,W0L
09BA:  MOV.B   W0L,984
09BC:  MOV     #8B8,W4
09BE:  MOV     W4,982
09C0:  CALL    8F4
.................... 		setAndError(&m6, ERR_PWR_KZ); 
09C4:  MOV.B   #10,W0L
09C6:  MOV.B   W0L,984
09C8:  MOV     #8E8,W4
09CA:  MOV     W4,982
09CC:  CALL    8F4
.................... 	}  
09D0:  RETURN  
.................... 	 
.................... } 
....................   
.................... void setPwm3456(int16 pwm3, int16 pwm4, int16 pwm5, int16 pwm6, int8 rk) 
.................... { 
.................... 	 setPwm3(pwm3);   
*
1344:  PUSH    97E
1346:  POP     990
1348:  CALL    1208
.................... 	 setPwm4(pwm4);  
134C:  PUSH    980
134E:  POP     990
1350:  CALL    1240
....................      setPwm5(pwm5);  
1354:  PUSH    982
1356:  POP     990
1358:  CALL    1278
....................      setPwm6(pwm6);  
135C:  PUSH    984
135E:  POP     990
1360:  CALL    12B0
....................      setRk(rk);  
1364:  MOV.B   986,W0L
1366:  MOV.B   W0L,990
1368:  CALL    1312
136C:  RETURN  
.................... } 
....................  
.................... void setPwm3(int16 data) 
.................... { 
.................... 	newValueM3 = data;  
*
1208:  PUSH    990
120A:  POP     918
120C:  RETURN  
.................... }  
.................... void setPwm4(int16 data)  
.................... { 
.................... 	newValueM4 = data;  
*
1240:  PUSH    990
1242:  POP     91A
1244:  RETURN  
.................... }  
.................... void setPwm5(int16 data) 
.................... { 
.................... 	newValueM5 = data;  
*
1278:  PUSH    990
127A:  POP     91C
127C:  RETURN  
.................... }  
.................... void setPwm6(int16 data) 
.................... { 
.................... 	newValueM6 = data;   
*
12B0:  PUSH    990
12B2:  POP     91E
12B4:  RETURN  
.................... }  
.................... void setRk(int8 data) 
.................... { 
.................... 	newValueRk = data;  
*
1312:  MOV.B   990,W0L
1314:  MOV.B   W0L,84D
.................... 	updateRk();  
1316:  CALL    12E8
131A:  RETURN  
.................... } 
....................  
....................  
.................... void updateRk() 
.................... { 
.................... 	if((newValueRk&0x01)) 
*
12E8:  MOV.B   84D,W0L
12EA:  SE      W0,W0
12EC:  AND     W0,#1,W0
12EE:  CP0     W0
12F0:  BRA     Z,12F8
.................... 	{ 
.................... 		BLENK2_ON;  
12F2:  BCLR.B  2DE.1
12F4:  BCLR.B  2E2.1
.................... 	} 
12F6:  BRA     12FC
.................... 	else 
.................... 	{ 
.................... 		BLENK2_OFF;  
12F8:  BCLR.B  2DE.1
12FA:  BSET.B  2E2.1
.................... 	} 
.................... 	 
.................... 	if((newValueRk&0x10)) 
12FC:  MOV.B   84D,W0L
12FE:  SE      W0,W0
1300:  AND     W0,#10,W0
1302:  CP0     W0
1304:  BRA     Z,130C
.................... 	{ 
.................... 		BLENK1_ON;  
1306:  BCLR.B  2DE.0
1308:  BCLR.B  2E2.0
.................... 	} 
130A:  BRA     1310
.................... 	else 
.................... 	{ 
.................... 		BLENK1_OFF;  
130C:  BCLR.B  2DE.0
130E:  BSET.B  2E2.0
.................... 	} 
1310:  RETURN  
.................... 	 
.................... } 
....................  
....................  
.................... #include "RS485.c"    //timer4, uart1 
.................... #include "RS485.h"  
.................... #ifndef RS485_H 
.................... #define RS485_H 
....................  
....................  
....................  
.................... #define ENABLE PIN_F6 
....................  
.................... int indW = 0;  
....................  
.................... #define SIZE_RS_BUFFER 24 
.................... #define RELOAD_INDW  22// SIZE_RS_BUFFER - 2   
....................  
.................... int8  buffer[SIZE_RS_BUFFER] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
....................  
.................... int1 FLAG = 0;  
.................... int16 pause = 47;/*115200/80MHZ*/ //35;/*115200/60MHz*/  
....................  
....................  
.................... void pause3_5RS();  
.................... void sendRS( int8 msg);  
.................... void sendRS16( int8 msg); 
.................... void initRS();  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... //***************************************************************** 
.................... //* инициализация  
.................... //***************************************************************** 
.................... void initRS() 
.................... { 
.................... 	enable_interrupts(INT_RDA); 
*
07AC:  BSET.B  95.3
07AE:  RETURN  
.................... } 
....................  
.................... #INT_RDA 
.................... void interruptRS() 
*
02BC:  PUSH    42
02BE:  PUSH    36
02C0:  PUSH    32
02C2:  MOV     W0,[W15++]
02C4:  MOV     #2,W0
02C6:  REPEAT  #C
02C8:  MOV     [W0++],[W15++]
.................... { 
.................... 	buffer[indW] = getc(); 
02CA:  MOV     #922,W4
02CC:  MOV     920,W3
02CE:  ADD     W3,W4,W5
02D0:  CALL    29A
02D4:  MOV.B   W0L,[W5]
.................... 	 
.................... 	indW++; 
02D6:  INC     0920
.................... 	 
.................... 	if(indW>RELOAD_INDW) 
02D8:  MOV     920,W4
02DA:  CP      W4,#16
02DC:  BRA     LE,2E0
.................... 	{ 
.................... 		indW = 0;  
02DE:  CLR     920
.................... 	} 
.................... 	clear_interrupt(INT_RDA); 
02E0:  REPEAT  #3
02E2:  MOV     226,W0
02E4:  BCLR.B  85.3
.................... 	 
.................... 	pause3_5RS(); 
02E6:  CALL    2A8
.................... 	 
.................... 	 
02EA:  BCLR.B  85.3
02EC:  MOV     #1A,W0
02EE:  REPEAT  #C
02F0:  MOV     [--W15],[W0--]
02F2:  MOV     [--W15],W0
02F4:  POP     32
02F6:  POP     36
02F8:  POP     42
02FA:  RETFIE  
.................... } 
....................  
.................... //***************************************************************** 
.................... //* пауза в 3,5 символа  
.................... //***************************************************************** 
....................  
.................... void pause3_5RS() 
.................... { 
.................... 	setup_timer4(TMR_DISABLED); 
*
02A8:  CLR     11E
....................     clear_interrupt(INT_TIMER4); 
02AA:  BCLR.B  87.3
.................... 	set_timer4(0); 	  
02AC:  CLR     114
.................... 	setup_timer4(TMR_INTERNAL|TMR_DIV_BY_256, pause );/// 
02AE:  CLR     11E
02B0:  PUSH    93C
02B2:  POP     11A
02B4:  MOV     #8030,W4
02B6:  MOV     W4,11E
.................... 	enable_interrupts(int_timer4); 
02B8:  BSET.B  97.3
02BA:  RETURN  
.................... //	output_high(PIN_G13); 
.................... 	//3.8mS 
....................  
.................... } 
.................... //**************************************************************** 
.................... // таймер расчета паузы в 3.5 символа  
.................... //**************************************************************** 
....................  
.................... #int_timer4 //  
.................... void __timer4_isr__(void) 
*
02FC:  PUSH    42
02FE:  PUSH    36
0300:  PUSH    32
0302:  MOV     W0,[W15++]
0304:  MOV     #2,W0
0306:  REPEAT  #C
0308:  MOV     [W0++],[W15++]
.................... { 
.................... 	 //1.6ms 
.................... //	output_low(PIN_G13); 
.................... 	setup_timer4(TMR_DISABLED); 
030A:  CLR     11E
.................... 	clear_interrupt(INT_TIMER4); 
030C:  BCLR.B  87.3
.................... 	FLAG = TRUE;  
030E:  BSET.B  93A.0
....................     set_timer4(0);  
0310:  CLR     114
.................... 	//1.6ms 
.................... 	 
0312:  BCLR.B  87.3
0314:  MOV     #1A,W0
0316:  REPEAT  #C
0318:  MOV     [--W15],[W0--]
031A:  MOV     [--W15],W0
031C:  POP     32
031E:  POP     36
0320:  POP     42
0322:  RETFIE  
.................... } 
....................  
.................... //**************************************************************** 
.................... // вывод  RS 
.................... //*************************************************************** 
....................  
.................... void sendRS( int8 msg) 
.................... { 
....................  
.................... 	output_high(ENABLE); 
*
14B8:  BCLR.B  2DE.6
14BA:  BSET.B  2E2.6
.................... 	while(MCU_UTXBF);  
14BC:  BTSC.B  223.1
14BE:  BRA     14BC
.................... 	MCU_U1TXREG = msg;   
14C0:  MOV.B   97E,W0L
14C2:  SE      W0,W0
14C4:  MOV     W0,224
.................... 	#asm nop #endasm 
14C6:  NOP     
.................... 	while(!MCU_TRMT);  
14C8:  BTSS.B  223.0
14CA:  BRA     14C8
.................... 	output_low(ENABLE);  
14CC:  BCLR.B  2DE.6
14CE:  BCLR.B  2E2.6
14D0:  RETURN  
.................... } 
....................  
....................  
.................... void sendRS16( int16 msg) 
.................... { 
....................  
.................... 	output_high(ENABLE); 
.................... 	while(MCU_UTXBF);  
.................... 	MCU_U1TXREG = ((msg>>8)&0xFF);   
.................... 	#asm nop #endasm 
.................... 	while(!MCU_TRMT);  
....................  
.................... 	while(MCU_UTXBF);  
.................... 	MCU_U1TXREG = (msg&0xFF);   
.................... 	#asm nop #endasm 
.................... 	while(!MCU_TRMT);  
.................... 	output_low(ENABLE);  
.................... } 
....................  
....................  
.................... #include "DMA_RS.c"   // DMA0 
.................... #define SIZE_DMA_BUF 24 
.................... #define PIN_RS_SEND PIN_F6 
.................... int1 dmaBusy = 0;  
.................... // ответы по RS 
.................... void ansComSetPwmRk(int8 canal, int16 p3, int16 p4, int16 p5, int16 p6, int8 rk);  
.................... void ansComSetPwm3(int8 canal, int16 p3 );   
.................... void ansComSetPwm4(int8 canal, int16 p4);   
.................... void ansComSetPwm5(int8 canal, int16 p5);   
.................... void ansComSetPwm6(int8 canal, int16 p6);   
.................... void ansComSetRk(int8 canal, int8 rk);  
.................... void ansComReadSpeed();  
.................... void ansComRunCalibr();  
....................  
.................... void ansComLimitAdc(int16 minAdc1,int16 minAdc2,int16 minAdc3,int16 minAdc4, int16 maxAdc1,int16 maxAdc2, int16 maxAdc3,int16 maxAdc4); 
.................... void ansComReadCurAdc(int16 a1, int16 a2, int16 a3, int16 a4); 
.................... void ansComOnOffPwm(int8 data);  
.................... void ansComSetSpeedPwm(int16 canal, int16 speedMin, int16 speedMax); 
.................... void ansComSetSpeedAllPwm(int16 can, int16 sMn3, int16 sMx3, int16 sMn4, int16 sMx4, int16 sMn5, int16 sMx5, int16 sMn6, int16 sMx6 );  
.................... void ansComReadError(int8 d1, int8 d2, int8 d3, int8 d4); 
....................  
.................... void ansReadCrc(int16 crc);  
.................... void ansComInfo();  
.................... void ansComId();  
.................... void ansComRst(int8 com, int8 data);  
.................... void ansErrorCom(int8 com);  
....................  
....................  
....................  
.................... #BANK_DMA 
.................... static volatile byte dmaBuffer[SIZE_DMA_BUF];  
....................  
.................... void clearDmaBuf()  
.................... { 
.................... 	memset(dmaBuffer, 0x00, sizeof(dmaBuffer));  
*
07B0:  MOV     #2008,W1
07B2:  MOV     #0,W2
07B4:  REPEAT  #17
07B6:  CLR.B   [W1++]
.................... 	dmaBusy = 0;  
07B8:  BCLR.B  93A.1
.................... 	dmaBuffer[0] = adress; 
07BA:  MOV.B   802,W0L
07BC:  PUSH    2008
07BE:  MOV.B   W0L,[W15-#2]
07C0:  POP     2008
07C2:  RETURN  
.................... } 
....................  
.................... void initDma() 
.................... { 
.................... 	clearDmaBuf();  
07C4:  CALL    7B0
.................... 	enable_interrupts(INT_DMA0); 
07C8:  BSET.B  94.4
.................... 	setup_dma(0, DMA_OUT_UART1, DMA_BYTE); 
07CA:  MOV.B   #60,W0L
07CC:  MOV.B   W0L,381
07CE:  MOV.B   #C,W0L
07D0:  MOV.B   W0L,382
07D2:  MOV     #224,W4
07D4:  MOV     W4,388
.................... 	output_low(PIN_RS_SEND); 
07D6:  BCLR.B  2DE.6
07D8:  BCLR.B  2E2.6
07DA:  RETURN  
.................... } 
....................  
.................... void sendInRsDma(int len) 
.................... { 
.................... 	dmaBusy = 1;  
*
0BC4:  BSET.B  93A.1
.................... 	output_high(PIN_RS_SEND); 
0BC6:  BCLR.B  2DE.6
0BC8:  BSET.B  2E2.6
.................... 	dma_start(0, DMA_ONE_SHOT|DMA_FORCE_NOW, dmaBuffer, len );  
0BCA:  BCLR.B  381.7
0BCC:  MOV.B   #1,W0L
0BCE:  MOV.B   W0L,380
0BD0:  MOV     #2008,W4
0BD2:  MOV     W4,384
0BD4:  PUSH    9A2
0BD6:  POP     38A
0BD8:  BSET.B  381.7
0BDA:  BSET.B  383.7
0BDC:  RETURN  
.................... } 
....................  
.................... #INT_DMA0 
.................... void DMAInterrupts() 
*
0324:  PUSH    42
0326:  PUSH    36
0328:  PUSH    32
032A:  MOV     W0,[W15++]
032C:  MOV     #2,W0
032E:  REPEAT  #C
0330:  MOV     [W0++],[W15++]
.................... { 
.................... 	dmaBusy = 0;  
0332:  BCLR.B  93A.1
.................... 	output_low(PIN_RS_SEND); 
0334:  BCLR.B  2DE.6
0336:  BCLR.B  2E2.6
.................... } 
....................  
....................  
0338:  BCLR.B  84.4
033A:  MOV     #1A,W0
033C:  REPEAT  #C
033E:  MOV     [--W15],[W0--]
0340:  MOV     [--W15],W0
0342:  POP     32
0344:  POP     36
0346:  POP     42
0348:  RETFIE  
.................... #INT_DMAERR 
.................... void DmaErrorInterrupt() 
034A:  PUSH    42
034C:  PUSH    36
034E:  PUSH    32
0350:  MOV     W0,[W15++]
0352:  MOV     #2,W0
0354:  REPEAT  #C
0356:  MOV     [W0++],[W15++]
.................... { 
....................     
0358:  BCLR.B  80.5
035A:  MOV     #1A,W0
035C:  REPEAT  #C
035E:  MOV     [--W15],[W0--]
0360:  MOV     [--W15],W0
0362:  POP     32
0364:  POP     36
0366:  POP     42
0368:  RETFIE  
.................... } 
....................  
.................... void ansComLimitAdc(int16 a1,int16 a2,int16 a3,int16 a4, int16 b1,int16 b2, b3,int16 b4) 
.................... { 
.................... 	clearDmaBuf();  
*
10C8:  CALL    7B0
.................... 	dmaBuffer[1]=COM_LIMIT_ADC;  
10CC:  MOV     2008,W0
10CE:  SWAP    W0
10D0:  MOV.B   #41,W0L
10D2:  SWAP    W0
10D4:  MOV     W0,2008
.................... 	dmaBuffer[2]=(a1>>8);  
10D6:  MOV.B   97F,W0L
10D8:  PUSH    200A
10DA:  MOV.B   W0L,[W15-#2]
10DC:  POP     200A
.................... 	dmaBuffer[3]=(a1&0xFF); 
10DE:  MOV     97E,W0
10E0:  AND     #FF,W0
10E2:  PUSH    200A
10E4:  MOV.B   W0L,[W15-#1]
10E6:  POP     200A
.................... 	dmaBuffer[4]=(a2>>8); 
10E8:  MOV.B   981,W0L
10EA:  PUSH    200C
10EC:  MOV.B   W0L,[W15-#2]
10EE:  POP     200C
.................... 	dmaBuffer[5]=(a2&0xFF); 
10F0:  MOV     980,W0
10F2:  AND     #FF,W0
10F4:  PUSH    200C
10F6:  MOV.B   W0L,[W15-#1]
10F8:  POP     200C
.................... 	dmaBuffer[6]=(a3>>8); 
10FA:  MOV.B   983,W0L
10FC:  PUSH    200E
10FE:  MOV.B   W0L,[W15-#2]
1100:  POP     200E
.................... 	dmaBuffer[7]=(a3&0xFF);  
1102:  MOV     982,W0
1104:  AND     #FF,W0
1106:  PUSH    200E
1108:  MOV.B   W0L,[W15-#1]
110A:  POP     200E
.................... 	dmaBuffer[8]=(a4>>8); 
110C:  MOV.B   985,W0L
110E:  PUSH    2010
1110:  MOV.B   W0L,[W15-#2]
1112:  POP     2010
.................... 	dmaBuffer[9]=(a4&0xFF);  
1114:  MOV     984,W0
1116:  AND     #FF,W0
1118:  PUSH    2010
111A:  MOV.B   W0L,[W15-#1]
111C:  POP     2010
.................... 	dmaBuffer[10]=(b1>>8);  
111E:  MOV.B   987,W0L
1120:  PUSH    2012
1122:  MOV.B   W0L,[W15-#2]
1124:  POP     2012
.................... 	dmaBuffer[11]=(b1&0xFF); 
1126:  MOV     986,W0
1128:  AND     #FF,W0
112A:  PUSH    2012
112C:  MOV.B   W0L,[W15-#1]
112E:  POP     2012
.................... 	dmaBuffer[12]=(b2>>8); 
1130:  MOV.B   989,W0L
1132:  PUSH    2014
1134:  MOV.B   W0L,[W15-#2]
1136:  POP     2014
.................... 	dmaBuffer[13]=(b2&0xFF); 
1138:  MOV     988,W0
113A:  AND     #FF,W0
113C:  PUSH    2014
113E:  MOV.B   W0L,[W15-#1]
1140:  POP     2014
.................... 	dmaBuffer[14]=(b3>>8); 
1142:  MOV.B   98B,W0L
1144:  PUSH    2016
1146:  MOV.B   W0L,[W15-#2]
1148:  POP     2016
.................... 	dmaBuffer[15]=(b3&0xFF);  
114A:  MOV     98A,W0
114C:  AND     #FF,W0
114E:  PUSH    2016
1150:  MOV.B   W0L,[W15-#1]
1152:  POP     2016
.................... 	dmaBuffer[16]=(b4>>8); 
1154:  MOV.B   98D,W0L
1156:  PUSH    2018
1158:  MOV.B   W0L,[W15-#2]
115A:  POP     2018
.................... 	dmaBuffer[17]=(b4&0xFF);  
115C:  MOV     98C,W0
115E:  AND     #FF,W0
1160:  PUSH    2018
1162:  MOV.B   W0L,[W15-#1]
1164:  POP     2018
.................... 	sendInRsDma(19); 
1166:  MOV     #13,W4
1168:  MOV     W4,9A2
116A:  CALL    BC4
116E:  RETURN  
....................  
.................... } 
....................  
.................... void ansComSetPwmRk(int8 canal, int16 p3, int16 p4, int16 p5, int16 p6, int8 rk) 
.................... { 
.................... 	clearDmaBuf();  
*
136E:  CALL    7B0
.................... 	dmaBuffer[1]=COM_SET_PWM_RK;  
1372:  MOV     2008,W0
1374:  SWAP    W0
1376:  MOV.B   #31,W0L
1378:  SWAP    W0
137A:  MOV     W0,2008
.................... 	dmaBuffer[2]=canal; 
137C:  MOV.B   97E,W0L
137E:  PUSH    200A
1380:  MOV.B   W0L,[W15-#2]
1382:  POP     200A
.................... 	dmaBuffer[3]=(p3>>8);  
1384:  MOV.B   981,W0L
1386:  PUSH    200A
1388:  MOV.B   W0L,[W15-#1]
138A:  POP     200A
.................... 	dmaBuffer[4]=(p3&0xFF); 
138C:  MOV     980,W0
138E:  AND     #FF,W0
1390:  PUSH    200C
1392:  MOV.B   W0L,[W15-#2]
1394:  POP     200C
.................... 	dmaBuffer[5]=(p4>>8); 
1396:  MOV.B   983,W0L
1398:  PUSH    200C
139A:  MOV.B   W0L,[W15-#1]
139C:  POP     200C
.................... 	dmaBuffer[6]=(p4&0xFF); 
139E:  MOV     982,W0
13A0:  AND     #FF,W0
13A2:  PUSH    200E
13A4:  MOV.B   W0L,[W15-#2]
13A6:  POP     200E
.................... 	dmaBuffer[7]=(p5>>8); 
13A8:  MOV.B   985,W0L
13AA:  PUSH    200E
13AC:  MOV.B   W0L,[W15-#1]
13AE:  POP     200E
.................... 	dmaBuffer[8]=(p5&0xFF);  
13B0:  MOV     984,W0
13B2:  AND     #FF,W0
13B4:  PUSH    2010
13B6:  MOV.B   W0L,[W15-#2]
13B8:  POP     2010
.................... 	dmaBuffer[9]=(p6>>8); 
13BA:  MOV.B   987,W0L
13BC:  PUSH    2010
13BE:  MOV.B   W0L,[W15-#1]
13C0:  POP     2010
.................... 	dmaBuffer[10]=(p6&0xFF);  
13C2:  MOV     986,W0
13C4:  AND     #FF,W0
13C6:  PUSH    2012
13C8:  MOV.B   W0L,[W15-#2]
13CA:  POP     2012
.................... 	dmaBuffer[11]=rk;  
13CC:  MOV.B   97F,W0L
13CE:  PUSH    2012
13D0:  MOV.B   W0L,[W15-#1]
13D2:  POP     2012
.................... 	sendInRsDma(13); 
13D4:  MOV     #D,W4
13D6:  MOV     W4,9A2
13D8:  CALL    BC4
13DC:  RETURN  
.................... }  
.................... void ansComSetPwm3(int8 canal, int16 p3) 
.................... { 
.................... 	clearDmaBuf();  
*
120E:  CALL    7B0
.................... 	dmaBuffer[1]=COM_SET_PWM_RK; 
1212:  MOV     2008,W0
1214:  SWAP    W0
1216:  MOV.B   #31,W0L
1218:  SWAP    W0
121A:  MOV     W0,2008
.................... 	dmaBuffer[2]=canal;  
121C:  MOV.B   97E,W0L
121E:  PUSH    200A
1220:  MOV.B   W0L,[W15-#2]
1222:  POP     200A
.................... 	dmaBuffer[3]=(p3>>8); 
1224:  MOV.B   981,W0L
1226:  PUSH    200A
1228:  MOV.B   W0L,[W15-#1]
122A:  POP     200A
.................... 	dmaBuffer[4]=(p3&0xFF);   
122C:  MOV     980,W0
122E:  AND     #FF,W0
1230:  PUSH    200C
1232:  MOV.B   W0L,[W15-#2]
1234:  POP     200C
.................... 	sendInRsDma(6); 
1236:  MOV     #6,W4
1238:  MOV     W4,9A2
123A:  CALL    BC4
123E:  RETURN  
.................... }   
.................... void ansComSetPwm4(int8 canal, int16 p4) 
.................... { 
.................... 	clearDmaBuf();  
*
1246:  CALL    7B0
.................... 	dmaBuffer[1]=COM_SET_PWM_RK;  
124A:  MOV     2008,W0
124C:  SWAP    W0
124E:  MOV.B   #31,W0L
1250:  SWAP    W0
1252:  MOV     W0,2008
.................... 	dmaBuffer[2]=canal; 
1254:  MOV.B   97E,W0L
1256:  PUSH    200A
1258:  MOV.B   W0L,[W15-#2]
125A:  POP     200A
.................... 	dmaBuffer[3]=(p4>>8); 
125C:  MOV.B   981,W0L
125E:  PUSH    200A
1260:  MOV.B   W0L,[W15-#1]
1262:  POP     200A
.................... 	dmaBuffer[4]=(p4&0xFF);   
1264:  MOV     980,W0
1266:  AND     #FF,W0
1268:  PUSH    200C
126A:  MOV.B   W0L,[W15-#2]
126C:  POP     200C
.................... 	sendInRsDma(6); 
126E:  MOV     #6,W4
1270:  MOV     W4,9A2
1272:  CALL    BC4
1276:  RETURN  
.................... }   
.................... void ansComSetPwm5(int8 canal, int16 p5) 
.................... { 
.................... 	clearDmaBuf();  
*
127E:  CALL    7B0
.................... 	dmaBuffer[1]=COM_SET_PWM_RK;  
1282:  MOV     2008,W0
1284:  SWAP    W0
1286:  MOV.B   #31,W0L
1288:  SWAP    W0
128A:  MOV     W0,2008
.................... 	dmaBuffer[2]=canal; 
128C:  MOV.B   97E,W0L
128E:  PUSH    200A
1290:  MOV.B   W0L,[W15-#2]
1292:  POP     200A
.................... 	dmaBuffer[3]=(p5>>8); 
1294:  MOV.B   981,W0L
1296:  PUSH    200A
1298:  MOV.B   W0L,[W15-#1]
129A:  POP     200A
.................... 	dmaBuffer[4]=(p5&0xFF);   
129C:  MOV     980,W0
129E:  AND     #FF,W0
12A0:  PUSH    200C
12A2:  MOV.B   W0L,[W15-#2]
12A4:  POP     200C
.................... 	sendInRsDma(6); 
12A6:  MOV     #6,W4
12A8:  MOV     W4,9A2
12AA:  CALL    BC4
12AE:  RETURN  
.................... }   
.................... void ansComSetPwm6(int8 canal, int16 p6) 
.................... { 
.................... 	clearDmaBuf();  
*
12B6:  CALL    7B0
.................... 	dmaBuffer[1]=COM_SET_PWM_RK; 
12BA:  MOV     2008,W0
12BC:  SWAP    W0
12BE:  MOV.B   #31,W0L
12C0:  SWAP    W0
12C2:  MOV     W0,2008
.................... 	dmaBuffer[2]=canal;  
12C4:  MOV.B   97E,W0L
12C6:  PUSH    200A
12C8:  MOV.B   W0L,[W15-#2]
12CA:  POP     200A
.................... 	dmaBuffer[3]=(p6>>8); 
12CC:  MOV.B   981,W0L
12CE:  PUSH    200A
12D0:  MOV.B   W0L,[W15-#1]
12D2:  POP     200A
.................... 	dmaBuffer[4]=(p6&0xFF);   
12D4:  MOV     980,W0
12D6:  AND     #FF,W0
12D8:  PUSH    200C
12DA:  MOV.B   W0L,[W15-#2]
12DC:  POP     200C
.................... 	sendInRsDma(6); 
12DE:  MOV     #6,W4
12E0:  MOV     W4,9A2
12E2:  CALL    BC4
12E6:  RETURN  
.................... }   
.................... void ansComSetRk(int8 canal, int8 rk) 
.................... { 
.................... 	clearDmaBuf();  
*
131C:  CALL    7B0
.................... 	dmaBuffer[1]=COM_SET_PWM_RK;  
1320:  MOV     2008,W0
1322:  SWAP    W0
1324:  MOV.B   #31,W0L
1326:  SWAP    W0
1328:  MOV     W0,2008
.................... 	dmaBuffer[2]=canal; 
132A:  MOV.B   97E,W0L
132C:  PUSH    200A
132E:  MOV.B   W0L,[W15-#2]
1330:  POP     200A
.................... 	dmaBuffer[3]=rk;  
1332:  MOV.B   97F,W0L
1334:  PUSH    200A
1336:  MOV.B   W0L,[W15-#1]
1338:  POP     200A
.................... 	sendInRsDma(5); 
133A:  MOV     #5,W4
133C:  MOV     W4,9A2
133E:  CALL    BC4
1342:  RETURN  
.................... }  
....................  
.................... void ansComReadCurAdc(int16 a1, int16 a2, int16 a3, int16 a4) 
.................... { 
.................... 	clearDmaBuf();  
*
11A8:  CALL    7B0
.................... 	dmaBuffer[1]=COM_READ_ADC;  
11AC:  MOV     2008,W0
11AE:  SWAP    W0
11B0:  MOV.B   #40,W0L
11B2:  SWAP    W0
11B4:  MOV     W0,2008
.................... 	dmaBuffer[2]=(a1>>8);  
11B6:  MOV.B   97F,W0L
11B8:  PUSH    200A
11BA:  MOV.B   W0L,[W15-#2]
11BC:  POP     200A
.................... 	dmaBuffer[3]=(a1&0xFF); 
11BE:  MOV     97E,W0
11C0:  AND     #FF,W0
11C2:  PUSH    200A
11C4:  MOV.B   W0L,[W15-#1]
11C6:  POP     200A
.................... 	dmaBuffer[4]=(a2>>8); 
11C8:  MOV.B   981,W0L
11CA:  PUSH    200C
11CC:  MOV.B   W0L,[W15-#2]
11CE:  POP     200C
.................... 	dmaBuffer[5]=(a2&0xFF); 
11D0:  MOV     980,W0
11D2:  AND     #FF,W0
11D4:  PUSH    200C
11D6:  MOV.B   W0L,[W15-#1]
11D8:  POP     200C
.................... 	dmaBuffer[6]=(a3>>8); 
11DA:  MOV.B   983,W0L
11DC:  PUSH    200E
11DE:  MOV.B   W0L,[W15-#2]
11E0:  POP     200E
.................... 	dmaBuffer[7]=(a3&0xFF);  
11E2:  MOV     982,W0
11E4:  AND     #FF,W0
11E6:  PUSH    200E
11E8:  MOV.B   W0L,[W15-#1]
11EA:  POP     200E
.................... 	dmaBuffer[8]=(a4>>8); 
11EC:  MOV.B   985,W0L
11EE:  PUSH    2010
11F0:  MOV.B   W0L,[W15-#2]
11F2:  POP     2010
.................... 	dmaBuffer[9]=(a4&0xFF);   
11F4:  MOV     984,W0
11F6:  AND     #FF,W0
11F8:  PUSH    2010
11FA:  MOV.B   W0L,[W15-#1]
11FC:  POP     2010
.................... 	sendInRsDma(11); 
11FE:  MOV     #B,W4
1200:  MOV     W4,9A2
1202:  CALL    BC4
1206:  RETURN  
....................  
.................... } 
....................  
.................... void ansComOnOffPwm(int8 data) 
.................... { 
.................... 	clearDmaBuf();  
*
1188:  CALL    7B0
.................... 	dmaBuffer[1]=COM_ONOFF_PWM;  
118C:  MOV     2008,W0
118E:  SWAP    W0
1190:  MOV.B   #35,W0L
1192:  SWAP    W0
1194:  MOV     W0,2008
.................... 	dmaBuffer[2]=data; 
1196:  MOV.B   97E,W0L
1198:  PUSH    200A
119A:  MOV.B   W0L,[W15-#2]
119C:  POP     200A
.................... 	sendInRsDma(4);	 
119E:  MOV     #4,W4
11A0:  MOV     W4,9A2
11A2:  CALL    BC4
11A6:  RETURN  
.................... } 
....................  
....................  
....................  
.................... void ansComSetSpeedPwm(int16 canal, int16 speedMin, int16 speedMax) 
.................... { 
.................... 	clearDmaBuf();  
*
0FB4:  CALL    7B0
.................... 	dmaBuffer[1]=COM_SET_SPEED;  
0FB8:  MOV     2008,W0
0FBA:  SWAP    W0
0FBC:  MOV.B   #33,W0L
0FBE:  SWAP    W0
0FC0:  MOV     W0,2008
.................... 	dmaBuffer[2]=canal; 
0FC2:  MOV.B   97E,W0L
0FC4:  PUSH    200A
0FC6:  MOV.B   W0L,[W15-#2]
0FC8:  POP     200A
.................... 	dmaBuffer[3]=(speedMin>>8);  
0FCA:  MOV.B   981,W0L
0FCC:  PUSH    200A
0FCE:  MOV.B   W0L,[W15-#1]
0FD0:  POP     200A
.................... 	dmaBuffer[4]=(speedMin&0xFF); 
0FD2:  MOV     980,W0
0FD4:  AND     #FF,W0
0FD6:  PUSH    200C
0FD8:  MOV.B   W0L,[W15-#2]
0FDA:  POP     200C
.................... 	dmaBuffer[5]=(speedMax>>8);  
0FDC:  MOV.B   983,W0L
0FDE:  PUSH    200C
0FE0:  MOV.B   W0L,[W15-#1]
0FE2:  POP     200C
.................... 	dmaBuffer[6]=(speedMax&0xFF); 
0FE4:  MOV     982,W0
0FE6:  AND     #FF,W0
0FE8:  PUSH    200E
0FEA:  MOV.B   W0L,[W15-#2]
0FEC:  POP     200E
.................... 	sendInRsDma(8);	 
0FEE:  MOV     #8,W4
0FF0:  MOV     W4,9A2
0FF2:  CALL    BC4
0FF6:  RETURN  
.................... } 
.................... void ansComSetSpeedAllPwm(int16 can, int16 sMn3, int16 sMx3, int16 sMn4, int16 sMx4, int16 sMn5, int16 sMx5, int16 sMn6, int16 sMx6 ) 
.................... { 
.................... 	clearDmaBuf();  
0FF8:  CALL    7B0
.................... 	dmaBuffer[1]=COM_SET_SPEED;  
0FFC:  MOV     2008,W0
0FFE:  SWAP    W0
1000:  MOV.B   #33,W0L
1002:  SWAP    W0
1004:  MOV     W0,2008
.................... 	dmaBuffer[2]=can; 
1006:  MOV.B   97E,W0L
1008:  PUSH    200A
100A:  MOV.B   W0L,[W15-#2]
100C:  POP     200A
.................... 	dmaBuffer[3]=(sMn3>>8);  
100E:  MOV.B   981,W0L
1010:  PUSH    200A
1012:  MOV.B   W0L,[W15-#1]
1014:  POP     200A
.................... 	dmaBuffer[4]=(sMn3&0xFF); 
1016:  MOV     980,W0
1018:  AND     #FF,W0
101A:  PUSH    200C
101C:  MOV.B   W0L,[W15-#2]
101E:  POP     200C
.................... 	dmaBuffer[5]=(sMx3>>8);  
1020:  MOV.B   983,W0L
1022:  PUSH    200C
1024:  MOV.B   W0L,[W15-#1]
1026:  POP     200C
.................... 	dmaBuffer[6]=(sMx3&0xFF); 
1028:  MOV     982,W0
102A:  AND     #FF,W0
102C:  PUSH    200E
102E:  MOV.B   W0L,[W15-#2]
1030:  POP     200E
.................... 	dmaBuffer[7]=(sMn4>>8);  
1032:  MOV.B   985,W0L
1034:  PUSH    200E
1036:  MOV.B   W0L,[W15-#1]
1038:  POP     200E
.................... 	dmaBuffer[8]=(sMn4&0xFF); 
103A:  MOV     984,W0
103C:  AND     #FF,W0
103E:  PUSH    2010
1040:  MOV.B   W0L,[W15-#2]
1042:  POP     2010
.................... 	dmaBuffer[9]=(sMx4>>8);  
1044:  MOV.B   987,W0L
1046:  PUSH    2010
1048:  MOV.B   W0L,[W15-#1]
104A:  POP     2010
.................... 	dmaBuffer[10]=(sMx4&0xFF); 
104C:  MOV     986,W0
104E:  AND     #FF,W0
1050:  PUSH    2012
1052:  MOV.B   W0L,[W15-#2]
1054:  POP     2012
.................... 	dmaBuffer[11]=(sMn5>>8);  
1056:  MOV.B   989,W0L
1058:  PUSH    2012
105A:  MOV.B   W0L,[W15-#1]
105C:  POP     2012
.................... 	dmaBuffer[12]=(sMn5&0xFF); 
105E:  MOV     988,W0
1060:  AND     #FF,W0
1062:  PUSH    2014
1064:  MOV.B   W0L,[W15-#2]
1066:  POP     2014
.................... 	dmaBuffer[13]=(sMx5>>8);  
1068:  MOV.B   98B,W0L
106A:  PUSH    2014
106C:  MOV.B   W0L,[W15-#1]
106E:  POP     2014
.................... 	dmaBuffer[14]=(sMx5&0xFF); 
1070:  MOV     98A,W0
1072:  AND     #FF,W0
1074:  PUSH    2016
1076:  MOV.B   W0L,[W15-#2]
1078:  POP     2016
.................... 	dmaBuffer[15]=(sMn6>>8);  
107A:  MOV.B   98D,W0L
107C:  PUSH    2016
107E:  MOV.B   W0L,[W15-#1]
1080:  POP     2016
.................... 	dmaBuffer[16]=(sMn6&0xFF); 
1082:  MOV     98C,W0
1084:  AND     #FF,W0
1086:  PUSH    2018
1088:  MOV.B   W0L,[W15-#2]
108A:  POP     2018
.................... 	dmaBuffer[17]=(sMx6>>8);  
108C:  MOV.B   98F,W0L
108E:  PUSH    2018
1090:  MOV.B   W0L,[W15-#1]
1092:  POP     2018
.................... 	dmaBuffer[18]=(sMx6&0xFF); 
1094:  MOV     98E,W0
1096:  AND     #FF,W0
1098:  PUSH    201A
109A:  MOV.B   W0L,[W15-#2]
109C:  POP     201A
.................... 	sendInRsDma(20);	 
109E:  MOV     #14,W4
10A0:  MOV     W4,9A2
10A2:  CALL    BC4
10A6:  RETURN  
....................  
.................... } 
....................  
.................... void ansComReadSpeed() 
.................... { 
.................... 	  
.................... 	clearDmaBuf();  
*
0C36:  CALL    7B0
.................... 	dmaBuffer[1]=COM_READ_SPEED; 
0C3A:  MOV     2008,W0
0C3C:  SWAP    W0
0C3E:  MOV.B   #43,W0L
0C40:  SWAP    W0
0C42:  MOV     W0,2008
.................... 	// m3 min   
.................... 	int16 data = getMinSpeed(&m3); 
0C44:  MOV     #858,W4
0C46:  MOV     W4,980
0C48:  CALL    C16
0C4C:  MOV     W0,97E
.................... 	dmaBuffer[2]=(data>>8);  
0C4E:  MOV.B   97F,W0L
0C50:  PUSH    200A
0C52:  MOV.B   W0L,[W15-#2]
0C54:  POP     200A
.................... 	dmaBuffer[3]=(data&0xFF); 
0C56:  MOV     97E,W0
0C58:  AND     #FF,W0
0C5A:  PUSH    200A
0C5C:  MOV.B   W0L,[W15-#1]
0C5E:  POP     200A
.................... 	// m4 min  
.................... 	data = getMinSpeed(&m4);  
0C60:  MOV     #888,W4
0C62:  MOV     W4,980
0C64:  CALL    C16
0C68:  MOV     W0,97E
.................... 	dmaBuffer[4]=(data>>8);  
0C6A:  MOV.B   97F,W0L
0C6C:  PUSH    200C
0C6E:  MOV.B   W0L,[W15-#2]
0C70:  POP     200C
.................... 	dmaBuffer[5]=(data&0xFF); 
0C72:  MOV     97E,W0
0C74:  AND     #FF,W0
0C76:  PUSH    200C
0C78:  MOV.B   W0L,[W15-#1]
0C7A:  POP     200C
.................... 	// m5 min 
.................... 	data = getMinSpeed(&m5);  
0C7C:  MOV     #8B8,W4
0C7E:  MOV     W4,980
0C80:  CALL    C16
0C84:  MOV     W0,97E
.................... 	dmaBuffer[6]=(data>>8);  
0C86:  MOV.B   97F,W0L
0C88:  PUSH    200E
0C8A:  MOV.B   W0L,[W15-#2]
0C8C:  POP     200E
.................... 	dmaBuffer[7]=(data&0xFF); 
0C8E:  MOV     97E,W0
0C90:  AND     #FF,W0
0C92:  PUSH    200E
0C94:  MOV.B   W0L,[W15-#1]
0C96:  POP     200E
.................... 	// m6 min  
.................... 	data = getMinSpeed(&m6);  
0C98:  MOV     #8E8,W4
0C9A:  MOV     W4,980
0C9C:  CALL    C16
0CA0:  MOV     W0,97E
.................... 	dmaBuffer[8]=(data>>8);  
0CA2:  MOV.B   97F,W0L
0CA4:  PUSH    2010
0CA6:  MOV.B   W0L,[W15-#2]
0CA8:  POP     2010
.................... 	dmaBuffer[9]=(data&0xFF); 
0CAA:  MOV     97E,W0
0CAC:  AND     #FF,W0
0CAE:  PUSH    2010
0CB0:  MOV.B   W0L,[W15-#1]
0CB2:  POP     2010
.................... 	 
.................... 	 
.................... 	// m3 max  
.................... 	data = getMaxSpeed(&m3); 
0CB4:  MOV     #858,W4
0CB6:  MOV     W4,980
0CB8:  CALL    C26
0CBC:  MOV     W0,97E
.................... 	dmaBuffer[10]=(data>>8);  
0CBE:  MOV.B   97F,W0L
0CC0:  PUSH    2012
0CC2:  MOV.B   W0L,[W15-#2]
0CC4:  POP     2012
.................... 	dmaBuffer[11]=(data&0xFF); 
0CC6:  MOV     97E,W0
0CC8:  AND     #FF,W0
0CCA:  PUSH    2012
0CCC:  MOV.B   W0L,[W15-#1]
0CCE:  POP     2012
.................... 	// m4 max  
.................... 	data = getMaxSpeed(&m4); 
0CD0:  MOV     #888,W4
0CD2:  MOV     W4,980
0CD4:  CALL    C26
0CD8:  MOV     W0,97E
.................... 	dmaBuffer[12]=(data>>8);  
0CDA:  MOV.B   97F,W0L
0CDC:  PUSH    2014
0CDE:  MOV.B   W0L,[W15-#2]
0CE0:  POP     2014
.................... 	dmaBuffer[13]=(data&0xFF); 
0CE2:  MOV     97E,W0
0CE4:  AND     #FF,W0
0CE6:  PUSH    2014
0CE8:  MOV.B   W0L,[W15-#1]
0CEA:  POP     2014
.................... 	// m5 max  
.................... 	data = getMaxSpeed(&m5); 
0CEC:  MOV     #8B8,W4
0CEE:  MOV     W4,980
0CF0:  CALL    C26
0CF4:  MOV     W0,97E
.................... 	dmaBuffer[14]=(data>>8);  
0CF6:  MOV.B   97F,W0L
0CF8:  PUSH    2016
0CFA:  MOV.B   W0L,[W15-#2]
0CFC:  POP     2016
.................... 	dmaBuffer[15]=(data&0xFF); 
0CFE:  MOV     97E,W0
0D00:  AND     #FF,W0
0D02:  PUSH    2016
0D04:  MOV.B   W0L,[W15-#1]
0D06:  POP     2016
.................... 	// m6 max 
.................... 	data = getMaxSpeed(&m6); 
0D08:  MOV     #8E8,W4
0D0A:  MOV     W4,980
0D0C:  CALL    C26
0D10:  MOV     W0,97E
.................... 	dmaBuffer[16]=(data>>8);  
0D12:  MOV.B   97F,W0L
0D14:  PUSH    2018
0D16:  MOV.B   W0L,[W15-#2]
0D18:  POP     2018
.................... 	dmaBuffer[17]=(data&0xFF); 
0D1A:  MOV     97E,W0
0D1C:  AND     #FF,W0
0D1E:  PUSH    2018
0D20:  MOV.B   W0L,[W15-#1]
0D22:  POP     2018
.................... 	sendInRsDma(19);	 
0D24:  MOV     #13,W4
0D26:  MOV     W4,9A2
0D28:  CALL    BC4
0D2C:  RETURN  
....................   
.................... } 
....................  
.................... void ansComRunCalibr() 
.................... { 
.................... 	clearDmaBuf(); 
*
1170:  CALL    7B0
.................... 	dmaBuffer[1]=COM_RUN_CALIBR;  
1174:  MOV     2008,W0
1176:  SWAP    W0
1178:  MOV.B   #32,W0L
117A:  SWAP    W0
117C:  MOV     W0,2008
.................... 	sendInRsDma(3); 
117E:  MOV     #3,W4
1180:  MOV     W4,9A2
1182:  CALL    BC4
1186:  RETURN  
.................... } 
....................  
.................... void ansComReadError(int8 d1, int8 d2, int8 d3, int8 d4) 
.................... { 
.................... 	clearDmaBuf(); 
*
0BDE:  CALL    7B0
.................... 	dmaBuffer[1]=COM_READ_ERROR;  
0BE2:  MOV     2008,W0
0BE4:  SWAP    W0
0BE6:  MOV.B   #42,W0L
0BE8:  SWAP    W0
0BEA:  MOV     W0,2008
.................... 	dmaBuffer[2]=d1; 
0BEC:  MOV.B   97E,W0L
0BEE:  PUSH    200A
0BF0:  MOV.B   W0L,[W15-#2]
0BF2:  POP     200A
.................... 	dmaBuffer[3]=d2; 
0BF4:  MOV.B   97F,W0L
0BF6:  PUSH    200A
0BF8:  MOV.B   W0L,[W15-#1]
0BFA:  POP     200A
.................... 	dmaBuffer[4]=d3; 
0BFC:  MOV.B   980,W0L
0BFE:  PUSH    200C
0C00:  MOV.B   W0L,[W15-#2]
0C02:  POP     200C
.................... 	dmaBuffer[5]=d4; 
0C04:  MOV.B   981,W0L
0C06:  PUSH    200C
0C08:  MOV.B   W0L,[W15-#1]
0C0A:  POP     200C
....................  	sendInRsDma(7); 
0C0C:  MOV     #7,W4
0C0E:  MOV     W4,9A2
0C10:  CALL    BC4
0C14:  RETURN  
.................... } 
.................... //********************** 
....................  
.................... void ansReadCrc(int16 crc) 
*
13DE:  MOV     W5,[W15++]
.................... { 
.................... 	clearDmaBuf();  
13E0:  CALL    7B0
.................... 	dmaBuffer[1]=COM_READ_CRC;  
13E4:  MOV     2008,W0
13E6:  SWAP    W0
13E8:  MOV.B   #47,W0L
13EA:  SWAP    W0
13EC:  MOV     W0,2008
.................... 	dmaBuffer[2]=((crc>>8)&0xFF);  
13EE:  MOV.B   97F,W0L
13F0:  MOV.B   W0L,W5L
13F2:  CLR.B   B
13F4:  MOV     W5,W0
13F6:  PUSH    200A
13F8:  MOV.B   W0L,[W15-#2]
13FA:  POP     200A
.................... 	dmaBuffer[3]= (crc&0xFF);  
13FC:  MOV     97E,W0
13FE:  AND     #FF,W0
1400:  PUSH    200A
1402:  MOV.B   W0L,[W15-#1]
1404:  POP     200A
.................... 	sendInRsDma(5); 
1406:  MOV     #5,W4
1408:  MOV     W4,9A2
140A:  CALL    BC4
140E:  MOV     [--W15],W5
1410:  RETURN  
.................... }  
.................... void ansComInfo() 
.................... { 
.................... 	clearDmaBuf();  
1412:  CALL    7B0
.................... 	dmaBuffer[1]= COM_INFO;			//0x48 
1416:  MOV     2008,W0
1418:  SWAP    W0
141A:  MOV.B   #48,W0L
141C:  SWAP    W0
141E:  MOV     W0,2008
.................... 	dmaBuffer[2]= COM_SET_PWM_RK;	//0x31 
1420:  MOV     200A,W0
1422:  MOV.B   #31,W0L
1424:  MOV     W0,200A
.................... 	dmaBuffer[3]= COM_RUN_CALIBR;	//0x32 
1426:  MOV     200A,W0
1428:  SWAP    W0
142A:  MOV.B   #32,W0L
142C:  SWAP    W0
142E:  MOV     W0,200A
.................... 	dmaBuffer[4]= COM_SET_SPEED;	//0x33 
1430:  MOV     200C,W0
1432:  MOV.B   #33,W0L
1434:  MOV     W0,200C
.................... 	dmaBuffer[5]= COM_ONOFF_PWM;	//0x35 
1436:  MOV     200C,W0
1438:  SWAP    W0
143A:  MOV.B   #35,W0L
143C:  SWAP    W0
143E:  MOV     W0,200C
.................... 	dmaBuffer[6]= COM_READ_ADC;		//0x40 
1440:  MOV     200E,W0
1442:  MOV.B   #40,W0L
1444:  MOV     W0,200E
.................... 	dmaBuffer[7]= COM_LIMIT_ADC;	//0x41 
1446:  MOV     200E,W0
1448:  SWAP    W0
144A:  MOV.B   #41,W0L
144C:  SWAP    W0
144E:  MOV     W0,200E
.................... 	dmaBuffer[8]= COM_READ_ERROR;	//0x42	 
1450:  MOV     2010,W0
1452:  MOV.B   #42,W0L
1454:  MOV     W0,2010
.................... 	dmaBuffer[9]= COM_READ_SPEED;   //0x43 
1456:  MOV     2010,W0
1458:  SWAP    W0
145A:  MOV.B   #43,W0L
145C:  SWAP    W0
145E:  MOV     W0,2010
.................... 	dmaBuffer[10]= COM_READ_CRC;		//0x47 
1460:  MOV     2012,W0
1462:  MOV.B   #47,W0L
1464:  MOV     W0,2012
.................... 	dmaBuffer[11]= COM_READ_ID;		//0x46 
1466:  MOV     2012,W0
1468:  SWAP    W0
146A:  MOV.B   #46,W0L
146C:  SWAP    W0
146E:  MOV     W0,2012
.................... 	dmaBuffer[12]= COM_RESET_MK;		//0x55 
1470:  MOV     2014,W0
1472:  MOV.B   #55,W0L
1474:  MOV     W0,2014
.................... 	sendInRsDma(14); 
1476:  MOV     #E,W4
1478:  MOV     W4,9A2
147A:  CALL    BC4
147E:  RETURN  
....................  
.................... } 
.................... void ansComId() 
.................... { 
.................... 	clearDmaBuf();  
1480:  CALL    7B0
.................... 	dmaBuffer[1]= COM_READ_ID; 
1484:  MOV     2008,W0
1486:  SWAP    W0
1488:  MOV.B   #46,W0L
148A:  SWAP    W0
148C:  MOV     W0,2008
.................... 	dmaBuffer[2]= ID1; 
148E:  MOV     200A,W0
1490:  MOV.B   #17,W0L
1492:  MOV     W0,200A
.................... 	dmaBuffer[3]= ID2; 
1494:  MOV     200A,W0
1496:  SWAP    W0
1498:  MOV.B   #3,W0L
149A:  SWAP    W0
149C:  MOV     W0,200A
.................... 	dmaBuffer[4]= ID3; 
149E:  MOV     200C,W0
14A0:  MOV.B   #20,W0L
14A2:  MOV     W0,200C
.................... 	dmaBuffer[5]= ID4;  
14A4:  MOV     200C,W0
14A6:  SWAP    W0
14A8:  MOV.B   #16,W0L
14AA:  SWAP    W0
14AC:  MOV     W0,200C
.................... 	sendInRsDma(7); 
14AE:  MOV     #7,W4
14B0:  MOV     W4,9A2
14B2:  CALL    BC4
14B6:  RETURN  
.................... }  
.................... void ansComRst(int8 com, int8 data) 
.................... { 
.................... 	clearDmaBuf();  
*
14D2:  CALL    7B0
.................... 	dmaBuffer[1]= com; 
14D6:  MOV.B   980,W0L
14D8:  PUSH    2008
14DA:  MOV.B   W0L,[W15-#1]
14DC:  POP     2008
.................... 	dmaBuffer[2]= data;  
14DE:  MOV.B   981,W0L
14E0:  PUSH    200A
14E2:  MOV.B   W0L,[W15-#2]
14E4:  POP     200A
.................... 	sendInRsDma(4);	 
14E6:  MOV     #4,W4
14E8:  MOV     W4,9A2
14EA:  CALL    BC4
14EE:  RETURN  
.................... } 
.................... void ansErrorCom(int8 com) 
.................... { 
.................... 	clearDmaBuf();   
14F0:  CALL    7B0
.................... 	dmaBuffer[1]= (~com);  
14F4:  COM.B   0980,W0L
14F6:  PUSH    2008
14F8:  MOV.B   W0L,[W15-#1]
14FA:  POP     2008
.................... 	sendInRsDma(3);	 
14FC:  MOV     #3,W4
14FE:  MOV     W4,9A2
1500:  CALL    BC4
1504:  RETURN  
.................... } 
....................  
.................... void ansErrorComCanal(int8 com) 
.................... { 
.................... 	clearDmaBuf();   
*
10A8:  CALL    7B0
.................... 	dmaBuffer[1]= COM_SET_PWM_RK; 
10AC:  MOV     2008,W0
10AE:  SWAP    W0
10B0:  MOV.B   #31,W0L
10B2:  SWAP    W0
10B4:  MOV     W0,2008
.................... 	dmaBuffer[2]= (~com);   
10B6:  COM.B   097E,W0L
10B8:  PUSH    200A
10BA:  MOV.B   W0L,[W15-#2]
10BC:  POP     200A
.................... 	sendInRsDma(4);	 
10BE:  MOV     #4,W4
10C0:  MOV     W4,9A2
10C2:  CALL    BC4
10C6:  RETURN  
.................... } 
....................  
....................  
.................... #include "CRC.c" 
.................... //*********************************************************** 
.................... //контрольная сумма  
.................... //*********************************************************** 
.................... int16 crc = 0;  
.................... int16 getChecksum() 
*
080A:  MOV     W5,[W15++]
080C:  CLR     940
*
0810:  MOV     #ABFE,W4
0812:  MOV     W4,944
0814:  CLR     946
.................... 	{ 
.................... 		int16 chSum = 0;  
.................... 		int8 temp[2] = {0, 0};  
*
080E:  CLR     942
.................... 		int32 adr = (getenv("Program_memory")-2 );  
.................... 		//sendRS(0x33); 
.................... 		read_program_memory(adr, temp, 2); 
*
0816:  MOV     944,W0
0818:  MOV     946,W1
081A:  MOV     #942,W2
081C:  MOV     #2,W3
081E:  CALL    7DC
.................... 		//sendRS(temp[1]); 
.................... 		//sendRS(temp[0]);  
.................... 		chSum = make16(temp[1], temp[0]); 
0822:  MOV.B   942,W0L
0824:  MOV.B   W0L,940
0826:  MOV.B   943,W0L
0828:  MOV.B   W0L,941
.................... 		return chSum;  
082A:  PUSH    940
082C:  POP     0
082E:  MOV     [--W15],W5
0830:  RETURN  
.................... 	} 
.................... //*********************************************************** 
....................  
.................... #include "calibrAdcPwm.c" // timer7 
.................... #include "calibrAdcPwm.h" 
.................... #ifndef CALIBRADCPWM_H 
.................... #define CALIBRADCPWM_H 
....................  
.................... #include "pwmUap.h" 
.................... #include "AZP.h" 
....................  
.................... #define TIME_TEST_ADC_PWM 31250  //200ms 
.................... #define MAX_COUNT_ZIKL_WAIT 200 
....................  
.................... #define ERROR_WAIT (1<<4) 
.................... #define ACCURACY_ADC 0xFFF0 
....................  
.................... #define SK_VAL1_UP 250 
.................... #define SK_VAL2_UP (POL_PERIOD + SK_VAL1_UP) 
.................... #define SK_VAL1_DW (TIME_PWM-SK_VAL1_UP) 
.................... #define SK_VAL2_DW (POL_PERIOD-(TIME_PWM-SK_VAL1_DW)) 
.................... //states  
.................... #define S0  0x0000 
.................... #define S1  0x0001 
.................... #define S2  0x0002 
.................... #define S3  0x0004 
.................... #define S4  0x0008 
.................... #define S5  0x0010 
.................... #define S6  0x0020 
.................... #define S7  0x0040 
.................... #define S8  0x0080 
.................... #define S9  0x0100 
.................... #define S10 0x0200 
....................  
.................... // граничные значения с АЦП при нахождении указателей 
.................... // в максимальном и минимальном положени по шкале 
.................... //min  
.................... int16 minAdc1 = 0;  
.................... int16 minAdc2 = 0;  
.................... int16 minAdc3 = 0;  
.................... int16 minAdc4 = 0;  
.................... //max 
.................... int16 maxAdc1 = 0;  
.................... int16 maxAdc2 = 0;  
.................... int16 maxAdc3 = 0;  
.................... int16 maxAdc4 = 0;  
....................  
.................... #define SIZE_TEMP_ADC 4 
.................... int16 tempValADC11[SIZE_TEMP_ADC] = {0,0,0,0};  
.................... int16 tempValADC12[SIZE_TEMP_ADC] = {0,0,0,0}; 
.................... int16 tempValADC13[SIZE_TEMP_ADC] = {0,0,0,0}; 
.................... int16 tempValADC14[SIZE_TEMP_ADC] = {0,0,0,0}; 
....................  
.................... int16 readValADC11 = 0;  
.................... int16 readValADC12 = 0; 
.................... int16 readValADC21 = 0; 
.................... int16 readValADC22 = 0; 
.................... int16 readValADC31 = 0; 
.................... int16 readValADC32 = 0; 
.................... int16 readValADC41 = 0; 
.................... int16 readValADC42 = 0; 
....................  
.................... int8 errorRotate = 0; 
....................  
.................... int16 currentStateAvt = 0;  
.................... int16 oldStateAvt = 0;  
.................... int16 newStateAvt = 0;  
.................... int1 enabSendCalibrData = 0;   
.................... int1 endCalibrMotor = 0;  
....................  
.................... void setPositionEndCalibr(); 
....................  
.................... void initAvtomat();  
.................... void startAvtomatCalibr();  
.................... void startTimer7();  
.................... void resetCountZikl();  
.................... void resetAvtomat();  
.................... void updateState();  
.................... void readData1Adc();  
.................... void readData2Adc();  
.................... void sravnData(); 
.................... void setEnableSendData();   
.................... void sendDataCalibr();  
.................... void stopTimer7(); 
.................... void setRotatePwm(int1 b);  
.................... int1 waitStop();  
.................... void sendState( );  
....................  
.................... int16 ziklReadCalibr = 0; 
.................... int16 indexDataRead = 0;     
....................  
....................  
.................... int1 getFullMasCalibr(int16 a, int16 b, int16 c, int16 d);  
....................  
....................  
.................... int1 debugRS = 0;  
.................... void setDebugRS(); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... void initAvtomat() 
.................... { 
.................... 	minAdc1 = 0x0000; 
*
036A:  CLR     80C
.................... 	minAdc2 = 0x0000; 
036C:  CLR     80E
.................... 	minAdc3 = 0x0000; 
036E:  CLR     810
.................... 	minAdc4 = 0x0000; 
0370:  CLR     812
.................... 	maxAdc1 = 0x0000; 
0372:  CLR     814
.................... 	maxAdc2 = 0x0000; 
0374:  CLR     816
.................... 	maxAdc3 = 0x0000; 
0376:  CLR     818
.................... 	maxAdc4 = 0x0000; 
0378:  CLR     81A
.................... 	 
.................... 	memset(tempValADC11, 0, (SIZE_TEMP_ADC<<1));  
037A:  MOV     #81C,W1
037C:  MOV     #0,W2
037E:  REPEAT  #7
0380:  CLR.B   [W1++]
.................... 	memset(tempValADC12, 0, (SIZE_TEMP_ADC<<1));  
0382:  MOV     #824,W1
0384:  MOV     #0,W2
0386:  REPEAT  #7
0388:  CLR.B   [W1++]
.................... 	memset(tempValADC13, 0, (SIZE_TEMP_ADC<<1));  
038A:  MOV     #82C,W1
038C:  MOV     #0,W2
038E:  REPEAT  #7
0390:  CLR.B   [W1++]
.................... 	memset(tempValADC14, 0, (SIZE_TEMP_ADC<<1));  
0392:  MOV     #834,W1
0394:  MOV     #0,W2
0396:  REPEAT  #7
0398:  CLR.B   [W1++]
.................... /*	for(int i= 0; i<SIZE_TEMP_ADC; i++) 
.................... 	{ 
.................... 		tempValADC11[i] = 0; 	 
.................... 		tempValADC12[i] = 0; 
.................... 		tempValADC13[i] = 0; 
.................... 		tempValADC14[i] = 0; 
.................... 	}*/ 
.................... 	 
.................... 	currentStateAvt = 0;  
039A:  CLR     84E
.................... 	oldStateAvt = 0;  
039C:  CLR     850
.................... 	newStateAvt = 0;  
039E:  CLR     852
.................... 	enabSendCalibrData = 0;  
03A0:  BCLR.B  803.5
.................... 	endCalibrMotor = 0;  
03A2:  BCLR.B  803.6
03A4:  RETURN  
.................... //	resetCountZikl();  
.................... } 
....................  
....................  
.................... void setPositionEndCalibr() // smotri stopTimer7(), primenenie dannoi f() vyzyvaet  
.................... {				//Interrupts disabled during call to prevent re-entrancy:  (stopTimer7) 
.................... 	newValueM3  = (maxAdc1&0xFFC0); 
.................... 	newValueM4  = (maxAdc2&0xFFC0); 
.................... 	newValueM5  = (maxAdc3&0xFFC0); 
.................... 	newValueM6  = (maxAdc4&0xFFC0); 
....................  
.................... } 
....................  
.................... void resetCountZikl() 
.................... { 
.................... 	ziklReadCalibr = 0;  
03A6:  CLR     854
.................... 	indexDataRead = 0; 
03A8:  CLR     856
.................... 	enabSendCalibrData = 0;   
03AA:  BCLR.B  803.5
03AC:  RETURN  
.................... 	 
.................... } 
....................  
.................... void stopTimer7() 
.................... { 
.................... 	disable_interrupts(int_TIMER7);  
*
0654:  BCLR.B  9A.0
.................... 	set_timer7(0); 
0656:  CLR     126
.................... 	endCalibrMotor = 1;  
0658:  BSET.B  803.6
.................... 	//setPositionEndCalibr(); -  Interrupts disabled during call to prevent re-entrancy:  (stopTimer7) 
.................... 	newValueM3  = (maxAdc1&0xFFC0); 
065A:  PUSH    814
065C:  POP     918
065E:  MOV     #FFC0,W0
0660:  AND     918
.................... 	newValueM4  = (maxAdc2&0xFFC0); 
0662:  PUSH    816
0664:  POP     91A
0666:  MOV     #FFC0,W0
0668:  AND     91A
.................... 	newValueM5  = (maxAdc3&0xFFC0); 
066A:  PUSH    818
066C:  POP     91C
066E:  MOV     #FFC0,W0
0670:  AND     91C
.................... 	newValueM6  = (maxAdc4&0xFFC0); 
0672:  PUSH    81A
0674:  POP     91E
0676:  MOV     #FFC0,W0
0678:  AND     91E
067A:  RETURN  
.................... } 
....................  
.................... void startTimer7() 
.................... { 
.................... 	 
.................... 	disable_interrupts(int_TIMER7);  
*
0B4E:  BCLR.B  9A.0
.................... 	setup_timer7(TMR_INTERNAL|TMR_DIV_BY_256, TIME_TEST_ADC_PWM);  
0B50:  CLR     12E
0B52:  MOV     #7A12,W4
0B54:  MOV     W4,12A
0B56:  MOV     #8030,W4
0B58:  MOV     W4,12E
.................... 	set_timer7(0);  
0B5A:  CLR     126
.................... 	enable_interrupts(int_TIMER7); 	 
0B5C:  BSET.B  9A.0
0B5E:  RETURN  
.................... } 
....................  
.................... void startAvtomatCalibr() 
.................... { 
.................... 	stopTimer7();  
0B60:  CALL    654
.................... 	setAndError(&m3, END_CALIBR|ERROR_CLBR|ERR_DADC|ERR_VADC2_B|ERR_VADC1_B|ERR_VADC_RAVN); 
0B64:  MOV.B   #CF,W0L
0B66:  MOV.B   W0L,984
0B68:  MOV     #858,W4
0B6A:  MOV     W4,982
0B6C:  CALL    8F4
.................... 	setAndError(&m4, END_CALIBR|ERROR_CLBR|ERR_DADC|ERR_VADC2_B|ERR_VADC1_B|ERR_VADC_RAVN); 
0B70:  MOV.B   #CF,W0L
0B72:  MOV.B   W0L,984
0B74:  MOV     #888,W4
0B76:  MOV     W4,982
0B78:  CALL    8F4
.................... 	setAndError(&m5, END_CALIBR|ERROR_CLBR|ERR_DADC|ERR_VADC2_B|ERR_VADC1_B|ERR_VADC_RAVN); 
0B7C:  MOV.B   #CF,W0L
0B7E:  MOV.B   W0L,984
0B80:  MOV     #8B8,W4
0B82:  MOV     W4,982
0B84:  CALL    8F4
.................... 	setAndError(&m6, END_CALIBR|ERROR_CLBR|ERR_DADC|ERR_VADC2_B|ERR_VADC1_B|ERR_VADC_RAVN); 
0B88:  MOV.B   #CF,W0L
0B8A:  MOV.B   W0L,984
0B8C:  MOV     #8E8,W4
0B8E:  MOV     W4,982
0B90:  CALL    8F4
.................... 	initAvtomat(); 
0B94:  CALL    36A
.................... 	startTimer7();  
0B98:  CALL    B4E
.................... 	endCalibrMotor = 0;  
0B9C:  BCLR.B  803.6
.................... 	errorRotate = 0;  
0B9E:  CLR.B   84C
0BA0:  RETURN  
....................  
.................... 		 
.................... } 
....................  
.................... void updateState() 
.................... { 
.................... 	oldStateAvt = currentStateAvt;  
*
0684:  PUSH    84E
0686:  POP     850
.................... 	currentStateAvt = newStateAvt; 	 
0688:  PUSH    852
068A:  POP     84E
068C:  RETURN  
.................... } 
.................... 	 
....................  
....................  
.................... void testPWM(int8 n, int1 b) 
.................... { 
.................... 		switch(n) 
*
03AE:  MOV.B   9BC,W0L
03B0:  SE      W0,W0
03B2:  XOR     #3,W0
03B4:  BRA     Z,3C4
03B6:  XOR     #7,W0
03B8:  BRA     Z,3DC
03BA:  XOR     #1,W0
03BC:  BRA     Z,3F4
03BE:  XOR     #3,W0
03C0:  BRA     Z,40C
03C2:  BRA     424
.................... 		{ 
.................... 			case 3: { 
.................... 						if(b){set_compare_time(3, SK_VAL1_UP, SK_VAL2_UP);} 
03C4:  CP0.B   9BD
03C6:  BRA     Z,3D2
03C8:  MOV     #FA,W4
03CA:  MOV     W4,18E
03CC:  MOV     #1964,W4
03CE:  MOV     W4,18C
03D0:  BRA     3DA
.................... 						else{set_compare_time(3, SK_VAL1_DW, SK_VAL2_DW);} 
03D2:  MOV     #2FDA,W4
03D4:  MOV     W4,18E
03D6:  MOV     #1770,W4
03D8:  MOV     W4,18C
.................... 						break; 
03DA:  BRA     424
.................... 					} 
.................... 			case 4: { 
.................... 						if(b){set_compare_time(4, SK_VAL1_UP, SK_VAL2_UP);} 
03DC:  CP0.B   9BD
03DE:  BRA     Z,3EA
03E0:  MOV     #FA,W4
03E2:  MOV     W4,194
03E4:  MOV     #1964,W4
03E6:  MOV     W4,192
03E8:  BRA     3F2
.................... 						else{set_compare_time(4, SK_VAL1_DW, SK_VAL2_DW);} 
03EA:  MOV     #2FDA,W4
03EC:  MOV     W4,194
03EE:  MOV     #1770,W4
03F0:  MOV     W4,192
.................... 						break; 
03F2:  BRA     424
.................... 					} 
.................... 			case 5: { 
.................... 						if(b){set_compare_time(5, SK_VAL1_UP, SK_VAL2_UP);} 
03F4:  CP0.B   9BD
03F6:  BRA     Z,402
03F8:  MOV     #FA,W4
03FA:  MOV     W4,19A
03FC:  MOV     #1964,W4
03FE:  MOV     W4,198
0400:  BRA     40A
.................... 						else{set_compare_time(5, SK_VAL1_DW, SK_VAL2_DW);} 
0402:  MOV     #2FDA,W4
0404:  MOV     W4,19A
0406:  MOV     #1770,W4
0408:  MOV     W4,198
.................... 						break; 
040A:  BRA     424
.................... 					} 
.................... 			case 6: { 
.................... 						if(b){set_compare_time(6, SK_VAL1_UP, SK_VAL2_UP);} 
040C:  CP0.B   9BD
040E:  BRA     Z,41A
0410:  MOV     #FA,W4
0412:  MOV     W4,1A0
0414:  MOV     #1964,W4
0416:  MOV     W4,19E
0418:  BRA     422
.................... 						else{set_compare_time(6, SK_VAL1_DW, SK_VAL2_DW);} 
041A:  MOV     #2FDA,W4
041C:  MOV     W4,1A0
041E:  MOV     #1770,W4
0420:  MOV     W4,19E
.................... 						break; 
0422:  BRA     424
.................... 					} 
.................... 			default:{}	 
....................  
.................... 		} 
0424:  RETURN  
.................... } 
....................  
....................  
.................... #int_timer7  
.................... void timer7_isr(void) 
*
068E:  PUSH    42
0690:  PUSH    36
0692:  PUSH    32
0694:  MOV     W0,[W15++]
0696:  MOV     #2,W0
0698:  REPEAT  #C
069A:  MOV     [W0++],[W15++]
.................... {	 
.................... 	ziklReadCalibr++; 
069C:  INC     0854
.................... 	if(ziklREadCalibr>=MAX_COUNT_ZIKL_WAIT) 
069E:  MOV     854,W4
06A0:  MOV     #C8,W3
06A2:  CP      W3,W4
06A4:  BRA     GT,6AE
.................... 	{ 
.................... 		errorRotate = ERROR_WAIT; 
06A6:  MOV.B   #10,W0L
06A8:  MOV.B   W0L,84C
.................... 		newStateAvt = S10;  
06AA:  MOV     #200,W4
06AC:  MOV     W4,852
.................... 	} 
.................... 	switch(currentStateAvt) 
06AE:  MOV     84E,W0
06B0:  XOR     #0,W0
06B2:  BRA     Z,6DE
06B4:  XOR     #1,W0
06B6:  BRA     Z,6E8
06B8:  XOR     #3,W0
06BA:  BRA     Z,6F2
06BC:  XOR     #6,W0
06BE:  BRA     Z,700
06C0:  XOR     #C,W0
06C2:  BRA     Z,714
06C4:  XOR     #18,W0
06C6:  BRA     Z,71E
06C8:  XOR     #30,W0
06CA:  BRA     Z,728
06CC:  XOR     #60,W0
06CE:  BRA     Z,734
06D0:  XOR     #C0,W0
06D2:  BRA     Z,748
06D4:  XOR     #180,W0
06D6:  BRA     Z,752
06D8:  XOR     #300,W0
06DA:  BRA     Z,75C
06DC:  BRA     766
.................... 	{ 
.................... 		case S0 :{ initAvtomat(); newStateAvt = S1;    break;} 
06DE:  CALL    36A
06E2:  MOV     #1,W4
06E4:  MOV     W4,852
06E6:  BRA     770
.................... 		case S1 :{ resetCountZikl(); newStateAvt = S2;  break;} 
06E8:  CALL    3A6
06EC:  MOV     #2,W4
06EE:  MOV     W4,852
06F0:  BRA     770
.................... 		case S2 :{ setRotatePwm(1); newStateAvt = S3;  break;} 
06F2:  MOV.B   #1,W0L
06F4:  MOV.B   W0L,9BA
06F6:  CALL    426
06FA:  MOV     #4,W4
06FC:  MOV     W4,852
06FE:  BRA     770
.................... 		case S3 :{ if(waitStop()){ newStateAvt = S4;  }else{ newStateAvt = S3;} break;}	 
0700:  CALL    4E2
0704:  CP0.B   W0L
0706:  BRA     Z,70E
0708:  MOV     #8,W4
070A:  MOV     W4,852
070C:  BRA     712
070E:  MOV     #4,W4
0710:  MOV     W4,852
0712:  BRA     770
.................... 		case S4 :{ readData1Adc(); newStateAvt = S5; break;} 
0714:  CALL    5C6
0718:  MOV     #10,W4
071A:  MOV     W4,852
071C:  BRA     770
.................... 		case S5 :{ resetCountZikl(); newStateAvt = S6; break;} 
071E:  CALL    3A6
0722:  MOV     #20,W4
0724:  MOV     W4,852
0726:  BRA     770
.................... 		case S6 :{ setRotatePwm(0); newStateAvt = S7; break;} 
0728:  CLR.B   9BA
072A:  CALL    426
072E:  MOV     #40,W4
0730:  MOV     W4,852
0732:  BRA     770
.................... 		case S7 :{ if(waitStop()){ newStateAvt = S8;  }else{ newStateAvt = S7;} break;} 
0734:  CALL    4E2
0738:  CP0.B   W0L
073A:  BRA     Z,742
073C:  MOV     #80,W4
073E:  MOV     W4,852
0740:  BRA     746
0742:  MOV     #40,W4
0744:  MOV     W4,852
0746:  BRA     770
.................... 		case S8 :{ readData2Adc(); newStateAvt = S9; break;}	 
0748:  CALL    5D8
074C:  MOV     #100,W4
074E:  MOV     W4,852
0750:  BRA     770
.................... 		case S9 :{ sravnData(); newStateAvt = S10;  break;} 
0752:  CALL    5EA
0756:  MOV     #200,W4
0758:  MOV     W4,852
075A:  BRA     770
.................... 		case S10:{ stopTimer7(); setEnableSendData();  break;} 
075C:  CALL    654
0760:  CALL    67C
0764:  BRA     770
.................... 		default :{ stopTimer7(); setEnableSendData();  break;} 
0766:  CALL    654
076A:  CALL    67C
076E:  BRA     770
.................... 	}	 
.................... 	setDebugRS(); 
0770:  CALL    680
.................... 	updateState();  
0774:  CALL    684
....................  
0778:  BCLR.B  8A.0
077A:  MOV     #1A,W0
077C:  REPEAT  #C
077E:  MOV     [--W15],[W0--]
0780:  MOV     [--W15],W0
0782:  POP     32
0784:  POP     36
0786:  POP     42
0788:  RETFIE  
.................... } 
.................... void setDebugRS() 
.................... { 
.................... 	debugRS = 1; 
*
0680:  BSET.B  803.7
0682:  RETURN  
.................... } 
....................  
.................... void sendState( ) 
.................... { 
.................... 	if(debugRS ) 
.................... 	{ 
.................... 		switch(currentStateAvt) 
.................... 		{ 
.................... 			case S0 :{ sendRS(0x30); break;} 
.................... 			case S1 :{ sendRS(0x31); break;} 
.................... 			case S2 :{ sendRS(0x32); break;} 
.................... 			case S3 :{ sendRS(0x33); break;}	 
.................... 			case S4 :{ sendRS(0x34); break;} 
.................... 			case S5 :{ sendRS(0x35); break;} 
.................... 			case S6 :{ sendRS(0x36); break;} 
.................... 			case S7 :{ sendRS(0x37); break;} 
.................... 			case S8 :{ sendRS(0x38); break;}	 
.................... 			case S9 :{ sendRS(0x39);  break;} 
.................... 			case S10:{ sendRS(0x40);  break;} 
.................... 			default :{ sendRS(0x40);  break;} 
.................... 		} 
.................... 		debugRS = 0;  
.................... 	}	 
....................  
.................... } 
....................  
.................... //**************** 
.................... void sendDataCalibr() 
.................... { 
.................... 	if(enabSendCalibrData) 
*
1B94:  BTSS.B  803.5
1B96:  BRA     1C64
.................... 	{ 
.................... 	setLimitAdcMotor(&m3, minAdc1, maxAdc1); 
1B98:  MOV     #858,W4
1B9A:  MOV     W4,940
1B9C:  PUSH    80C
1B9E:  POP     942
1BA0:  PUSH    814
1BA2:  POP     944
1BA4:  CALL    1AB8
.................... 	setLimitAdcMotor(&m4, maxAdc2, minAdc2); // перевернута шкала АЦП 
1BA8:  MOV     #888,W4
1BAA:  MOV     W4,940
1BAC:  PUSH    816
1BAE:  POP     942
1BB0:  PUSH    80E
1BB2:  POP     944
1BB4:  CALL    1AB8
.................... 	setLimitAdcMotor(&m5, maxAdc3, minAdc3); // перевернута шкала АЦП 
1BB8:  MOV     #8B8,W4
1BBA:  MOV     W4,940
1BBC:  PUSH    818
1BBE:  POP     942
1BC0:  PUSH    810
1BC2:  POP     944
1BC4:  CALL    1AB8
.................... 	setLimitAdcMotor(&m6, minAdc4, maxAdc4); 
1BC8:  MOV     #8E8,W4
1BCA:  MOV     W4,940
1BCC:  PUSH    812
1BCE:  POP     942
1BD0:  PUSH    81A
1BD2:  POP     944
1BD4:  CALL    1AB8
.................... 	setOrError(&m3, END_CALIBR); 
1BD8:  MOV.B   #80,W0L
1BDA:  MOV.B   W0L,984
1BDC:  MOV     #858,W4
1BDE:  MOV     W4,982
1BE0:  CALL    914
.................... 	setOrError(&m4, END_CALIBR); 
1BE4:  MOV.B   #80,W0L
1BE6:  MOV.B   W0L,984
1BE8:  MOV     #888,W4
1BEA:  MOV     W4,982
1BEC:  CALL    914
.................... 	setOrError(&m5, END_CALIBR); 
1BF0:  MOV.B   #80,W0L
1BF2:  MOV.B   W0L,984
1BF4:  MOV     #8B8,W4
1BF6:  MOV     W4,982
1BF8:  CALL    914
.................... 	setOrError(&m6, END_CALIBR); 
1BFC:  MOV.B   #80,W0L
1BFE:  MOV.B   W0L,984
1C00:  MOV     #8E8,W4
1C02:  MOV     W4,982
1C04:  CALL    914
.................... 	updateError(&m3); 
1C08:  MOV     #858,W4
1C0A:  MOV     W4,940
1C0C:  CALL    1B5E
.................... 	updateError(&m4); 
1C10:  MOV     #888,W4
1C12:  MOV     W4,940
1C14:  CALL    1B5E
.................... 	updateError(&m5); 
1C18:  MOV     #8B8,W4
1C1A:  MOV     W4,940
1C1C:  CALL    1B5E
.................... 	updateError(&m6); 
1C20:  MOV     #8E8,W4
1C22:  MOV     W4,940
1C24:  CALL    1B5E
.................... 	if(errorRotate&ERROR_WAIT) 
1C28:  MOV.B   84C,W0L
1C2A:  SE      W0,W0
1C2C:  AND     W0,#10,W0
1C2E:  CP0     W0
1C30:  BRA     Z,1C62
.................... 	{ 
.................... 		setOrError(&m3, ERROR_CLBR); 
1C32:  MOV.B   #40,W0L
1C34:  MOV.B   W0L,984
1C36:  MOV     #858,W4
1C38:  MOV     W4,982
1C3A:  CALL    914
.................... 		setOrError(&m4, ERROR_CLBR); 
1C3E:  MOV.B   #40,W0L
1C40:  MOV.B   W0L,984
1C42:  MOV     #888,W4
1C44:  MOV     W4,982
1C46:  CALL    914
.................... 		setOrError(&m5, ERROR_CLBR); 
1C4A:  MOV.B   #40,W0L
1C4C:  MOV.B   W0L,984
1C4E:  MOV     #8B8,W4
1C50:  MOV     W4,982
1C52:  CALL    914
.................... 		setOrError(&m6, ERROR_CLBR); 
1C56:  MOV.B   #40,W0L
1C58:  MOV.B   W0L,984
1C5A:  MOV     #8E8,W4
1C5C:  MOV     W4,982
1C5E:  CALL    914
....................  
.................... 	} 
.................... 	 
.................... 	/*	sendRS(adress);  
.................... 		sendRS(COM_RUN_CALIBR); 
.................... 		sendRS16(minADC1); 
.................... 		sendRS16(minADC2); 
.................... 		sendRS16(minADC3); 
.................... 		sendRS16(minADC4); 
.................... 		sendRS16(maxADC1); 
.................... 		sendRS16(maxADC2); 
.................... 		sendRS16(maxADC3); 
.................... 		sendRS16(maxADC4); 
.................... 		sendRS(errorRotate); */ 
.................... 		enabSendCalibrData = 0;  
1C62:  BCLR.B  803.5
.................... 	} 
1C64:  RETURN  
.................... 	 
.................... 	 
.................... } 
.................... //**************** 
.................... void setEnableSendData() 
.................... { 
.................... 	enabSendCalibrData = 1;  
*
067C:  BSET.B  803.5
067E:  RETURN  
.................... 	 
.................... } 
.................... //**************** 
.................... void readData1Adc() 
.................... { 
.................... 	readValADC11 = valAdc1; 
*
05C6:  PUSH    804
05C8:  POP     83C
.................... 	readValADC21 = valAdc2; 
05CA:  PUSH    806
05CC:  POP     840
.................... 	readValADC31 = valAdc3; 
05CE:  PUSH    808
05D0:  POP     844
.................... 	readValADC41 = valAdc4;  
05D2:  PUSH    80A
05D4:  POP     848
05D6:  RETURN  
.................... } 
....................  
.................... void readData2Adc() 
.................... { 
.................... 	readValADC12 = valAdc1; 
05D8:  PUSH    804
05DA:  POP     83E
.................... 	readValADC22 = valAdc2; 
05DC:  PUSH    806
05DE:  POP     842
.................... 	readValADC32 = valAdc3; 
05E0:  PUSH    808
05E2:  POP     846
.................... 	readValADC42 = valAdc4;  
05E4:  PUSH    80A
05E6:  POP     84A
05E8:  RETURN  
.................... } 
....................  
.................... //**************** 
.................... int1 waitStop() 
*
04E2:  MOV     W5,[W15++]
04E4:  MOV     W6,[W15++]
04E6:  MOV     W7,[W15++]
04E8:  MOV     W8,[W15++]
04EA:  BCLR.B  9BA.0
.................... { 
.................... 	int1 boll = 0;  
.................... 	tempValADC11[indexDataRead] = valAdc1; 
04EC:  MOV     856,W4
04EE:  MUL.UU  W4,#2,W0
04F0:  MOV     #81C,W4
04F2:  ADD     W0,W4,W5
04F4:  MOV     804,W4
04F6:  MOV     W4,[W5+#0]
.................... 	tempValADC12[indexDataRead] = valAdc2; 
04F8:  MOV     856,W4
04FA:  MUL.UU  W4,#2,W0
04FC:  MOV     #824,W4
04FE:  ADD     W0,W4,W5
0500:  MOV     806,W4
0502:  MOV     W4,[W5+#0]
.................... 	tempValADC13[indexDataRead] = valAdc3; 
0504:  MOV     856,W4
0506:  MUL.UU  W4,#2,W0
0508:  MOV     #82C,W4
050A:  ADD     W0,W4,W5
050C:  MOV     808,W4
050E:  MOV     W4,[W5+#0]
.................... 	tempValADC14[indexDataRead] = valAdc4; 
0510:  MOV     856,W4
0512:  MUL.UU  W4,#2,W0
0514:  MOV     #834,W4
0516:  ADD     W0,W4,W5
0518:  MOV     80A,W4
051A:  MOV     W4,[W5+#0]
.................... 	indexDataRead++;  
051C:  INC     0856
.................... 	if(indexDataRead>=SIZE_TEMP_ADC) 
051E:  MOV     856,W4
0520:  CP      W4,#4
0522:  BRA     LT,526
.................... 	{ 
.................... 		indexDataRead = 0;  
0524:  CLR     856
.................... 	} 
.................... 	int1 a = getFullMasCalibr(tempValADC11[0], tempValADC11[1], tempValADC11[2], tempValADC11[3]);  
.................... 	int1 b = getFullMasCalibr(tempValADC12[0], tempValADC12[1], tempValADC12[2], tempValADC12[3]); 
.................... 	int1 c = getFullMasCalibr(tempValADC13[0], tempValADC13[1], tempValADC13[2], tempValADC13[3]); 
.................... 	int1 d = getFullMasCalibr(tempValADC14[0], tempValADC14[1], tempValADC14[2], tempValADC14[3]);  
0526:  PUSH    81C
0528:  POP     9BC
052A:  PUSH    81E
052C:  POP     9BE
052E:  PUSH    820
0530:  POP     9C0
0532:  PUSH    822
0534:  POP     9C2
0536:  CALL    486
053A:  BCLR.B  9BA.1
053C:  BTSC.B  0.0
053E:  BSET.B  9BA.1
0540:  PUSH    824
0542:  POP     9BC
0544:  PUSH    826
0546:  POP     9BE
0548:  PUSH    828
054A:  POP     9C0
054C:  PUSH    82A
054E:  POP     9C2
0550:  CALL    486
0554:  BCLR.B  9BA.2
0556:  BTSC.B  0.0
0558:  BSET.B  9BA.2
055A:  PUSH    82C
055C:  POP     9BC
055E:  PUSH    82E
0560:  POP     9BE
0562:  PUSH    830
0564:  POP     9C0
0566:  PUSH    832
0568:  POP     9C2
056A:  CALL    486
056E:  BCLR.B  9BA.3
0570:  BTSC.B  0.0
0572:  BSET.B  9BA.3
0574:  PUSH    834
0576:  POP     9BC
0578:  PUSH    836
057A:  POP     9BE
057C:  PUSH    838
057E:  POP     9C0
0580:  PUSH    83A
0582:  POP     9C2
0584:  CALL    486
0588:  BCLR.B  9BA.4
058A:  BTSC.B  0.0
058C:  BSET.B  9BA.4
.................... 	if(((a&b)&(c&d))) 
058E:  CLR     W0
0590:  BTSC.B  9BA.1
0592:  INC     W0,W0
0594:  MOV.B   W0L,W6L
0596:  CLR     W0
0598:  BTSC.B  9BA.2
059A:  INC     W0,W0
059C:  AND.B   W6L,W0L,W5L
059E:  CLR     W0
05A0:  BTSC.B  9BA.3
05A2:  INC     W0,W0
05A4:  MOV.B   W0L,W8L
05A6:  CLR     W0
05A8:  BTSC.B  9BA.4
05AA:  INC     W0,W0
05AC:  AND.B   W8L,W0L,W0L
05AE:  AND.B   W5L,W0L,W0L
05B0:  CP0.B   W0L
05B2:  BRA     Z,5B6
.................... 	{ 
.................... 		boll = 1;  
05B4:  BSET.B  9BA.0
.................... 	}		 
.................... 	return boll;  
05B6:  CLR     W0
05B8:  BTSC.B  9BA.0
05BA:  INC     W0,W0
05BC:  MOV     [--W15],W8
05BE:  MOV     [--W15],W7
05C0:  MOV     [--W15],W6
05C2:  MOV     [--W15],W5
05C4:  RETURN  
.................... } 
.................... //****************************** 
.................... void sravnData() 
.................... { 
.................... 	if(readValADC11>=readValADC12)  
*
05EA:  MOV     83E,W0
05EC:  MOV     83C,W4
05EE:  CP      W4,W0
05F0:  BRA     LT,5FC
.................... 	{  
.................... 		maxAdc1 = readValADC11;  
05F2:  PUSH    83C
05F4:  POP     814
.................... 		minAdc1 = readValADC12; 
05F6:  PUSH    83E
05F8:  POP     80C
.................... 	} 
05FA:  BRA     604
.................... 	else 
.................... 	{ 
.................... 		maxAdc1 = readValADC12;  
05FC:  PUSH    83E
05FE:  POP     814
.................... 		minAdc1 = readValADC11; 
0600:  PUSH    83C
0602:  POP     80C
.................... 	} 
....................  
.................... 	if(readValADC21>=readValADC22)  
0604:  MOV     842,W0
0606:  MOV     840,W4
0608:  CP      W4,W0
060A:  BRA     LT,616
.................... 	{  
.................... 		maxAdc2 = readValADC21;  
060C:  PUSH    840
060E:  POP     816
.................... 		minAdc2 = readValADC22; 
0610:  PUSH    842
0612:  POP     80E
.................... 	} 
0614:  BRA     61E
.................... 	else 
.................... 	{ 
.................... 		maxAdc2 = readValADC22;  
0616:  PUSH    842
0618:  POP     816
.................... 		minAdc2 = readValADC21; 
061A:  PUSH    840
061C:  POP     80E
.................... 	} 
....................  
.................... 	if(readValADC31>=readValADC32)  
061E:  MOV     846,W0
0620:  MOV     844,W4
0622:  CP      W4,W0
0624:  BRA     LT,630
.................... 	{  
.................... 		maxAdc3 = readValADC31;  
0626:  PUSH    844
0628:  POP     818
.................... 		minAdc3 = readValADC32; 
062A:  PUSH    846
062C:  POP     810
.................... 	} 
062E:  BRA     638
.................... 	else 
.................... 	{ 
.................... 		maxAdc3 = readValADC32;  
0630:  PUSH    846
0632:  POP     818
.................... 		minAdc3 = readValADC31; 
0634:  PUSH    844
0636:  POP     810
.................... 	} 
....................  
.................... 	if(readValADC41>=readValADC42)  
0638:  MOV     84A,W0
063A:  MOV     848,W4
063C:  CP      W4,W0
063E:  BRA     LT,64A
.................... 	{  
.................... 		maxAdc4 = readValADC41;  
0640:  PUSH    848
0642:  POP     81A
.................... 		minAdc4 = readValADC42; 
0644:  PUSH    84A
0646:  POP     812
.................... 	} 
0648:  BRA     652
.................... 	else 
.................... 	{ 
.................... 		maxAdc4 = readValADC42;  
064A:  PUSH    84A
064C:  POP     81A
.................... 		minAdc4 = readValADC41; 
064E:  PUSH    848
0650:  POP     812
.................... 	} 
0652:  RETURN  
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... void setRotatePwm(int1 b) 
.................... { 
....................  
.................... 		if(b) 
*
0426:  CP0.B   9BA
0428:  BRA     Z,45C
.................... 		{ 
.................... 			testPWM(3, 1);  
042A:  MOV.B   #3,W0L
042C:  MOV.B   W0L,9BC
042E:  MOV.B   #1,W0L
0430:  MOV.B   W0L,9BD
0432:  CALL    3AE
.................... 			testPWM(4, 1); 
0436:  MOV.B   #4,W0L
0438:  MOV.B   W0L,9BC
043A:  MOV.B   #1,W0L
043C:  MOV.B   W0L,9BD
043E:  CALL    3AE
.................... 			testPWM(5, 1); 
0442:  MOV.B   #5,W0L
0444:  MOV.B   W0L,9BC
0446:  MOV.B   #1,W0L
0448:  MOV.B   W0L,9BD
044A:  CALL    3AE
.................... 			testPWM(6, 1); 
044E:  MOV.B   #6,W0L
0450:  MOV.B   W0L,9BC
0452:  MOV.B   #1,W0L
0454:  MOV.B   W0L,9BD
0456:  CALL    3AE
.................... 		} 
045A:  BRA     484
.................... 		else 
.................... 		{ 
.................... 			testPWM(3, 0);  
045C:  MOV.B   #3,W0L
045E:  MOV.B   W0L,9BC
0460:  CLR.B   9BD
0462:  CALL    3AE
.................... 			testPWM(4, 0); 
0466:  MOV.B   #4,W0L
0468:  MOV.B   W0L,9BC
046A:  CLR.B   9BD
046C:  CALL    3AE
.................... 			testPWM(5, 0); 
0470:  MOV.B   #5,W0L
0472:  MOV.B   W0L,9BC
0474:  CLR.B   9BD
0476:  CALL    3AE
.................... 			testPWM(6, 0); 
047A:  MOV.B   #6,W0L
047C:  MOV.B   W0L,9BC
047E:  CLR.B   9BD
0480:  CALL    3AE
.................... 		} 
0484:  RETURN  
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... void readCalibrTwo() 
.................... { 
.................... 	if((valAdc1&0xFFF0)<(minAdc1&0xFFF0)) 
.................... 	{ 
.................... 		maxAdc1 = minAdc1;  
.................... 		minAdc1 = valAdc1;  
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		maxAdc1 = valAdc1;  
.................... 	} 
....................  
.................... 	if((valAdc2&0xFFF0)<(minAdc2&0xFFF0)) 
.................... 	{ 
.................... 		maxAdc2 = minAdc2;  
.................... 		minAdc2 = valAdc2;  
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		maxAdc2 = valAdc2;  
.................... 	} 
....................  
.................... 	if((valAdc3&0xFFF0)<(minAdc3&0xFFF0)) 
.................... 	{ 
.................... 		maxAdc3 = minAdc3;  
.................... 		minAdc3 = valAdc3;  
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		maxAdc3 = valAdc3;  
.................... 	} 
....................  
.................... 	if((valAdc4&0xFFF0)<(minAdc4&0xFFF0)) 
.................... 	{ 
.................... 		maxAdc4 = minAdc4;  
.................... 		minAdc4 = valAdc4;  
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		maxAdc4 = valAdc4;  
.................... 	} 
.................... } 
....................  
.................... int1 getFullMasCalibr(int16 a, int16 b, int16 c, int16 d)  
0486:  MOV     W5,[W15++]
0488:  MOV     W6,[W15++]
.................... { 
....................  
.................... 	if((((a&ACCURACY_ADC)==(b&ACCURACY_ADC))&((c&ACCURACY_ADC)==(d&ACCURACY_ADC)))&((a&ACCURACY_ADC)==(c&ACCURACY_ADC))) 
048A:  MOV     #FFF0,W0
048C:  AND     9BC,W0
048E:  MOV     W0,W5
0490:  MOV     #FFF0,W0
0492:  AND     9BE,W0
0494:  CP      W5,W0
0496:  BRA     Z,49C
0498:  CLR.B   W0
049A:  BRA     49E
049C:  MOV.B   #1,W0L
049E:  MOV.B   W0L,W5L
04A0:  MOV     #FFF0,W0
04A2:  AND     9C0,W0
04A4:  MOV     W0,W6
04A6:  MOV     #FFF0,W0
04A8:  AND     9C2,W0
04AA:  CP      W6,W0
04AC:  BRA     Z,4B2
04AE:  CLR.B   W0
04B0:  BRA     4B4
04B2:  MOV.B   #1,W0L
04B4:  AND.B   W5L,W0L,W5L
04B6:  MOV     #FFF0,W0
04B8:  AND     9BC,W0
04BA:  MOV     W0,W6
04BC:  MOV     #FFF0,W0
04BE:  AND     9C0,W0
04C0:  CP      W6,W0
04C2:  BRA     Z,4C8
04C4:  CLR.B   W0
04C6:  BRA     4CA
04C8:  MOV.B   #1,W0L
04CA:  AND.B   W5L,W0L,W0L
04CC:  CP0.B   W0L
04CE:  BRA     Z,4D8
.................... 	{ 
.................... 		return 1;  
04D0:  MOV.B   #1,W0L
04D2:  MOV.B   W0L,0
04D4:  BRA     4DC
.................... 	} 
04D6:  BRA     4DC
.................... 	else 
.................... 	{ 
.................... 		return 0;  
04D8:  CLR.B   0
04DA:  BRA     4DC
.................... 	} 
04DC:  MOV     [--W15],W6
04DE:  MOV     [--W15],W5
04E0:  RETURN  
....................  
.................... } 
....................  
....................  
.................... #include "motor.c" 
.................... #include "motor.h" 
.................... #ifndef MOTOR_H 
.................... #define MOTOR_H 
....................  
.................... //#define MIN_ERROR  2.0f // минимальная ошибка для доворота  
....................  
.................... #define MIN_DADC 0x00FF //минимальная разница между граничными значениями АЦП 
....................  
.................... // Error 
.................... // bits 
.................... #define END_CALIBR    0x80 // флаг окончания калибровки 
.................... #define ERROR_CLBR   0x40 // вышло время калибровки, значения не прочитались 
.................... #define ERR_PWR_ANALOG_ON (0x20) // силовая часть включена 
.................... #define ERR_PWR_KZ    	   (0x10) // замыкание силовой части  
.................... #define ERR_DADC      0x08 //(dADC<MIN_ADC) // мотор не крутится положение макс и мин ацп менее MIN_DADC  
.................... #define ERR_VADC2_B   0x04 //vAdc1<vAdc2 // определяет верх и низ 
.................... #define ERR_VADC1_B   0x02 //vAdc1>vAdc2 // определяет верх и низ 
.................... #define ERR_VADC_RAVN 0x01 //vAdc1=vAdc2 // калибровки не было  
.................... //#define MAX_INT_ERROR 50     
.................... //#define MIN_INT_ERROR (-50)  
....................  
....................  
.................... typedef struct MotorAs 
.................... { 
.................... 	int canalPwm;  // пин ШИМ 
.................... 	int1 upValue; //флаг направления движения, вводит относительный верх и  низ у нескольких моторов 
.................... 	int16 minValAdc; //минимальное значение ацп на одном краю шкалы 
.................... 	int16 maxValAdc; //максимальное значение ацп на другом краю шкалы 
.................... 	int16 oldValAdc; // прошлое значение используемое для установки  
.................... 	int16 newValue; // новое значение в которое необходимо перейти стрелке 
.................... 	float dAdc; 	// разность макс и мин значения АЦП 
.................... 	float kP;  // 	(m->maxSpeed/m->dAdc) где (m->maxSpeed = POL_POL_PERIOD(default)) знач ШИМ для макс  
.................... 				//скорости(1/4Шим(90градусов сдвиг между каналами ШИМ))))  
.................... 				// и m->dAdc диапазон шкалы в значениях АЦП 
.................... 	float kD;  
.................... 	float kI;  
.................... 	int8 Error;    // хранит ошибки и текущее состояние  
.................... 	int16 minSpeed; // минимальное значение ШИМ при котором стрелка двигается 
.................... 	int16 maxSpeed; // максимальное значение ШИМ при котором стрелка двигается (1/4 значения счетчика ШИМ) 
.................... 	int16 maxAccel; // максимальное ускорение 
.................... 	int16 minAccel; // минимальное ускорение  
.................... 	int16 oldSpeed; // значение скорости в прошлый перерасчет положения 
.................... 	int1 enabRotate; // разрешение вращения  
.................... 	signed int maxIEr; // максимальная ошибка интегр. сост  
.................... 	signed int minIEr; // минимальная ошибка интегр. сост 
.................... 	signed int integrError; 
.................... } Motor;  
....................  
....................   
....................   
.................... void initMotor(Motor * m, int cPwm, int16 tPwm, int16 vAdc1, int16 vAdc2);  
.................... void setLimitAdcMotor(Motor *m, int16 vAdc1, int16 vAdc2); 
.................... void setMinSpeed(Motor *m,int16 data);  
.................... void setMaxSpeed(Motor *m,int16 data);     
.................... void setRotate(Motor *m, int16 currentData, int16 newData);  
.................... int16 difSost(Motor *m, float data);  
.................... int16 intSost(Motor *m, int1 dir, float data);  
.................... int16 proSost(Motor *m, int16 data, float eData);  
.................... void setNewValueMotor (Motor *m, int16 data);  
.................... void setK(Motor *m); 
.................... void setMaxAccel(Motor *m, int16 data);   
....................  
.................... void setIntError(Motor *m,signed int minE, signed int maxE); 
.................... void setOrError(Motor *m, int8 data);  
.................... void setAndError(Motor *m, int8 data);  
.................... //void setError(Motor *m, int8 data);  
.................... void updateError(Motor *m); 
.................... //void setMinRotate(int16 min_error);   
....................  
.................... //get setting motor 
.................... int16 getMinSpeed(Motor *m);  
.................... int16 getMaxSpeed(Motor *m);  
.................... int16 getMinAccel(Motor *m);  
.................... int16 getMaxAccel(Motor *m);  
.................... int8  getError(Motor *m);  
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... void initMotor(Motor * m, int cPwm,  int16 tPwm, int16 vAdc1, int16 vAdc2) 
*
09D2:  MOV     W5,[W15++]
09D4:  MOV     W6,[W15++]
.................... { 
.................... 	m->canalPwm = cPwm;  
09D6:  MOV     940,W5
09D8:  MOV     942,W4
09DA:  MOV     W4,[W5+#0]
.................... 	m->upValue = 0;   
09DC:  MOV     #2,W0
09DE:  ADD     940,W0
09E0:  MOV     W0,W5
09E2:  MOV     #FE,W4
09E4:  AND.B   W4L,[W5],[W5]
.................... 	m->minSpeed = 100; 
09E6:  MOV     #1E,W0
09E8:  ADD     940,W0
09EA:  MOV     W0,W5
09EC:  MOV.B   #64,W0L
09EE:  MOV.B   W0L,[W5]
09F0:  MOV.B   #0,W0L
09F2:  MOV.B   W0L,[W5+#1]
.................... 	m->maxSpeed = POL_POL_PERIOD;   
09F4:  MOV     #20,W0
09F6:  ADD     940,W0
09F8:  MOV     W0,W5
09FA:  MOV.B   #35,W0L
09FC:  MOV.B   W0L,[W5]
09FE:  MOV.B   #C,W0L
0A00:  MOV.B   W0L,[W5+#1]
.................... 	m->enabRotate = 1; 
0A02:  MOV     #28,W0
0A04:  ADD     940,W0
0A06:  MOV     W0,W5
0A08:  MOV     #1,W4
0A0A:  IOR.B    W4L,  [W5],[W5]
.................... 	m->Error = 0;  
0A0C:  MOV     #1C,W0
0A0E:  ADD     940,W0
0A10:  MOV     W0,W5
0A12:  CLR.B   [W5]
.................... 	m->oldValAdc = 0;  
0A14:  MOV     #8,W0
0A16:  ADD     940,W0
0A18:  MOV     W0,W5
0A1A:  CLR.B   [W5]
0A1C:  MOV.B   #0,W0L
0A1E:  MOV.B   W0L,[W5+#1]
.................... 	m->newValue = 0;  
0A20:  MOV     #A,W0
0A22:  ADD     940,W0
0A24:  MOV     W0,W5
0A26:  CLR.B   [W5]
0A28:  MOV.B   #0,W0L
0A2A:  MOV.B   W0L,[W5+#1]
.................... 	m->kP = 0;  
0A2C:  MOV     #10,W0
0A2E:  ADD     940,W0
0A30:  MOV     W0,W5
0A32:  CLR.B   [W5]
0A34:  MOV.B   #0,W0L
0A36:  MOV.B   W0L,[W5+#1]
0A38:  MOV.B   #0,W0L
0A3A:  MOV.B   W0L,[W5+#2]
0A3C:  MOV.B   #0,W0L
0A3E:  MOV.B   W0L,[W5+#3]
.................... 	m->kD = 0;  
0A40:  MOV     #14,W0
0A42:  ADD     940,W0
0A44:  MOV     W0,W5
0A46:  CLR.B   [W5]
0A48:  MOV.B   #0,W0L
0A4A:  MOV.B   W0L,[W5+#1]
0A4C:  MOV.B   #0,W0L
0A4E:  MOV.B   W0L,[W5+#2]
0A50:  MOV.B   #0,W0L
0A52:  MOV.B   W0L,[W5+#3]
.................... 	m->minAccel = 0;  
0A54:  MOV     #24,W0
0A56:  ADD     940,W0
0A58:  MOV     W0,W5
0A5A:  CLR.B   [W5]
0A5C:  MOV.B   #0,W0L
0A5E:  MOV.B   W0L,[W5+#1]
.................... 	m->maxAccel = POL_POL_PERIOD;  
0A60:  MOV     #22,W0
0A62:  ADD     940,W0
0A64:  MOV     W0,W5
0A66:  MOV.B   #35,W0L
0A68:  MOV.B   W0L,[W5]
0A6A:  MOV.B   #C,W0L
0A6C:  MOV.B   W0L,[W5+#1]
.................... 	m->oldSpeed = 0; 
0A6E:  MOV     #26,W0
0A70:  ADD     940,W0
0A72:  MOV     W0,W5
0A74:  CLR.B   [W5]
0A76:  MOV.B   #0,W0L
0A78:  MOV.B   W0L,[W5+#1]
.................... 	m->integrError = 0; 
0A7A:  MOV     #2E,W0
0A7C:  ADD     940,W0
0A7E:  MOV     W0,W5
0A80:  CLR.B   [W5]
0A82:  MOV.B   #0,W0L
0A84:  MOV.B   W0L,[W5+#1]
.................... 	m->maxIEr = (m->minSpeed<<3);  
0A86:  MOV     #2A,W0
0A88:  ADD     940,W0
0A8A:  MOV     W0,W5
0A8C:  MOV     #1E,W0
0A8E:  ADD     940,W0
0A90:  MOV     [W0],W6
0A92:  SL      W6,#3,W0
0A94:  MOV     W0,[W5]
.................... 	m->minIEr = ((m->minSpeed<<3)*(-1));   
0A96:  MOV     #2C,W0
0A98:  ADD     940,W0
0A9A:  MOV     W0,W5
0A9C:  MOV     #1E,W0
0A9E:  ADD     940,W0
0AA0:  MOV     [W0],W6
0AA2:  SL      W6,#3,W6
0AA4:  MOV     #FFFF,W4
0AA6:  MUL.US  W6,W4,W0
0AA8:  MOV     W0,[W5]
0AAA:  MOV     [--W15],W6
0AAC:  MOV     [--W15],W5
0AAE:  RETURN  
....................  
.................... } 
....................  
.................... void updateError(Motor *m) 
*
1B5E:  MOV     W5,[W15++]
1B60:  MOV     #6,W0
1B62:  ADD     940,W0
1B64:  MOV     [W0],W5
1B66:  MOV     #4,W0
1B68:  ADD     940,W0
1B6A:  MOV     W0,W4
1B6C:  MOV     [W4],W0
1B6E:  SUB     W5,W0,W0
1B70:  MOV     W0,942
.................... { 
.................... 	int16 dAdc  = (m->maxValAdc - m->minValAdc); 
.................... 	if(dAdc < MIN_DADC) 
1B72:  MOV     942,W4
1B74:  MOV     #FF,W3
1B76:  CP      W3,W4
1B78:  BRA     LE,1B90
.................... 	{ 
.................... 		setOrError(m, ERR_DADC);  
1B7A:  MOV.B   #8,W0L
1B7C:  MOV.B   W0L,984
1B7E:  PUSH    940
1B80:  POP     982
1B82:  CALL    914
.................... 		m->enabRotate = 0;  
1B86:  MOV     #28,W0
1B88:  ADD     940,W0
1B8A:  MOV     W0,W5
1B8C:  MOV     #FE,W4
1B8E:  AND.B   W4L,[W5],[W5]
.................... 	} 
1B90:  MOV     [--W15],W5
1B92:  RETURN  
.................... 	 
....................  
.................... } 
....................  
....................  
.................... int8 getError(Motor *m) 
*
0BB4:  MOV     #1C,W0
0BB6:  ADD     97E,W0
0BB8:  MOV     980,W4
0BBA:  MOV.B   [W0+#0],W4L
0BBC:  MOV     W4,980
.................... { 
.................... 	int8 dataError = m->Error;  
.................... 	return dataError;  
0BBE:  MOV.B   980,W0L
0BC0:  MOV.B   W0L,0
0BC2:  RETURN  
.................... } 
....................  
....................  
.................... void setOrError(Motor *m, int8 data) 
*
0914:  MOV     W5,[W15++]
.................... { 
.................... 	m->Error |= (data&0xFF);   
0916:  MOV     #1C,W0
0918:  ADD     982,W0
091A:  MOV     W0,W5
091C:  MOV.B   984,W0L
091E:  SE      W0,W0
0920:  AND     #FF,W0
0922:  MOV     W0,W0
0924:  SWAP    W0
0926:  IOR.B    W0L,  [++W5],W0L
0928:  SWAP    W0
092A:  IOR.B    W0L,  [--W5],W0L
092C:  MOV.B   W0L,[W5]
092E:  MOV     [--W15],W5
0930:  RETURN  
.................... } 
....................  
.................... void setAndError(Motor *m, int8 data) 
*
08F4:  MOV     W5,[W15++]
.................... { 
.................... 	m->Error &= (~(data&0xFF));   
08F6:  MOV     #1C,W0
08F8:  ADD     982,W0
08FA:  MOV     W0,W5
08FC:  MOV.B   984,W0L
08FE:  SE      W0,W0
0900:  AND     #FF,W0
0902:  COM     W0,W0
0904:  MOV     W0,W0
0906:  SWAP    W0
0908:  AND.B   W0L,[++W5],W0L
090A:  SWAP    W0
090C:  AND.B   W0L,[--W5],W0L
090E:  MOV.B   W0L,[W5]
0910:  MOV     [--W15],W5
0912:  RETURN  
.................... } 
....................  
.................... /*void setError(Motor *m, int8 data) 
.................... { 
.................... 	m->Error = data; 
.................... }*/ 
....................  
.................... void setLimitAdcMotor(Motor *m, int16 vAdc1, int16 vAdc2) 
*
1AB8:  MOV     W5,[W15++]
1ABA:  MOV     W6,[W15++]
.................... { 
.................... 	if(vAdc1>vAdc2) 
1ABC:  MOV     944,W0
1ABE:  MOV     942,W4
1AC0:  CP      W4,W0
1AC2:  BRA     LE,1AF0
.................... 	{ 
.................... 		m->upValue = 0;  
1AC4:  MOV     #2,W0
1AC6:  ADD     940,W0
1AC8:  MOV     W0,W5
1ACA:  MOV     #FE,W4
1ACC:  AND.B   W4L,[W5],[W5]
.................... 		m->minValAdc = vAdc2;  
1ACE:  MOV     #4,W0
1AD0:  ADD     940,W0
1AD2:  MOV     W0,W5
1AD4:  MOV     944,W4
1AD6:  MOV     W4,[W5+#0]
.................... 		m->maxValAdc = vAdc1;  
1AD8:  MOV     #6,W0
1ADA:  ADD     940,W0
1ADC:  MOV     W0,W5
1ADE:  MOV     942,W4
1AE0:  MOV     W4,[W5+#0]
.................... 		setOrError(m, ERR_VADC1_B); 
1AE2:  MOV.B   #2,W0L
1AE4:  MOV.B   W0L,984
1AE6:  PUSH    940
1AE8:  POP     982
1AEA:  CALL    914
.................... 	} 
1AEE:  BRA     1B30
.................... 	else 
.................... 	{	 
.................... 		if(vAdc1<vAdc2) 
1AF0:  MOV     942,W0
1AF2:  MOV     944,W4
1AF4:  CP      W4,W0
1AF6:  BRA     LE,1B24
.................... 		{	 
.................... 			m->upValue = 1;  
1AF8:  MOV     #2,W0
1AFA:  ADD     940,W0
1AFC:  MOV     W0,W5
1AFE:  MOV     #1,W4
1B00:  IOR.B    W4L,  [W5],[W5]
.................... 			m->minValAdc = vAdc1;  
1B02:  MOV     #4,W0
1B04:  ADD     940,W0
1B06:  MOV     W0,W5
1B08:  MOV     942,W4
1B0A:  MOV     W4,[W5+#0]
.................... 			m->maxValAdc = vAdc2; 
1B0C:  MOV     #6,W0
1B0E:  ADD     940,W0
1B10:  MOV     W0,W5
1B12:  MOV     944,W4
1B14:  MOV     W4,[W5+#0]
.................... 			setOrError(m, ERR_VADC2_B); 
1B16:  MOV.B   #4,W0L
1B18:  MOV.B   W0L,984
1B1A:  PUSH    940
1B1C:  POP     982
1B1E:  CALL    914
.................... 		 
.................... 		} 
1B22:  BRA     1B30
.................... 		else 
.................... 		{ 
.................... 			setOrError(m, ERR_VADC_RAVN); 
1B24:  MOV.B   #1,W0L
1B26:  MOV.B   W0L,984
1B28:  PUSH    940
1B2A:  POP     982
1B2C:  CALL    914
.................... 		} 
.................... 	}  
.................... 	m->dAdc = ((float)(m->maxValAdc - m->minValAdc)); 
1B30:  MOV     #C,W0
1B32:  ADD     940,W0
1B34:  MOV     W0,W5
1B36:  MOV     #6,W0
1B38:  ADD     940,W0
1B3A:  MOV     [W0],W6
1B3C:  MOV     #4,W0
1B3E:  ADD     940,W0
1B40:  MOV     W0,W4
1B42:  MOV     [W4],W0
1B44:  SUB     W6,W0,W0
1B46:  CALL    D2E
1B4A:  MOV     #0,W4
1B4C:  MOV     [W4++],[W5++]
1B4E:  MOV     [W4++],[W5++]
.................... 	setK(m);  
1B50:  PUSH    940
1B52:  POP     986
1B54:  CALL    EFA
1B58:  MOV     [--W15],W6
1B5A:  MOV     [--W15],W5
1B5C:  RETURN  
.................... //	m->newValue = m->maxValAdc;    
.................... }   
....................  
.................... void setMinSpeed(Motor *m, int16 data) 
*
0D78:  MOV     W5,[W15++]
0D7A:  MOV     W6,[W15++]
.................... { 
.................... 	m->minSpeed = data;  
0D7C:  MOV     #1E,W0
0D7E:  ADD     97E,W0
0D80:  MOV     W0,W5
0D82:  MOV     980,W4
0D84:  MOV     W4,[W5+#0]
.................... 	m->maxIEr = (m->minSpeed<<3);  
0D86:  MOV     #2A,W0
0D88:  ADD     97E,W0
0D8A:  MOV     W0,W5
0D8C:  MOV     #1E,W0
0D8E:  ADD     97E,W0
0D90:  MOV     [W0],W6
0D92:  SL      W6,#3,W0
0D94:  MOV     W0,[W5]
.................... 	m->minIEr = ((m->minSpeed<<3)*(-1)); 
0D96:  MOV     #2C,W0
0D98:  ADD     97E,W0
0D9A:  MOV     W0,W5
0D9C:  MOV     #1E,W0
0D9E:  ADD     97E,W0
0DA0:  MOV     [W0],W6
0DA2:  SL      W6,#3,W6
0DA4:  MOV     #FFFF,W4
0DA6:  MUL.US  W6,W4,W0
0DA8:  MOV     W0,[W5]
.................... 	m->kI = m->minSpeed;  
0DAA:  MOV     #18,W0
0DAC:  ADD     97E,W0
0DAE:  MOV     W0,W5
0DB0:  MOV     #1E,W0
0DB2:  ADD     97E,W0
0DB4:  MOV     W0,W4
0DB6:  MOV     [W4],W0
0DB8:  CALL    D2E
0DBC:  MOV     #0,W4
0DBE:  MOV     [W4++],[W5++]
0DC0:  MOV     [W4++],[W5++]
0DC2:  MOV     [--W15],W6
0DC4:  MOV     [--W15],W5
0DC6:  RETURN  
.................... } 
....................  
.................... void setK(Motor *m) 
*
0EFA:  MOV     W5,[W15++]
0EFC:  MOV     W6,[W15++]
0EFE:  MOV     W7,[W15++]
0F00:  MOV     W8,[W15++]
.................... { 
.................... 	if(m->dAdc>0) 
0F02:  MOV     #C,W0
0F04:  ADD     986,W0
0F06:  MOV     #A,W4
0F08:  MOV     [W0++],[W4++]
0F0A:  MOV     [W0++],[W4++]
0F0C:  MOV     #0,W0
0F0E:  MOV     #0,W1
0F10:  MOV     W5,W2
0F12:  MOV     W6,W3
0F14:  CALL    DC8
0F18:  BRA     NC,F46
.................... 	{ 
.................... 		m->kP = (m->maxSpeed/m->dAdc);  
0F1A:  MOV     #10,W0
0F1C:  ADD     986,W0
0F1E:  MOV     W0,W5
0F20:  MOV     #20,W0
0F22:  ADD     986,W0
0F24:  MOV     [W0],W6
0F26:  MOV     #C,W0
0F28:  ADD     986,W0
0F2A:  MOV     #E,W4
0F2C:  MOV     [W0++],[W4++]
0F2E:  MOV     [W0++],[W4++]
0F30:  MOV     W6,W0
0F32:  CALL    D2E
0F36:  MOV     W7,W2
0F38:  MOV     W8,W3
0F3A:  CALL    E30
0F3E:  MOV     #0,W4
0F40:  MOV     [W4++],[W5++]
0F42:  MOV     [W4++],[W5++]
.................... 	} 
0F44:  BRA     F62
.................... 	else 
.................... 	{ 
.................... 		m->Error = 0;  
0F46:  MOV     #1C,W0
0F48:  ADD     986,W0
0F4A:  MOV     W0,W5
0F4C:  CLR.B   [W5]
.................... 		m->kP = 1; 	 
0F4E:  MOV     #10,W0
0F50:  ADD     986,W0
0F52:  MOV     W0,W5
0F54:  CLR.B   [W5]
0F56:  MOV.B   #0,W0L
0F58:  MOV.B   W0L,[W5+#1]
0F5A:  MOV.B   #80,W0L
0F5C:  MOV.B   W0L,[W5+#2]
0F5E:  MOV.B   #3F,W0L
0F60:  MOV.B   W0L,[W5+#3]
.................... 	} 
.................... //	m->kD = (m->kP*0.3f); 
.................... 	//m->kI = 0.01;//m->minSpeed; 
.................... 	m->kI = m->minSpeed;  
0F62:  MOV     #18,W0
0F64:  ADD     986,W0
0F66:  MOV     W0,W5
0F68:  MOV     #1E,W0
0F6A:  ADD     986,W0
0F6C:  MOV     W0,W4
0F6E:  MOV     [W4],W0
0F70:  CALL    D2E
0F74:  MOV     #0,W4
0F76:  MOV     [W4++],[W5++]
0F78:  MOV     [W4++],[W5++]
0F7A:  MOV     [--W15],W8
0F7C:  MOV     [--W15],W7
0F7E:  MOV     [--W15],W6
0F80:  MOV     [--W15],W5
0F82:  RETURN  
.................... } 
....................  
.................... void setMaxSpeed(Motor *m,int16 data) 
0F84:  MOV     W5,[W15++]
.................... { 
.................... 	if(data>POL_POL_PERIOD) 
0F86:  MOV     980,W4
0F88:  MOV     #C35,W3
0F8A:  CP      W3,W4
0F8C:  BRA     GE,F9E
.................... 	{ 
.................... 		m->maxSpeed = POL_POL_PERIOD;		 
0F8E:  MOV     #20,W0
0F90:  ADD     97E,W0
0F92:  MOV     W0,W5
0F94:  MOV.B   #35,W0L
0F96:  MOV.B   W0L,[W5]
0F98:  MOV.B   #C,W0L
0F9A:  MOV.B   W0L,[W5+#1]
.................... 	} 
0F9C:  BRA     FA8
.................... 	else 
.................... 	{ 
.................... 		m->maxSpeed = data; 
0F9E:  MOV     #20,W0
0FA0:  ADD     97E,W0
0FA2:  MOV     W0,W5
0FA4:  MOV     980,W4
0FA6:  MOV     W4,[W5+#0]
.................... 	}  
....................  
.................... 	setK(m);  
0FA8:  PUSH    97E
0FAA:  POP     986
0FAC:  CALL    EFA
0FB0:  MOV     [--W15],W5
0FB2:  RETURN  
.................... } 
....................  
.................... int16 difSost(Motor *m, float data) 
*
1E5A:  MOV     W5,[W15++]
1E5C:  CLR     964
1E5E:  MOV     #1E,W0
1E60:  ADD     95E,W0
1E62:  MOV     [W0],W5
1E64:  MOV     W5,966
1E66:  LSR     966
.................... {	 
.................... 	int16 result = 0; 
.................... 	int16 d = (m->minSpeed>>1);    
.................... 	if(data>d)//(MIN_ERROR)) 
1E68:  MOV     966,W0
1E6A:  CALL    D2E
1E6E:  MOV     960,W2
1E70:  MOV     962,W3
1E72:  CALL    DC8
1E76:  BRA     NC,1E7C
.................... 	{ 
.................... 		result = d; //data*m->kD; //m->minSpeed>>1;  
1E78:  PUSH    966
1E7A:  POP     964
.................... 	} 
.................... 	return result;  
1E7C:  PUSH    964
1E7E:  POP     0
1E80:  MOV     [--W15],W5
1E82:  RETURN  
.................... } 
.................... int16  intSost(Motor *m,int1 dir,  float data) 
*
1D82:  MOV     W5,[W15++]
1D84:  MOV     W6,[W15++]
1D86:  CLR     962
.................... { 
.................... 	int16 result = 0; 
.................... 	 
.................... 	if(dir) 
1D88:  CP0.B   95C
1D8A:  BRA     Z,1DA0
.................... 	{ 
.................... 		m->integrError +=((int16)data);  
1D8C:  MOV     #2E,W0
1D8E:  ADD     95A,W0
1D90:  MOV     W0,W5
1D92:  MOV     95E,W0
1D94:  MOV     960,W1
1D96:  CALL    1D2A
1D9A:  MOV     W0,W6
1D9C:  ADD     W6,[W5],[W5]
.................... 	} 
1D9E:  BRA     1DB4
.................... 	else 
.................... 	{ 
.................... 		m->integrError -= ((int16)data); 
1DA0:  MOV     #2E,W0
1DA2:  ADD     95A,W0
1DA4:  MOV     W0,W5
1DA6:  MOV     95E,W0
1DA8:  MOV     960,W1
1DAA:  CALL    1D2A
1DAE:  MOV     W0,W6
1DB0:  MOV     [W5],W4
1DB2:  SUB     W4,W6,[W5]
.................... 	}	 
....................  
.................... 	if(m->integrError> m->maxIEr ) 
1DB4:  MOV     #2E,W0
1DB6:  ADD     95A,W0
1DB8:  MOV     [W0],W5
1DBA:  MOV     #2A,W0
1DBC:  ADD     95A,W0
1DBE:  MOV     W0,W4
1DC0:  MOV     [W4],W0
1DC2:  CP      W0,W5
1DC4:  BRA     GE,1DD2
.................... 	{ 
.................... 		m->integrError = m->maxIEr;  
1DC6:  MOV     #2E,W0
1DC8:  ADD     95A,W0
1DCA:  MOV     W0,W5
1DCC:  MOV     #2A,W0
1DCE:  ADD     95A,W0
1DD0:  MOV     [W0],[W5]
.................... 	} 
.................... 	 
.................... 	if(m->integrError< m->minIEr) 
1DD2:  MOV     #2E,W0
1DD4:  ADD     95A,W0
1DD6:  MOV     [W0],W5
1DD8:  MOV     #2C,W0
1DDA:  ADD     95A,W0
1DDC:  MOV     W0,W4
1DDE:  MOV     [W4],W0
1DE0:  CP      W5,W0
1DE2:  BRA     GE,1DF0
.................... 	{ 
.................... 		m->integrError = m->minIEr; 
1DE4:  MOV     #2E,W0
1DE6:  ADD     95A,W0
1DE8:  MOV     W0,W5
1DEA:  MOV     #2C,W0
1DEC:  ADD     95A,W0
1DEE:  MOV     [W0],[W5]
.................... 	} 
.................... 	 
.................... 	if(m->integrError<0) 
1DF0:  MOV     #2E,W0
1DF2:  ADD     95A,W0
1DF4:  MOV     [W0],W5
1DF6:  CP      W5,#0
1DF8:  BRA     GE,1E26
.................... 	{ 
.................... 		float d =  (((float)m->integrError)*(-0.1f)); 	 
1DFA:  MOV     #2E,W0
1DFC:  ADD     95A,W0
1DFE:  MOV     W0,W4
1E00:  MOV     [W4],W0
1E02:  CALL    D2E
1E06:  MOV     W0,W5
1E08:  MOV     W1,W6
1E0A:  MOV     W5,W0
1E0C:  MOV     W6,W1
1E0E:  MOV     #CCCD,W2
1E10:  MOV     #BDCC,W3
1E12:  CALL    1C66
1E16:  MOV     W0,964
1E18:  MOV     W1,966
.................... 		result = ((int16) d); 
1E1A:  MOV     964,W0
1E1C:  MOV     966,W1
1E1E:  CALL    1D2A
1E22:  MOV     W0,962
.................... 	} 
1E24:  BRA     1E50
.................... 	else 
.................... 	{ 
.................... 		float d = (((float)m->integrError)*(0.1f));  
1E26:  MOV     #2E,W0
1E28:  ADD     95A,W0
1E2A:  MOV     W0,W4
1E2C:  MOV     [W4],W0
1E2E:  CALL    D2E
1E32:  MOV     W0,W5
1E34:  MOV     W1,W6
1E36:  MOV     W5,W0
1E38:  MOV     W6,W1
1E3A:  MOV     #CCCD,W2
1E3C:  MOV     #3DCC,W3
1E3E:  CALL    1C66
1E42:  MOV     W0,968
1E44:  MOV     W1,96A
.................... 		result = ((int16) d); 
1E46:  MOV     968,W0
1E48:  MOV     96A,W1
1E4A:  CALL    1D2A
1E4E:  MOV     W0,962
.................... 	} 
.................... 	 
.................... 	//if(data>MIN_ERROR) 
.................... 	{ 
.................... 		 //result = ((int16)(data*m->kI)); 
.................... 		 //result = (((int16)m->integrError)&0xFFFF);    
.................... 		  
.................... 	} 
....................  
.................... 	return result;  
1E50:  PUSH    962
1E52:  POP     0
1E54:  MOV     [--W15],W6
1E56:  MOV     [--W15],W5
1E58:  RETURN  
.................... } 
....................  
.................... int16 proSost(Motor *m, int16 data, float eData) 
*
1D56:  MOV     #10,W0
1D58:  ADD     956,W0
1D5A:  MOV     W0,W4
1D5C:  MOV     #0,W3
1D5E:  MOV     [W4++],[W3++]
1D60:  MOV     [W4++],[W3++]
1D62:  MOV     W0,W2
1D64:  MOV     W1,W3
1D66:  MOV     95A,W0
1D68:  MOV     95C,W1
1D6A:  CALL    1C66
1D6E:  MOV     W0,95E
1D70:  MOV     W1,960
1D72:  MOV     95E,W0
1D74:  MOV     960,W1
1D76:  CALL    1D2A
1D7A:  MOV     W0,962
.................... { 
.................... 	 
.................... 	//float ps =((((float)(data*POL_POL_PERIOD))/m->dAdc)); 
.................... 	float ps =((float)(eData*m->kP)); 
.................... 	int16 newSpeed = ((int16) ps);  
....................  
.................... 	// введение ограничений на величину изменения АЦП между измерениями    
.................... 	// текущая скорость  
.................... /*	int16 Vtek = 0; 
.................... 	// ускорение  
.................... 	int16 Atek = 0;  
.................... 	 
.................... 	if(data>m->oldValAdc) 
.................... 	{ 
.................... 		Vtek = (data - m->oldValAdc); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		Vtek = (m->oldValAdc - data);  
.................... 	} 
.................... // speed ограничивается в kP 
.................... 	if(Vtek>m->oldSpeed) 
.................... 	{ 
.................... 		Atek = (Vtek - m->oldSpeed); 		 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		Atek = (m->oldSpeed - Vtek);  
.................... 	} 
.................... 	m->oldSpeed = Vtek;  
.................... 	int16 kor = 0;  
.................... 	 
.................... 	if(Atek>m->maxAccel) 
.................... 	{ 
.................... 		kor = Atek - m->maxAccel;  
.................... 	} 
.................... 	float nS; */ 
.................... /*	if(newSpeed>kor) 
.................... 	{ 
.................... 		nS =(((float) newSpeed)*0.9f); 
.................... 		newSpeed = ((int16) ns);   
....................  	}  */  
.................... 	return newSpeed; 
1D7C:  PUSH    962
1D7E:  POP     0
1D80:  RETURN  
.................... 	 
.................... } 
....................  
.................... void setNewValueMotor(Motor *m, int16 data) 
.................... { 
.................... 	m->newValue = (data&0xFFFF);  
....................  
.................... }  
....................  
.................... void setRotate(Motor *m, int16 currentDataS, int16 newData) 
*
1E84:  MOV     W5,[W15++]
1E86:  MOV     W6,[W15++]
1E88:  MOV     W7,[W15++]
1E8A:  MOV     W8,[W15++]
.................... {	 
....................  m->newValue = (newData&0xFFFE); 
1E8C:  MOV     #A,W0
1E8E:  ADD     942,W0
1E90:  MOV     W0,W5
1E92:  MOV     #FFFE,W0
1E94:  AND     946,W0
1E96:  MOV     W0,[W5]
.................... int16 currentData =  (currentDataS&0xFFFE); 
1E98:  PUSH    944
1E9A:  POP     948
1E9C:  MOV     #FFFE,W0
1E9E:  AND     948
.................... // проверка на завершение калибровки ацп 
.................... if(m->enabRotate) 
1EA0:  MOV     #28,W0
1EA2:  ADD     942,W0
1EA4:  MOV.B   [W0],W4L
1EA6:  BTSS    W4.0
1EA8:  BRA     21CA
.................... 	{ 
.................... 	 
.................... 		if((m->Error&0x02)|(m->Error&0x04)) // если ацп работает и значения отличаются 
1EAA:  MOV     #1C,W0
1EAC:  ADD     942,W0
1EAE:  MOV.B   [W0],W5L
1EB0:  SE      W5,W5
1EB2:  AND     W5,#2,W5
1EB4:  MOV     #1C,W0
1EB6:  ADD     942,W0
1EB8:  MOV.B   [W0],W7L
1EBA:  SE      W7,W7
1EBC:  AND     W7,#4,W0
1EBE:  IOR      W5,  W0,W0
1EC0:  CP0     W0
1EC2:  BRA     Z,21CA
.................... 		{ 
.................... 			int16 n = 0;  
.................... 			float error = 0;  
1EC4:  CLR     94A
1EC6:  CLR     94C
1EC8:  CLR     94E
.................... 			if(currentData>m->newValue)// направление движения 
1ECA:  MOV     #A,W0
1ECC:  ADD     942,W0
1ECE:  MOV     W0,W4
1ED0:  MOV     [W4],W0
1ED2:  MOV     948,W4
1ED4:  CP      W4,W0
1ED6:  BRA     LE,202C
.................... 			{//niz 
.................... 				error = currentData - m->newValue; // рассогласование 
1ED8:  MOV     #A,W0
1EDA:  ADD     942,W0
1EDC:  MOV     W0,W4
1EDE:  MOV     [W4],W0
1EE0:  MOV     948,W4
1EE2:  SUB     W4,W0,W0
1EE4:  CALL    D2E
1EE8:  MOV     W0,94C
1EEA:  MOV     W1,94E
.................... 				n = ((proSost(m,currentData, error)+ intSost(m,1, error))- difSost(m, currentData)); // значение ШИМ 
1EEC:  PUSH    942
1EEE:  POP     956
1EF0:  PUSH    948
1EF2:  POP     958
1EF4:  PUSH    94C
1EF6:  POP     95A
1EF8:  PUSH    94E
1EFA:  POP     95C
1EFC:  CALL    1D56
1F00:  MOV     W0,W5
1F02:  MOV.B   #1,W0L
1F04:  MOV.B   W0L,95C
1F06:  PUSH    942
1F08:  POP     95A
1F0A:  PUSH    94C
1F0C:  POP     95E
1F0E:  PUSH    94E
1F10:  POP     960
1F12:  CALL    1D82
1F16:  ADD     W0,W5,W5
1F18:  MOV     948,W0
1F1A:  CALL    D2E
1F1E:  MOV.D   W0,W6
1F20:  PUSH    942
1F22:  POP     95E
1F24:  MOV     W6,960
1F26:  MOV     W7,962
1F28:  CALL    1E5A
1F2C:  SUB     W5,W0,W0
1F2E:  MOV     W0,94A
.................... 				if(m->upValue) // двигатели крутятся в разные стороны потому понятие верх и низ для каждого индивидуально 
1F30:  MOV     #2,W0
1F32:  ADD     942,W0
1F34:  MOV.B   [W0],W4L
1F36:  BTSS    W4.0
1F38:  BRA     1F8E
.................... 				{				// и верх совпал с макс ацп 
.................... 					switch(m->canalPwm&0xFF) // для индексов  
1F3A:  MOV     942,W0
1F3C:  MOV     [W0],W5
1F3E:  MOV     W5,W0
1F40:  AND     #FF,W0
1F42:  XOR     #3,W0
1F44:  BRA     Z,1F54
1F46:  XOR     #7,W0
1F48:  BRA     Z,1F62
1F4A:  XOR     #1,W0
1F4C:  BRA     Z,1F70
1F4E:  XOR     #3,W0
1F50:  BRA     Z,1F7E
1F52:  BRA     1F8C
.................... 					{ 
.................... 						case 3: { set_compare_time(3, n,(n+POL_PERIOD)); break; } 
1F54:  MOV     #186A,W4
1F56:  MOV     94A,W3
1F58:  ADD     W3,W4,W5
1F5A:  PUSH    94A
1F5C:  POP     18E
1F5E:  MOV     W5,18C
1F60:  BRA     1F8C
.................... 						case 4: { set_compare_time(4, n,(n+POL_PERIOD)); break; } 
1F62:  MOV     #186A,W4
1F64:  MOV     94A,W3
1F66:  ADD     W3,W4,W5
1F68:  PUSH    94A
1F6A:  POP     194
1F6C:  MOV     W5,192
1F6E:  BRA     1F8C
.................... 						case 5: { set_compare_time(5, n,(n+POL_PERIOD)); break; } 
1F70:  MOV     #186A,W4
1F72:  MOV     94A,W3
1F74:  ADD     W3,W4,W5
1F76:  PUSH    94A
1F78:  POP     19A
1F7A:  MOV     W5,198
1F7C:  BRA     1F8C
.................... 						case 6: { set_compare_time(6, n,(n+POL_PERIOD)); break; } 
1F7E:  MOV     #186A,W4
1F80:  MOV     94A,W3
1F82:  ADD     W3,W4,W5
1F84:  PUSH    94A
1F86:  POP     1A0
1F88:  MOV     W5,19E
1F8A:  BRA     1F8C
.................... 						default: {};  
.................... 					} 
.................... 				} 
1F8C:  BRA     2020
.................... 				else 
.................... 				{ 
.................... 					if(n>TIME_PWM) 
1F8E:  MOV     94A,W4
1F90:  MOV     #30D4,W3
1F92:  CP      W3,W4
1F94:  BRA     GE,1F9E
.................... 					{ 
.................... 						n = n-TIME_PWM;  
1F96:  MOV     94A,W4
1F98:  MOV     #30D4,W3
1F9A:  SUB     W4,W3,W0
1F9C:  MOV     W0,94A
.................... 					} 
.................... 					switch(m->canalPwm&0xFF) // для стрелок 
1F9E:  MOV     942,W0
1FA0:  MOV     [W0],W5
1FA2:  MOV     W5,W0
1FA4:  AND     #FF,W0
1FA6:  XOR     #3,W0
1FA8:  BRA     Z,1FB8
1FAA:  XOR     #7,W0
1FAC:  BRA     Z,1FD2
1FAE:  XOR     #1,W0
1FB0:  BRA     Z,1FEC
1FB2:  XOR     #3,W0
1FB4:  BRA     Z,2006
1FB6:  BRA     2020
.................... 					{ 
.................... 						case 3: { set_compare_time(3,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
1FB8:  MOV     #30D4,W4
1FBA:  MOV     94A,W3
1FBC:  SUB     W4,W3,W5
1FBE:  MOV     #30D4,W4
1FC0:  MOV     94A,W3
1FC2:  SUB     W4,W3,W0
1FC4:  MOV     #30D4,W4
1FC6:  SUB     W4,W0,W0
1FC8:  MOV     #186A,W4
1FCA:  SUB     W4,W0,W6
1FCC:  MOV     W5,18E
1FCE:  MOV     W6,18C
1FD0:  BRA     2020
.................... 						case 4: { set_compare_time(4,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
1FD2:  MOV     #30D4,W4
1FD4:  MOV     94A,W3
1FD6:  SUB     W4,W3,W5
1FD8:  MOV     #30D4,W4
1FDA:  MOV     94A,W3
1FDC:  SUB     W4,W3,W0
1FDE:  MOV     #30D4,W4
1FE0:  SUB     W4,W0,W0
1FE2:  MOV     #186A,W4
1FE4:  SUB     W4,W0,W6
1FE6:  MOV     W5,194
1FE8:  MOV     W6,192
1FEA:  BRA     2020
.................... 						case 5: { set_compare_time(5,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
1FEC:  MOV     #30D4,W4
1FEE:  MOV     94A,W3
1FF0:  SUB     W4,W3,W5
1FF2:  MOV     #30D4,W4
1FF4:  MOV     94A,W3
1FF6:  SUB     W4,W3,W0
1FF8:  MOV     #30D4,W4
1FFA:  SUB     W4,W0,W0
1FFC:  MOV     #186A,W4
1FFE:  SUB     W4,W0,W6
2000:  MOV     W5,19A
2002:  MOV     W6,198
2004:  BRA     2020
.................... 						case 6: { set_compare_time(6,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
2006:  MOV     #30D4,W4
2008:  MOV     94A,W3
200A:  SUB     W4,W3,W5
200C:  MOV     #30D4,W4
200E:  MOV     94A,W3
2010:  SUB     W4,W3,W0
2012:  MOV     #30D4,W4
2014:  SUB     W4,W0,W0
2016:  MOV     #186A,W4
2018:  SUB     W4,W0,W6
201A:  MOV     W5,1A0
201C:  MOV     W6,19E
201E:  BRA     2020
.................... 						default: {};  
.................... 					} 
.................... 				} 
.................... 				m->oldValAdc = currentData;  // прошлое значения для которого производился расчет Шим 
2020:  MOV     #8,W0
2022:  ADD     942,W0
2024:  MOV     W0,W5
2026:  MOV     948,W4
2028:  MOV     W4,[W5+#0]
.................... 					 
.................... 			} 
202A:  BRA     21CA
.................... 			else 
.................... 			{ 
.................... 				if(currentData<m->newValue)// направление движения 
202C:  MOV     #A,W0
202E:  ADD     942,W0
2030:  MOV     W0,W4
2032:  MOV     [W4],W0
2034:  MOV     948,W4
2036:  CP      W4,W0
2038:  BRA     GE,2186
.................... 				{//vverx 
.................... 					error = m->newValue -currentData;// рассогласование			 
203A:  MOV     #A,W0
203C:  ADD     942,W0
203E:  MOV     [W0],W5
2040:  MOV     948,W4
2042:  SUB     W5,W4,W0
2044:  CALL    D2E
2048:  MOV     W0,94C
204A:  MOV     W1,94E
.................... 			       	n = ((proSost(m,currentData, error)+ intSost(m,0, error))- difSost(m, error)); // значение ШИМ 
204C:  PUSH    942
204E:  POP     956
2050:  PUSH    948
2052:  POP     958
2054:  PUSH    94C
2056:  POP     95A
2058:  PUSH    94E
205A:  POP     95C
205C:  CALL    1D56
2060:  MOV     W0,W5
2062:  CLR.B   95C
2064:  PUSH    942
2066:  POP     95A
2068:  PUSH    94C
206A:  POP     95E
206C:  PUSH    94E
206E:  POP     960
2070:  CALL    1D82
2074:  ADD     W0,W5,W5
2076:  PUSH    942
2078:  POP     95E
207A:  PUSH    94C
207C:  POP     960
207E:  PUSH    94E
2080:  POP     962
2082:  CALL    1E5A
2086:  SUB     W5,W0,W0
2088:  MOV     W0,94A
.................... 					if(m->upValue)// двигатели крутятся в разные стороны потому понятие верх и низ для каждого индивидуально 
208A:  MOV     #2,W0
208C:  ADD     942,W0
208E:  MOV.B   [W0],W4L
2090:  BTSS    W4.0
2092:  BRA     2128
.................... 					{ 
.................... 						if(n>TIME_PWM) 
2094:  MOV     94A,W4
2096:  MOV     #30D4,W3
2098:  CP      W3,W4
209A:  BRA     GE,20A4
.................... 						{ 
.................... 							n = n-TIME_PWM;  
209C:  MOV     94A,W4
209E:  MOV     #30D4,W3
20A0:  SUB     W4,W3,W0
20A2:  MOV     W0,94A
.................... 						} 
.................... 						switch(m->canalPwm&0xFF) // для индексов  
20A4:  MOV     942,W0
20A6:  MOV     [W0],W5
20A8:  MOV     W5,W0
20AA:  AND     #FF,W0
20AC:  XOR     #3,W0
20AE:  BRA     Z,20BE
20B0:  XOR     #7,W0
20B2:  BRA     Z,20D8
20B4:  XOR     #1,W0
20B6:  BRA     Z,20F2
20B8:  XOR     #3,W0
20BA:  BRA     Z,210C
20BC:  BRA     2126
.................... 						{ 
.................... 							case 3: { set_compare_time(3,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
20BE:  MOV     #30D4,W4
20C0:  MOV     94A,W3
20C2:  SUB     W4,W3,W5
20C4:  MOV     #30D4,W4
20C6:  MOV     94A,W3
20C8:  SUB     W4,W3,W0
20CA:  MOV     #30D4,W4
20CC:  SUB     W4,W0,W0
20CE:  MOV     #186A,W4
20D0:  SUB     W4,W0,W6
20D2:  MOV     W5,18E
20D4:  MOV     W6,18C
20D6:  BRA     2126
.................... 							case 4: { set_compare_time(4,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
20D8:  MOV     #30D4,W4
20DA:  MOV     94A,W3
20DC:  SUB     W4,W3,W5
20DE:  MOV     #30D4,W4
20E0:  MOV     94A,W3
20E2:  SUB     W4,W3,W0
20E4:  MOV     #30D4,W4
20E6:  SUB     W4,W0,W0
20E8:  MOV     #186A,W4
20EA:  SUB     W4,W0,W6
20EC:  MOV     W5,194
20EE:  MOV     W6,192
20F0:  BRA     2126
.................... 							case 5: { set_compare_time(5,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
20F2:  MOV     #30D4,W4
20F4:  MOV     94A,W3
20F6:  SUB     W4,W3,W5
20F8:  MOV     #30D4,W4
20FA:  MOV     94A,W3
20FC:  SUB     W4,W3,W0
20FE:  MOV     #30D4,W4
2100:  SUB     W4,W0,W0
2102:  MOV     #186A,W4
2104:  SUB     W4,W0,W6
2106:  MOV     W5,19A
2108:  MOV     W6,198
210A:  BRA     2126
.................... 							case 6: { set_compare_time(6,(TIME_PWM-n),(POL_PERIOD-(TIME_PWM-(TIME_PWM-n)))); break; } 
210C:  MOV     #30D4,W4
210E:  MOV     94A,W3
2110:  SUB     W4,W3,W5
2112:  MOV     #30D4,W4
2114:  MOV     94A,W3
2116:  SUB     W4,W3,W0
2118:  MOV     #30D4,W4
211A:  SUB     W4,W0,W0
211C:  MOV     #186A,W4
211E:  SUB     W4,W0,W6
2120:  MOV     W5,1A0
2122:  MOV     W6,19E
2124:  BRA     2126
.................... 							default: {};  
.................... 						} 
.................... 					} 
2126:  BRA     217A
.................... 					else 
.................... 					{ 
.................... 		 
.................... 						switch(m->canalPwm&0xFF)// для стрелок 
2128:  MOV     942,W0
212A:  MOV     [W0],W5
212C:  MOV     W5,W0
212E:  AND     #FF,W0
2130:  XOR     #3,W0
2132:  BRA     Z,2142
2134:  XOR     #7,W0
2136:  BRA     Z,2150
2138:  XOR     #1,W0
213A:  BRA     Z,215E
213C:  XOR     #3,W0
213E:  BRA     Z,216C
2140:  BRA     217A
.................... 						{ 
.................... 							case 3: { set_compare_time(3, n,(n+POL_PERIOD)); break; } 
2142:  MOV     #186A,W4
2144:  MOV     94A,W3
2146:  ADD     W3,W4,W5
2148:  PUSH    94A
214A:  POP     18E
214C:  MOV     W5,18C
214E:  BRA     217A
.................... 							case 4: { set_compare_time(4, n,(n+POL_PERIOD)); break; } 
2150:  MOV     #186A,W4
2152:  MOV     94A,W3
2154:  ADD     W3,W4,W5
2156:  PUSH    94A
2158:  POP     194
215A:  MOV     W5,192
215C:  BRA     217A
.................... 							case 5: { set_compare_time(5, n,(n+POL_PERIOD)); break; } 
215E:  MOV     #186A,W4
2160:  MOV     94A,W3
2162:  ADD     W3,W4,W5
2164:  PUSH    94A
2166:  POP     19A
2168:  MOV     W5,198
216A:  BRA     217A
.................... 							case 6: { set_compare_time(6, n,(n+POL_PERIOD)); break; } 
216C:  MOV     #186A,W4
216E:  MOV     94A,W3
2170:  ADD     W3,W4,W5
2172:  PUSH    94A
2174:  POP     1A0
2176:  MOV     W5,19E
2178:  BRA     217A
.................... 							default: {};  
.................... 						} 
.................... 						 
.................... 					} 
.................... 					m->oldValAdc = currentData;  // прошлое значения для которого производился расчет Шим 
217A:  MOV     #8,W0
217C:  ADD     942,W0
217E:  MOV     W0,W5
2180:  MOV     948,W4
2182:  MOV     W4,[W5+#0]
.................... 								 
.................... 				} 
2184:  BRA     21CA
.................... 				else // двигатель стоит в заданной позиции, движение не требуется 
.................... 				{ 
.................... 					switch(m->canalPwm&0xFF) 
2186:  MOV     942,W0
2188:  MOV     [W0],W5
218A:  MOV     W5,W0
218C:  AND     #FF,W0
218E:  XOR     #3,W0
2190:  BRA     Z,21A0
2192:  XOR     #7,W0
2194:  BRA     Z,21A8
2196:  XOR     #1,W0
2198:  BRA     Z,21B0
219A:  XOR     #3,W0
219C:  BRA     Z,21B8
219E:  BRA     21C0
.................... 					{ 
.................... 						case 3: { set_compare_time(3,0,POL_PERIOD); break; } 
21A0:  CLR     18E
21A2:  MOV     #186A,W4
21A4:  MOV     W4,18C
21A6:  BRA     21C0
.................... 						case 4: { set_compare_time(4,0,POL_PERIOD); break; } 
21A8:  CLR     194
21AA:  MOV     #186A,W4
21AC:  MOV     W4,192
21AE:  BRA     21C0
.................... 						case 5: { set_compare_time(5,0,POL_PERIOD); break; } 
21B0:  CLR     19A
21B2:  MOV     #186A,W4
21B4:  MOV     W4,198
21B6:  BRA     21C0
.................... 						case 6: { set_compare_time(6,0,POL_PERIOD); break; } 
21B8:  CLR     1A0
21BA:  MOV     #186A,W4
21BC:  MOV     W4,19E
21BE:  BRA     21C0
.................... 						default: {};  
.................... 					} 
.................... 					m->oldValAdc = currentData;  // прошлое значения для которого производился расчет Шим		 
21C0:  MOV     #8,W0
21C2:  ADD     942,W0
21C4:  MOV     W0,W5
21C6:  MOV     948,W4
21C8:  MOV     W4,[W5+#0]
.................... 				} 
.................... 			} 
....................  
.................... 		} 
.................... 			 
.................... 	} 
21CA:  MOV     [--W15],W8
21CC:  MOV     [--W15],W7
21CE:  MOV     [--W15],W6
21D0:  MOV     [--W15],W5
21D2:  RETURN  
.................... 	 
.................... } 
....................  
.................... void setMaxAccel(Motor *m, int16 data) 
.................... { 
.................... 	m->maxAccel = data;  
.................... } 
....................  
.................... int16 getMinSpeed(Motor *m) 
*
0C16:  MOV     W5,[W15++]
.................... { 
....................     return m->minSpeed;   
0C18:  MOV     #1E,W0
0C1A:  ADD     980,W0
0C1C:  MOV     W0,W5
0C1E:  MOV     [W5],[W15++]
0C20:  POP     0
0C22:  MOV     [--W15],W5
0C24:  RETURN  
.................... }  
.................... int16 getMaxSpeed(Motor *m) 
0C26:  MOV     W5,[W15++]
.................... { 
....................     return m->maxSpeed;  
0C28:  MOV     #20,W0
0C2A:  ADD     980,W0
0C2C:  MOV     W0,W5
0C2E:  MOV     [W5],[W15++]
0C30:  POP     0
0C32:  MOV     [--W15],W5
0C34:  RETURN  
.................... }  
.................... int16 getMinAccel(Motor *m) 
.................... { 
....................     return m->minAccel;  
.................... }  
.................... int16 getMaxAccel(Motor *m) 
.................... { 
....................     return m->maxAccel;  
.................... }  
....................  
....................  
....................  
.................... void setIntError(Motor *m,signed int minE, signed int maxE) 
.................... { 
.................... 	m->minIEr = minE;  
.................... 	m->maxIEr = maxE;  
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #include "ioPin.c" 
.................... #include "ioPin.h" 
.................... #ifndef IOPIN_H 
.................... #define IOPIN_H 
....................  
.................... #define STATE_OUT PIN_D8 
....................  
.................... int1 getStateOutError();  
....................  
.................... #endif  
....................  
....................  
.................... int1 getStateOutError() 
*
0BA2:  BCLR.B  940.0
.................... { 
.................... 	int1 b = 0;   
.................... 	if(!input(STATE_OUT)) 
0BA4:  BSET.B  2D3.0
0BA6:  BTSC.B  2D5.0
0BA8:  BRA     BAC
.................... 	{ 
.................... 		b = 1;  
0BAA:  BSET.B  940.0
.................... 	} 
.................... 	return b;  
0BAC:  CLR     W0
0BAE:  BTSC.B  940.0
0BB0:  INC     W0,W0
0BB2:  RETURN  
.................... } 
....................  
....................  
....................  
.................... void obmenRS();  
....................  
....................  
....................  
....................  
.................... void main() 
*
2244:  MOV     #2780,W15
2246:  MOV     #27FF,W0
2248:  MOV     W0,20
224A:  NOP     
224C:  MOV     #4444,W0
224E:  MOV     W0,A8
2250:  MOV     #4444,W0
2252:  MOV     W0,B0
2254:  BSET.B  81.7
2256:  MOV     #800,W0
2258:  MOV     #FFE,W1
225A:  REPEAT  W1
225C:  CLR     [W0++]
225E:  BCLR.B  2DE.6
2260:  BCLR.B  2E2.6
2262:  CLR     800
2264:  MOV     #8000,W4
2266:  MOV     W4,220
2268:  MOV     #400,W4
226A:  MOV     W4,222
226C:  MOV     #15,W4
226E:  MOV     W4,228
2270:  CLR.B   802
2272:  BCLR.B  803.0
2274:  BCLR.B  803.1
2276:  BCLR.B  803.2
2278:  BCLR.B  803.3
227A:  BCLR.B  803.4
227C:  CLR     804
227E:  CLR     806
2280:  CLR     808
2282:  CLR     80A
2284:  CLR     80C
2286:  CLR     80E
2288:  CLR     810
228A:  CLR     812
228C:  CLR     814
228E:  CLR     816
2290:  CLR     818
2292:  CLR     81A
2294:  CLR     83C
2296:  CLR     83E
2298:  CLR     840
229A:  CLR     842
229C:  CLR     844
229E:  CLR     846
22A0:  CLR     848
22A2:  CLR     84A
22A4:  CLR.B   84C
22A6:  CLR     84E
22A8:  CLR     850
22AA:  CLR     852
22AC:  BCLR.B  803.5
22AE:  BCLR.B  803.6
22B0:  CLR     854
22B2:  CLR     856
22B4:  BCLR.B  803.7
22B6:  CLR     918
22B8:  CLR     91A
22BA:  CLR     91C
22BC:  CLR     91E
22BE:  CLR.B   84D
22C0:  CLR     920
22C2:  BCLR.B  93A.0
22C4:  MOV     #2F,W4
22C6:  MOV     W4,93C
22C8:  BCLR.B  93A.1
22CA:  CLR     93E
22CC:  SETM    32C
22CE:  SETM    32A
22D0:  CLR     81C
22D2:  CLR     81E
22D4:  CLR     820
22D6:  CLR     822
22D8:  CLR     824
22DA:  CLR     826
22DC:  CLR     828
22DE:  CLR     82A
22E0:  CLR     82C
22E2:  CLR     82E
22E4:  CLR     830
22E6:  CLR     832
22E8:  CLR     834
22EA:  CLR     836
22EC:  CLR     838
22EE:  CLR     83A
22F0:  CLR     922
22F2:  CLR     924
22F4:  CLR     926
22F6:  CLR     928
22F8:  CLR     92A
22FA:  CLR     92C
22FC:  CLR     92E
22FE:  CLR     930
2300:  CLR     932
2302:  CLR     934
2304:  CLR     936
2306:  CLR     938
.................... { 
.................... 	init_PLL();  
2308:  CALL    78A
.................... 	initRS();  
230C:  CALL    7AC
.................... 	adress = ADRES1;  
2310:  MOV.B   #85,W0L
2312:  MOV.B   W0L,802
.................... 	initDMA();  
2314:  CALL    7C4
.................... 	crc = getChecksum();  
2318:  CALL    80A
231C:  MOV     W0,93E
.................... 	initLed();  
231E:  CALL    854
.................... 	initADC();  
2322:  CALL    8A8
.................... 	initPWM();  
2326:  CALL    AB0
.................... 	 
.................... 	enable_interrupts(INTR_GLOBAL); 		 
232A:  BCLR.B  81.7
232C:  CLR     42
232E:  BSET.B  81.7
.................... 	onOffPWMCanal(0x01);  
2330:  MOV.B   #1,W0L
2332:  MOV.B   W0L,980
2334:  CALL    932
.................... 		 
.................... 	startAvtomatCalibr();  
2338:  CALL    B60
.................... 	 
....................  
....................   
.................... 	 
.................... 	while(TRUE) 
.................... 	{ 
.................... 		// отключение силовой части в случае замыкания 
.................... 		if(getStateOutError()) 
233C:  CALL    BA2
2340:  CP0.B   W0L
2342:  BRA     Z,237A
.................... 		{ 
.................... 			onOffPWMCanal(0x00); 
2344:  CLR.B   980
2346:  CALL    932
.................... 			setOrError(&m3, ERR_PWR_KZ); 
234A:  MOV.B   #10,W0L
234C:  MOV.B   W0L,984
234E:  MOV     #858,W4
2350:  MOV     W4,982
2352:  CALL    914
.................... 			setOrError(&m4, ERR_PWR_KZ); 
2356:  MOV.B   #10,W0L
2358:  MOV.B   W0L,984
235A:  MOV     #888,W4
235C:  MOV     W4,982
235E:  CALL    914
.................... 			setOrError(&m5, ERR_PWR_KZ); 
2362:  MOV.B   #10,W0L
2364:  MOV.B   W0L,984
2366:  MOV     #8B8,W4
2368:  MOV     W4,982
236A:  CALL    914
.................... 			setOrError(&m6, ERR_PWR_KZ);	 	 
236E:  MOV.B   #10,W0L
2370:  MOV.B   W0L,984
2372:  MOV     #8E8,W4
2374:  MOV     W4,982
2376:  CALL    914
.................... 		} 
.................... 	 
.................... 		readDmaAdc();  
237A:  CALL    25C
.................... 		obmenRS();  
237E:  CALL    1506
.................... 		sendDataCalibr();  
2382:  CALL    1B94
.................... 		rotate(); 
2386:  CALL    21D4
238A:  BRA     233C
.................... 	 
.................... 		 
....................  
.................... 	} 
....................  
....................  
.................... } 
....................  
238C:  PWRSAV  #0
.................... void obmenRS() 
*
1506:  MOV     W5,[W15++]
.................... { 
.................... 	if(FLAG) 
1508:  BTSS.B  93A.0
150A:  BRA     1AB4
.................... 	{ 
.................... 		if(buffer[0] == adress) 
150C:  MOV.B   922,W0L
150E:  CP.B    802
1510:  BRA     NZ,1A94
.................... 		{			 	 
.................... 			switch(buffer[1]) 
1512:  MOV.B   923,W0L
1514:  SE      W0,W0
1516:  XOR     #42,W0
1518:  BRA     Z,1548
151A:  XOR     #1,W0
151C:  BRA     Z,1590
151E:  XOR     #70,W0
1520:  BRA     Z,15A0
1522:  XOR     #72,W0
1524:  BRA     Z,17D6
1526:  XOR     #73,W0
1528:  BRA     Z,1806
152A:  XOR     #7,W0
152C:  BRA     Z,181A
152E:  XOR     #75,W0
1530:  BRA     Z,1846
1532:  XOR     #71,W0
1534:  BRA     Z,1866
1536:  XOR     #76,W0
1538:  BRA     Z,19D6
153A:  XOR     #F,W0
153C:  BRA     Z,19EA
153E:  XOR     #E,W0
1540:  BRA     Z,19FA
1542:  XOR     #13,W0
1544:  BRA     Z,1A0A
1546:  BRA     1A6C
.................... 			{	 
.................... 					case COM_READ_ERROR:  
.................... 					{ 
.................... 						int8 d3 = getError(&m3); 
.................... 						int8 d4 = getError(&m4); 
.................... 						int8 d5 = getError(&m5); 
.................... 						int8 d6 = getError(&m6); 
1548:  MOV     #858,W4
154A:  MOV     W4,97E
154C:  CALL    BB4
1550:  MOV.B   W0L,940
1552:  MOV     #888,W4
1554:  MOV     W4,97E
1556:  CALL    BB4
155A:  MOV.B   W0L,941
155C:  MOV     #8B8,W4
155E:  MOV     W4,97E
1560:  CALL    BB4
1564:  MOV.B   W0L,942
1566:  MOV     #8E8,W4
1568:  MOV     W4,97E
156A:  CALL    BB4
156E:  MOV.B   W0L,943
.................... 						ansComReadError(d3,d4,d5,d6);  
1570:  MOV.B   940,W0L
1572:  MOV.B   W0L,97E
1574:  MOV.B   941,W0L
1576:  MOV.B   W0L,97F
1578:  MOV.B   942,W0L
157A:  MOV.B   W0L,980
157C:  MOV.B   943,W0L
157E:  MOV.B   W0L,981
1580:  CALL    BDE
.................... 						runVD(LED_GREEN); 
1584:  MOV     #AAAA,W4
1586:  MOV     W4,97E
1588:  CALL    832
.................... 						indW = 0; 
158C:  CLR     920
.................... 						break;  
158E:  BRA     1A8A
.................... 	 
.................... 					}  
.................... 					case COM_READ_SPEED: 
.................... 					{ 
.................... 						ansComReadSpeed();  
1590:  CALL    C36
.................... 						runVD(LED_GREEN);  
1594:  MOV     #AAAA,W4
1596:  MOV     W4,97E
1598:  CALL    832
.................... 						indW = 0;  
159C:  CLR     920
.................... 						break;  
159E:  BRA     1A8A
.................... 					} 
.................... 					case COM_SET_SPEED:  
.................... 					{ 
.................... 						int8 canal = (buffer[2]&0xFF); 
.................... 						int1 b = 0;  
15A0:  MOV.B   924,W0L
15A2:  SE      W0,W0
15A4:  AND     #FF,W0
15A6:  MOV.B   W0L,944
15A8:  BCLR.B  945.0
....................  
.................... 						switch(canal) 
15AA:  MOV.B   944,W0L
15AC:  SE      W0,W0
15AE:  XOR     #3,W0
15B0:  BRA     Z,15C4
15B2:  XOR     #7,W0
15B4:  BRA     Z,160A
15B6:  XOR     #1,W0
15B8:  BRA     Z,1650
15BA:  XOR     #3,W0
15BC:  BRA     Z,1696
15BE:  XOR     #16,W0
15C0:  BRA     Z,16DC
15C2:  BRA     17B2
.................... 						{ 
.................... 							case SEL_SET_PWM3: {  if(indW>=7) 
15C4:  MOV     920,W4
15C6:  CP      W4,#7
15C8:  BRA     LT,1608
.................... 									   { 
.................... 									   		int16 speedMin = make16(buffer[3], buffer[4]); 
.................... 											int16 speedMax = make16(buffer[5], buffer[6]);  
15CA:  MOV.B   926,W0L
15CC:  MOV.B   W0L,946
15CE:  MOV.B   925,W0L
15D0:  MOV.B   W0L,947
15D2:  MOV.B   928,W0L
15D4:  MOV.B   W0L,948
15D6:  MOV.B   927,W0L
15D8:  MOV.B   W0L,949
.................... 									   		setMinSpeed(&m3, speedMin); 
15DA:  MOV     #858,W4
15DC:  MOV     W4,97E
15DE:  PUSH    946
15E0:  POP     980
15E2:  CALL    D78
.................... 											setMaxSpeed(&m3, speedMax); 
15E6:  MOV     #858,W4
15E8:  MOV     W4,97E
15EA:  PUSH    948
15EC:  POP     980
15EE:  CALL    F84
.................... 									   		ansComSetSpeedPwm(canal, speedMin, speedMax); 
15F2:  MOV.B   944,W0L
15F4:  MOV.B   W0L,8
15F6:  SE      W4,W3
15F8:  MOV     W3,97E
15FA:  PUSH    946
15FC:  POP     980
15FE:  PUSH    948
1600:  POP     982
1602:  CALL    FB4
.................... 											b = 1;   
1606:  BSET.B  945.0
.................... 									   } break;} 
1608:  BRA     17C4
.................... 							case SEL_SET_PWM4: {   if(indW>=7) 
160A:  MOV     920,W4
160C:  CP      W4,#7
160E:  BRA     LT,164E
.................... 									   { 
.................... 									   		int16 speedMin = make16(buffer[3], buffer[4]); 
.................... 											int16 speedMax = make16(buffer[5], buffer[6]);  
1610:  MOV.B   926,W0L
1612:  MOV.B   W0L,94A
1614:  MOV.B   925,W0L
1616:  MOV.B   W0L,94B
1618:  MOV.B   928,W0L
161A:  MOV.B   W0L,94C
161C:  MOV.B   927,W0L
161E:  MOV.B   W0L,94D
.................... 									   		setMinSpeed(&m4, speedMin); 
1620:  MOV     #888,W4
1622:  MOV     W4,97E
1624:  PUSH    94A
1626:  POP     980
1628:  CALL    D78
.................... 											setMaxSpeed(&m4, speedMax); 
162C:  MOV     #888,W4
162E:  MOV     W4,97E
1630:  PUSH    94C
1632:  POP     980
1634:  CALL    F84
.................... 									   		ansComSetSpeedPwm(canal, speedMin, speedMax); 
1638:  MOV.B   944,W0L
163A:  MOV.B   W0L,8
163C:  SE      W4,W3
163E:  MOV     W3,97E
1640:  PUSH    94A
1642:  POP     980
1644:  PUSH    94C
1646:  POP     982
1648:  CALL    FB4
.................... 											b = 1;  
164C:  BSET.B  945.0
.................... 									   } break;} 
164E:  BRA     17C4
.................... 							case SEL_SET_PWM5: {    if(indW>=7) 
1650:  MOV     920,W4
1652:  CP      W4,#7
1654:  BRA     LT,1694
.................... 									   { 
.................... 									   		int16 speedMin = make16(buffer[3], buffer[4]); 
.................... 											int16 speedMax = make16(buffer[5], buffer[6]);  
1656:  MOV.B   926,W0L
1658:  MOV.B   W0L,94E
165A:  MOV.B   925,W0L
165C:  MOV.B   W0L,94F
165E:  MOV.B   928,W0L
1660:  MOV.B   W0L,950
1662:  MOV.B   927,W0L
1664:  MOV.B   W0L,951
.................... 									   		setMinSpeed(&m5, speedMin); 
1666:  MOV     #8B8,W4
1668:  MOV     W4,97E
166A:  PUSH    94E
166C:  POP     980
166E:  CALL    D78
.................... 											setMaxSpeed(&m5, speedMax); 
1672:  MOV     #8B8,W4
1674:  MOV     W4,97E
1676:  PUSH    950
1678:  POP     980
167A:  CALL    F84
.................... 									   		ansComSetSpeedPwm(canal, speedMin, speedMax); 
167E:  MOV.B   944,W0L
1680:  MOV.B   W0L,8
1682:  SE      W4,W3
1684:  MOV     W3,97E
1686:  PUSH    94E
1688:  POP     980
168A:  PUSH    950
168C:  POP     982
168E:  CALL    FB4
.................... 											b = 1; 
1692:  BSET.B  945.0
.................... 									   } break;} 
1694:  BRA     17C4
.................... 							case SEL_SET_PWM6: {  if(indW>=7) 
1696:  MOV     920,W4
1698:  CP      W4,#7
169A:  BRA     LT,16DA
.................... 									   { 
.................... 									   		int16 speedMin = make16(buffer[3], buffer[4]); 
.................... 											int16 speedMax = make16(buffer[5], buffer[6]);  
169C:  MOV.B   926,W0L
169E:  MOV.B   W0L,952
16A0:  MOV.B   925,W0L
16A2:  MOV.B   W0L,953
16A4:  MOV.B   928,W0L
16A6:  MOV.B   W0L,954
16A8:  MOV.B   927,W0L
16AA:  MOV.B   W0L,955
.................... 									   		setMinSpeed(&m6, speedMin); 
16AC:  MOV     #8E8,W4
16AE:  MOV     W4,97E
16B0:  PUSH    952
16B2:  POP     980
16B4:  CALL    D78
.................... 											setMaxSpeed(&m6, speedMax); 
16B8:  MOV     #8E8,W4
16BA:  MOV     W4,97E
16BC:  PUSH    954
16BE:  POP     980
16C0:  CALL    F84
.................... 									   		ansComSetSpeedPwm(canal, speedMin, speedMax); 
16C4:  MOV.B   944,W0L
16C6:  MOV.B   W0L,8
16C8:  SE      W4,W3
16CA:  MOV     W3,97E
16CC:  PUSH    952
16CE:  POP     980
16D0:  PUSH    954
16D2:  POP     982
16D4:  CALL    FB4
.................... 											b = 1;  
16D8:  BSET.B  945.0
.................... 									   } break;} 
16DA:  BRA     17C4
.................... 							case SEL_SET_PWM_RK: {  if(indW>=19) 
16DC:  MOV     920,W4
16DE:  CP      W4,#13
16E0:  BRA     LT,17B0
.................... 										{ 
.................... 											int16 speedMin3 = make16(buffer[3], buffer[4]); 
.................... 											int16 speedMax3 = make16(buffer[5], buffer[6]); 
.................... 											int16 speedMin4 = make16(buffer[7], buffer[8]); 
.................... 											int16 speedMax4 = make16(buffer[9], buffer[10]); 
.................... 											int16 speedMin5 = make16(buffer[11], buffer[12]); 
.................... 											int16 speedMax5 = make16(buffer[13], buffer[14]); 
.................... 											int16 speedMin6 = make16(buffer[15], buffer[16]); 
.................... 											int16 speedMax6 = make16(buffer[17], buffer[18]);  
16E2:  MOV.B   926,W0L
16E4:  MOV.B   W0L,956
16E6:  MOV.B   925,W0L
16E8:  MOV.B   W0L,957
16EA:  MOV.B   928,W0L
16EC:  MOV.B   W0L,958
16EE:  MOV.B   927,W0L
16F0:  MOV.B   W0L,959
16F2:  MOV.B   92A,W0L
16F4:  MOV.B   W0L,95A
16F6:  MOV.B   929,W0L
16F8:  MOV.B   W0L,95B
16FA:  MOV.B   92C,W0L
16FC:  MOV.B   W0L,95C
16FE:  MOV.B   92B,W0L
1700:  MOV.B   W0L,95D
1702:  MOV.B   92E,W0L
1704:  MOV.B   W0L,95E
1706:  MOV.B   92D,W0L
1708:  MOV.B   W0L,95F
170A:  MOV.B   930,W0L
170C:  MOV.B   W0L,960
170E:  MOV.B   92F,W0L
1710:  MOV.B   W0L,961
1712:  MOV.B   932,W0L
1714:  MOV.B   W0L,962
1716:  MOV.B   931,W0L
1718:  MOV.B   W0L,963
171A:  MOV.B   934,W0L
171C:  MOV.B   W0L,964
171E:  MOV.B   933,W0L
1720:  MOV.B   W0L,965
.................... 									   		setMinSpeed(&m3, speedMin3); 
1722:  MOV     #858,W4
1724:  MOV     W4,97E
1726:  PUSH    956
1728:  POP     980
172A:  CALL    D78
.................... 											setMaxSpeed(&m3, speedMax3); 
172E:  MOV     #858,W4
1730:  MOV     W4,97E
1732:  PUSH    958
1734:  POP     980
1736:  CALL    F84
.................... 											setMinSpeed(&m4, speedMin4); 
173A:  MOV     #888,W4
173C:  MOV     W4,97E
173E:  PUSH    95A
1740:  POP     980
1742:  CALL    D78
.................... 											setMaxSpeed(&m4, speedMax4); 
1746:  MOV     #888,W4
1748:  MOV     W4,97E
174A:  PUSH    95C
174C:  POP     980
174E:  CALL    F84
.................... 											setMinSpeed(&m5, speedMin5); 
1752:  MOV     #8B8,W4
1754:  MOV     W4,97E
1756:  PUSH    95E
1758:  POP     980
175A:  CALL    D78
.................... 											setMaxSpeed(&m5, speedMax5); 
175E:  MOV     #8B8,W4
1760:  MOV     W4,97E
1762:  PUSH    960
1764:  POP     980
1766:  CALL    F84
.................... 											setMinSpeed(&m6, speedMin6); 
176A:  MOV     #8E8,W4
176C:  MOV     W4,97E
176E:  PUSH    962
1770:  POP     980
1772:  CALL    D78
.................... 											setMaxSpeed(&m6, speedMax6); 
1776:  MOV     #8E8,W4
1778:  MOV     W4,97E
177A:  PUSH    964
177C:  POP     980
177E:  CALL    F84
.................... 									   		ansComSetSpeedAllPwm(canal, speedMin3, speedMax3,speedMin4, speedMax4, 
.................... 														speedMin5, speedMax5,speedMin6, speedMax6 );  
1782:  MOV.B   944,W0L
1784:  MOV.B   W0L,8
1786:  SE      W4,W3
1788:  MOV     W3,97E
178A:  PUSH    956
178C:  POP     980
178E:  PUSH    958
1790:  POP     982
1792:  PUSH    95A
1794:  POP     984
1796:  PUSH    95C
1798:  POP     986
179A:  PUSH    95E
179C:  POP     988
179E:  PUSH    960
17A0:  POP     98A
17A2:  PUSH    962
17A4:  POP     98C
17A6:  PUSH    964
17A8:  POP     98E
17AA:  CALL    FF8
.................... 											b = 1; 
17AE:  BSET.B  945.0
.................... 										} break;} 
17B0:  BRA     17C4
.................... 		 
.................... 							default: {  runVD(LED_RED);  
17B2:  MOV     #5555,W4
17B4:  MOV     W4,97E
17B6:  CALL    832
.................... 										ansErrorComCanal(canal);  
17BA:  MOV.B   944,W0L
17BC:  MOV.B   W0L,97E
17BE:  CALL    10A8
.................... 										   break;} 
17C2:  BRA     17C4
.................... 			 
.................... 						}	 
.................... 						if(b) 
17C4:  BTSS.B  945.0
17C6:  BRA     17D2
.................... 						{				  
.................... 							runVD(LED_GREEN);   
17C8:  MOV     #AAAA,W4
17CA:  MOV     W4,97E
17CC:  CALL    832
.................... 							b = 0;  
17D0:  BCLR.B  945.0
.................... 						 
.................... 						} 
.................... 						indW = 0;	 
17D2:  CLR     920
.................... 						break;  
17D4:  BRA     1A8A
.................... 	 
.................... 					}  
.................... 					case COM_LIMIT_ADC: 
.................... 					{ 
.................... 						ansComLimitAdc(minAdc1, minAdc2, minAdc3, minAdc4, maxAdc1, 
.................... 										maxAdc2, maxAdc3, maxAdc4); 			 
17D6:  PUSH    80C
17D8:  POP     97E
17DA:  PUSH    80E
17DC:  POP     980
17DE:  PUSH    810
17E0:  POP     982
17E2:  PUSH    812
17E4:  POP     984
17E6:  PUSH    814
17E8:  POP     986
17EA:  PUSH    816
17EC:  POP     988
17EE:  PUSH    818
17F0:  POP     98A
17F2:  PUSH    81A
17F4:  POP     98C
17F6:  CALL    10C8
.................... 						runVD(LED_GREEN);  
17FA:  MOV     #AAAA,W4
17FC:  MOV     W4,97E
17FE:  CALL    832
.................... 						indW = 0;  
1802:  CLR     920
.................... 						break;  
1804:  BRA     1A8A
.................... 					} 
.................... 					case COM_RUN_CALIBR:  
.................... 					{ 
.................... 						startAvtomatCalibr();  
1806:  CALL    B60
.................... 						ansComRunCalibr(); 
180A:  CALL    1170
.................... 						runVD(LED_GREEN);  
180E:  MOV     #AAAA,W4
1810:  MOV     W4,97E
1812:  CALL    832
.................... 						indW = 0;   
1816:  CLR     920
.................... 						break; 
1818:  BRA     1A8A
.................... 					} 
.................... 					case COM_ONOFF_PWM:  
.................... 					{ 
.................... 						int8 data = (buffer[2]&0xFF);  
181A:  MOV.B   924,W0L
181C:  SE      W0,W0
181E:  AND     #FF,W0
1820:  MOV.B   W0L,966
.................... 						onOffPWMCanal(data&0x01);  
1822:  MOV.B   966,W0L
1824:  SE      W0,W0
1826:  AND     W0,#1,W5
1828:  PUSH    980
182A:  MOV.B   W5L,[W15-#2]
182C:  POP     980
182E:  CALL    932
.................... 						ansComOnOffPwm(data);  
1832:  MOV.B   966,W0L
1834:  MOV.B   W0L,97E
1836:  CALL    1188
.................... 						runVD(LED_GREEN); 
183A:  MOV     #AAAA,W4
183C:  MOV     W4,97E
183E:  CALL    832
.................... 						indW = 0;   
1842:  CLR     920
.................... 						break;  
1844:  BRA     1A8A
.................... 					} 
.................... 					case COM_READ_ADC: 
.................... 					{ 
.................... 						ansComReadCurAdc(valAdc1, valAdc2, valAdc3, valAdc4); 
1846:  PUSH    804
1848:  POP     97E
184A:  PUSH    806
184C:  POP     980
184E:  PUSH    808
1850:  POP     982
1852:  PUSH    80A
1854:  POP     984
1856:  CALL    11A8
.................... 						runVD(LED_GREEN);  
185A:  MOV     #AAAA,W4
185C:  MOV     W4,97E
185E:  CALL    832
.................... 						indW = 0;  
1862:  CLR     920
.................... 						break; 
1864:  BRA     1A8A
.................... 					} 
.................... 					case COM_SET_PWM_RK:  
.................... 					{ 
.................... 						int8 canal = (buffer[2]&0xFF); 
.................... 						int1 b = 0;  
1866:  MOV.B   924,W0L
1868:  SE      W0,W0
186A:  AND     #FF,W0
186C:  MOV.B   W0L,967
186E:  BCLR.B  945.1
....................  
.................... 						switch(canal) 
1870:  MOV.B   967,W0L
1872:  SE      W0,W0
1874:  XOR     #3,W0
1876:  BRA     Z,188E
1878:  XOR     #7,W0
187A:  BRA     Z,18B4
187C:  XOR     #1,W0
187E:  BRA     Z,18DA
1880:  XOR     #3,W0
1882:  BRA     Z,1900
1884:  XOR     #1,W0
1886:  BRA     Z,1926
1888:  XOR     #17,W0
188A:  BRA     Z,194C
188C:  BRA     19B2
.................... 						{ 
.................... 							case SEL_SET_PWM3: {  if(indW>=5) 
188E:  MOV     920,W4
1890:  CP      W4,#5
1892:  BRA     LT,18B2
.................... 									   { 
.................... 									   		int16 dPwm = make16(buffer[3], buffer[4]);  
1894:  MOV.B   926,W0L
1896:  MOV.B   W0L,968
1898:  MOV.B   925,W0L
189A:  MOV.B   W0L,969
.................... 									   		setPwm3(dPwm); 
189C:  PUSH    968
189E:  POP     990
18A0:  CALL    1208
.................... 									   		ansComSetPwm3(canal, dPwm); 
18A4:  MOV.B   967,W0L
18A6:  MOV.B   W0L,97E
18A8:  PUSH    968
18AA:  POP     980
18AC:  CALL    120E
.................... 											b = 1;   
18B0:  BSET.B  945.1
.................... 									   } break;} 
18B2:  BRA     19C4
.................... 							case SEL_SET_PWM4: {  if(indW>=5) 
18B4:  MOV     920,W4
18B6:  CP      W4,#5
18B8:  BRA     LT,18D8
.................... 									   { 
.................... 									   		int16 dPwm = make16(buffer[3], buffer[4]);  
18BA:  MOV.B   926,W0L
18BC:  MOV.B   W0L,96A
18BE:  MOV.B   925,W0L
18C0:  MOV.B   W0L,96B
.................... 									   		setPwm4(dPwm); 
18C2:  PUSH    96A
18C4:  POP     990
18C6:  CALL    1240
.................... 									   		ansComSetPwm4(canal, dPwm); 
18CA:  MOV.B   967,W0L
18CC:  MOV.B   W0L,97E
18CE:  PUSH    96A
18D0:  POP     980
18D2:  CALL    1246
.................... 											b = 1;   
18D6:  BSET.B  945.1
.................... 									   } break;} 
18D8:  BRA     19C4
.................... 							case SEL_SET_PWM5: {  if(indW>=5) 
18DA:  MOV     920,W4
18DC:  CP      W4,#5
18DE:  BRA     LT,18FE
.................... 									   { 
.................... 									   		int16 dPwm = make16(buffer[3], buffer[4]);  
18E0:  MOV.B   926,W0L
18E2:  MOV.B   W0L,96C
18E4:  MOV.B   925,W0L
18E6:  MOV.B   W0L,96D
.................... 									   		setPwm5(dPwm); 
18E8:  PUSH    96C
18EA:  POP     990
18EC:  CALL    1278
.................... 									   		ansComSetPwm5(canal, dPwm); 
18F0:  MOV.B   967,W0L
18F2:  MOV.B   W0L,97E
18F4:  PUSH    96C
18F6:  POP     980
18F8:  CALL    127E
.................... 											b = 1;   
18FC:  BSET.B  945.1
.................... 									   } break;} 
18FE:  BRA     19C4
.................... 							case SEL_SET_PWM6: {  if(indW>=5) 
1900:  MOV     920,W4
1902:  CP      W4,#5
1904:  BRA     LT,1924
.................... 									   { 
.................... 									   		int16 dPwm = make16(buffer[3], buffer[4]);  
1906:  MOV.B   926,W0L
1908:  MOV.B   W0L,96E
190A:  MOV.B   925,W0L
190C:  MOV.B   W0L,96F
.................... 									   		setPwm6(dPwm); 
190E:  PUSH    96E
1910:  POP     990
1912:  CALL    12B0
.................... 									   		ansComSetPwm6(canal, dPwm); 
1916:  MOV.B   967,W0L
1918:  MOV.B   W0L,97E
191A:  PUSH    96E
191C:  POP     980
191E:  CALL    12B6
.................... 											b = 1;   
1922:  BSET.B  945.1
.................... 									   } break;} 
1924:  BRA     19C4
.................... 							case SEL_SET_RK: {  if(indW>=4) 
1926:  MOV     920,W4
1928:  CP      W4,#4
192A:  BRA     LT,194A
.................... 									   { 
.................... 									   		int8 dRk = (buffer[3]&0xFF);   
192C:  MOV.B   925,W0L
192E:  SE      W0,W0
1930:  AND     #FF,W0
1932:  MOV.B   W0L,970
.................... 									   		setRk(dRk);  
1934:  MOV.B   970,W0L
1936:  MOV.B   W0L,990
1938:  CALL    1312
.................... 									   		ansComSetRk(canal, dRk); 
193C:  MOV.B   967,W0L
193E:  MOV.B   W0L,97E
1940:  MOV.B   970,W0L
1942:  MOV.B   W0L,97F
1944:  CALL    131C
.................... 											b = 1;   
1948:  BSET.B  945.1
.................... 									   } break;} 
194A:  BRA     19C4
.................... 							case SEL_SET_PWM_RK: {  if(indW>=12) 
194C:  MOV     920,W4
194E:  CP      W4,#C
1950:  BRA     LT,19B0
.................... 										{ 
.................... 											int16 dPwm3 = make16(buffer[3], buffer[4]);  
.................... 											int16 dPwm4 = make16(buffer[5], buffer[6]); 
.................... 											int16 dPwm5 = make16(buffer[7], buffer[8]); 
.................... 											int16 dPwm6 = make16(buffer[9], buffer[10]); 
.................... 											int8 dRk = (buffer[11]&0xFF);    
1952:  MOV.B   926,W0L
1954:  MOV.B   W0L,972
1956:  MOV.B   925,W0L
1958:  MOV.B   W0L,973
195A:  MOV.B   928,W0L
195C:  MOV.B   W0L,974
195E:  MOV.B   927,W0L
1960:  MOV.B   W0L,975
1962:  MOV.B   92A,W0L
1964:  MOV.B   W0L,976
1966:  MOV.B   929,W0L
1968:  MOV.B   W0L,977
196A:  MOV.B   92C,W0L
196C:  MOV.B   W0L,978
196E:  MOV.B   92B,W0L
1970:  MOV.B   W0L,979
1972:  MOV.B   92D,W0L
1974:  SE      W0,W0
1976:  AND     #FF,W0
1978:  MOV.B   W0L,971
.................... 											setPwm3456(dPwm3, dPwm4, dPwm5, dPwm6, dRk); 
197A:  MOV.B   971,W0L
197C:  MOV.B   W0L,986
197E:  PUSH    972
1980:  POP     97E
1982:  PUSH    974
1984:  POP     980
1986:  PUSH    976
1988:  POP     982
198A:  PUSH    978
198C:  POP     984
198E:  CALL    1344
.................... 									 		ansComSetPwmRk(canal, dPwm3, dPwm4, dPwm5, dPwm6, dRk);  
1992:  MOV.B   967,W0L
1994:  MOV.B   W0L,97E
1996:  MOV.B   971,W0L
1998:  MOV.B   W0L,97F
199A:  PUSH    972
199C:  POP     980
199E:  PUSH    974
19A0:  POP     982
19A2:  PUSH    976
19A4:  POP     984
19A6:  PUSH    978
19A8:  POP     986
19AA:  CALL    136E
.................... 											b = 1; 
19AE:  BSET.B  945.1
.................... 										} break;} 
19B0:  BRA     19C4
.................... 		 
.................... 							default: {  runVD(LED_RED);  
19B2:  MOV     #5555,W4
19B4:  MOV     W4,97E
19B6:  CALL    832
.................... 										ansErrorComCanal(canal);  
19BA:  MOV.B   967,W0L
19BC:  MOV.B   W0L,97E
19BE:  CALL    10A8
.................... 										   break;} 
19C2:  BRA     19C4
.................... 			 
.................... 						}	 
.................... 						if(b) 
19C4:  BTSS.B  945.1
19C6:  BRA     19D2
.................... 						{				  
.................... 							runVD(LED_GREEN);   
19C8:  MOV     #AAAA,W4
19CA:  MOV     W4,97E
19CC:  CALL    832
.................... 							b = 0;  
19D0:  BCLR.B  945.1
.................... 						 
.................... 						} 
.................... 						indW = 0;	 
19D2:  CLR     920
.................... 						break;  
19D4:  BRA     1A8A
.................... 					}  
....................  
.................... 				//**************************************** 
.................... 				// CRC 
.................... 				case COM_READ_CRC: 
.................... 				{ 
.................... 						ansReadCrc(crc); 
19D6:  PUSH    93E
19D8:  POP     97E
19DA:  CALL    13DE
.................... 						runVD(LED_GREEN); 
19DE:  MOV     #AAAA,W4
19E0:  MOV     W4,97E
19E2:  CALL    832
.................... 						indW = 0; 
19E6:  CLR     920
.................... 					 
.................... 					break;  
19E8:  BRA     1A8A
.................... 				} 
.................... 				case COM_INFO: 
.................... 				{ 
.................... 						ansComInfo(); 
19EA:  CALL    1412
.................... 						runVD(LED_GREEN); 
19EE:  MOV     #AAAA,W4
19F0:  MOV     W4,97E
19F2:  CALL    832
.................... 						indW = 0; 
19F6:  CLR     920
.................... 					 
.................... 					break;  
19F8:  BRA     1A8A
.................... 				} 
.................... 				case COM_READ_ID: 
.................... 				{ 
.................... 						ansComId(); 
19FA:  CALL    1480
.................... 						runVD(LED_GREEN); 
19FE:  MOV     #AAAA,W4
1A00:  MOV     W4,97E
1A02:  CALL    832
.................... 						indW = 0; 
1A06:  CLR     920
.................... 					 
.................... 					break;  
1A08:  BRA     1A8A
.................... 				} 
.................... 				case COM_RESET_MK: 
.................... 				{ 
.................... 					int d = (buffer[2]&0xFF);  
1A0A:  MOV.B   924,W0L
1A0C:  SE      W0,W0
1A0E:  MOV     W0,W4
1A10:  AND     #FF,W4
1A12:  MOV     W4,97A
.................... 					switch (d) 
1A14:  MOV     97A,W0
1A16:  XOR     #AA,W0
1A18:  BRA     Z,1A1C
1A1A:  BRA     1A42
.................... 					{ 
.................... 						case 0xAA: 
.................... 						{ 
.................... 							sendRS(buffer[0]);  
1A1C:  MOV.B   922,W0L
1A1E:  MOV.B   W0L,97E
1A20:  CALL    14B8
.................... 							sendRS(buffer[1]); 
1A24:  MOV.B   923,W0L
1A26:  MOV.B   W0L,97E
1A28:  CALL    14B8
.................... 							sendRS(buffer[2]); 
1A2C:  MOV.B   924,W0L
1A2E:  MOV.B   W0L,97E
1A30:  CALL    14B8
.................... 							runVD(LED_GREEN);  
1A34:  MOV     #AAAA,W4
1A36:  MOV     W4,97E
1A38:  CALL    832
.................... 							reset_cpu();  
1A3C:  RESET   
.................... 							indW=0; 
1A3E:  CLR     920
.................... 							break;  
1A40:  BRA     1A68
.................... 						} 
.................... 						default:  
.................... 						{ 
.................... 							ansComRst(((~buffer[1])&0xFF), buffer[2]);  
1A42:  COM.B   0923,W0L
1A44:  CLR.B   1
1A46:  MOV.B   W0L,W5L
1A48:  AND     #FF,W5
1A4A:  PUSH    980
1A4C:  MOV.B   W5L,[W15-#2]
1A4E:  POP     980
1A50:  MOV     W0,[W15++]
1A52:  MOV.B   924,W0L
1A54:  MOV.B   W0L,981
1A56:  MOV     [--W15],W0
1A58:  CALL    14D2
.................... 							runVD(LED_RED); 
1A5C:  MOV     #5555,W4
1A5E:  MOV     W4,97E
1A60:  CALL    832
.................... 							indW=0;  
1A64:  CLR     920
.................... 							break;  
1A66:  BRA     1A68
.................... 						 
....................  
.................... 						}  
.................... 					} 
.................... 					indW = 0; 
1A68:  CLR     920
.................... 					 
.................... 					break;  
1A6A:  BRA     1A8A
.................... 				} 
.................... 				default: 
.................... 				{ 
.................... 					ansErrorCom(buffer[1]&0xFF);  
1A6C:  MOV.B   923,W0L
1A6E:  SE      W0,W0
1A70:  MOV     W0,W5
1A72:  AND     #FF,W5
1A74:  PUSH    980
1A76:  MOV.B   W5L,[W15-#2]
1A78:  POP     980
1A7A:  CALL    14F0
.................... 					runVD(LED_RED); 
1A7E:  MOV     #5555,W4
1A80:  MOV     W4,97E
1A82:  CALL    832
.................... 					indW = 0; 
1A86:  CLR     920
.................... 				 
.................... 					break; 
1A88:  BRA     1A8A
.................... 				 
.................... 				}  
....................  
.................... 			} 
.................... 			 
.................... 			buffer[0]=0; 
1A8A:  CLR.B   922
.................... 			buffer[1]=0;  
1A8C:  CLR.B   923
.................... 			buffer[2]=0; 
1A8E:  CLR.B   924
.................... 			indW = 0;  
1A90:  CLR     920
.................... 		} 
1A92:  BRA     1A96
.................... 		else 
.................... 		{ 
.................... 		 
.................... 			indW = 0;  
1A94:  CLR     920
.................... 	 
.................... 		} 
.................... 	 
.................... 	 
.................... 	 
.................... 		 
.................... 		 
.................... 		flag = 0;  
1A96:  BCLR.B  93A.0
....................  
.................... 		if(indW>SIZE_RS_BUFFER) 
1A98:  MOV     920,W4
1A9A:  CP      W4,#18
1A9C:  BRA     LE,1AB4
.................... 		{ 
.................... 			indW = 0; 
1A9E:  CLR     920
.................... 			buffer[0]=0; 
1AA0:  CLR.B   922
.................... 			buffer[1]=0;  
1AA2:  CLR.B   923
.................... 			buffer[2]=0; 
1AA4:  CLR.B   924
.................... 			buffer[3]=0;  
1AA6:  CLR.B   925
.................... 			buffer[4]=0;  
1AA8:  CLR.B   926
.................... 			buffer[5]=0;  
1AAA:  CLR.B   927
.................... 			buffer[6]=0;  
1AAC:  CLR.B   928
.................... 			buffer[7]=0;  
1AAE:  CLR.B   929
.................... 			buffer[8]=0; 
1AB0:  CLR.B   92A
.................... 			buffer[9]=0;    
1AB2:  CLR.B   92B
.................... 		} 
.................... 	} 
1AB4:  MOV     [--W15],W5
1AB6:  RETURN  
....................  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: 0000  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: 0000  
   Word  3L: 0007   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 0083   PR_PLL IESO
          H: 0000  
   Word  5L: 00C6   HS NOOSCIO
          H: 0000  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00E6   PUT64
          H: 0000  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: 0000  

ROM data:
00ABFE: BE9D                                       ..
